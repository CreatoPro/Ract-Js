{"ast":null,"code":"/*! @name mux.js @version 6.0.1 @license Apache-2.0 */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('global/window')) : typeof define === 'function' && define.amd ? define(['global/window'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.muxjs = factory(global.window));\n})(this, function (window) {\n  'use strict';\n\n  function _interopDefaultLegacy(e) {\n    return e && typeof e === 'object' && 'default' in e ? e : {\n      'default': e\n    };\n  }\n\n  var window__default = /*#__PURE__*/_interopDefaultLegacy(window);\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   *\n   * A lightweight readable stream implemention that handles event dispatching.\n   * Objects that inherit from streams should call init in their constructors.\n   */\n\n\n  var Stream = function Stream() {\n    this.init = function () {\n      var listeners = {};\n      /**\n       * Add a listener for a specified event type.\n       * @param type {string} the event name\n       * @param listener {function} the callback to be invoked when an event of\n       * the specified type occurs\n       */\n\n      this.on = function (type, listener) {\n        if (!listeners[type]) {\n          listeners[type] = [];\n        }\n\n        listeners[type] = listeners[type].concat(listener);\n      };\n      /**\n       * Remove a listener for a specified event type.\n       * @param type {string} the event name\n       * @param listener {function} a function previously registered for this\n       * type of event through `on`\n       */\n\n\n      this.off = function (type, listener) {\n        var index;\n\n        if (!listeners[type]) {\n          return false;\n        }\n\n        index = listeners[type].indexOf(listener);\n        listeners[type] = listeners[type].slice();\n        listeners[type].splice(index, 1);\n        return index > -1;\n      };\n      /**\n       * Trigger an event of the specified type on this stream. Any additional\n       * arguments to this function are passed as parameters to event listeners.\n       * @param type {string} the event name\n       */\n\n\n      this.trigger = function (type) {\n        var callbacks, i, length, args;\n        callbacks = listeners[type];\n\n        if (!callbacks) {\n          return;\n        } // Slicing the arguments on every invocation of this method\n        // can add a significant amount of overhead. Avoid the\n        // intermediate object creation for the common case of a\n        // single callback argument\n\n\n        if (arguments.length === 2) {\n          length = callbacks.length;\n\n          for (i = 0; i < length; ++i) {\n            callbacks[i].call(this, arguments[1]);\n          }\n        } else {\n          args = [];\n          i = arguments.length;\n\n          for (i = 1; i < arguments.length; ++i) {\n            args.push(arguments[i]);\n          }\n\n          length = callbacks.length;\n\n          for (i = 0; i < length; ++i) {\n            callbacks[i].apply(this, args);\n          }\n        }\n      };\n      /**\n       * Destroys the stream and cleans up.\n       */\n\n\n      this.dispose = function () {\n        listeners = {};\n      };\n    };\n  };\n  /**\n   * Forwards all `data` events on this stream to the destination stream. The\n   * destination stream should provide a method `push` to receive the data\n   * events as they arrive.\n   * @param destination {stream} the stream that will receive all `data` events\n   * @param autoFlush {boolean} if false, we will not call `flush` on the destination\n   *                            when the current stream emits a 'done' event\n   * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n   */\n\n\n  Stream.prototype.pipe = function (destination) {\n    this.on('data', function (data) {\n      destination.push(data);\n    });\n    this.on('done', function (flushSource) {\n      destination.flush(flushSource);\n    });\n    this.on('partialdone', function (flushSource) {\n      destination.partialFlush(flushSource);\n    });\n    this.on('endedtimeline', function (flushSource) {\n      destination.endTimeline(flushSource);\n    });\n    this.on('reset', function (flushSource) {\n      destination.reset(flushSource);\n    });\n    return destination;\n  }; // Default stream functions that are expected to be overridden to perform\n  // actual work. These are provided by the prototype as a sort of no-op\n  // implementation so that we don't have to check for their existence in the\n  // `pipe` function above.\n\n\n  Stream.prototype.push = function (data) {\n    this.trigger('data', data);\n  };\n\n  Stream.prototype.flush = function (flushSource) {\n    this.trigger('done', flushSource);\n  };\n\n  Stream.prototype.partialFlush = function (flushSource) {\n    this.trigger('partialdone', flushSource);\n  };\n\n  Stream.prototype.endTimeline = function (flushSource) {\n    this.trigger('endedtimeline', flushSource);\n  };\n\n  Stream.prototype.reset = function (flushSource) {\n    this.trigger('reset', flushSource);\n  };\n\n  var stream = Stream;\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n\n  var ONE_SECOND_IN_TS$5 = 90000,\n      // 90kHz clock\n  secondsToVideoTs,\n      secondsToAudioTs,\n      videoTsToSeconds,\n      audioTsToSeconds,\n      audioTsToVideoTs,\n      videoTsToAudioTs,\n      metadataTsToSeconds;\n\n  secondsToVideoTs = function secondsToVideoTs(seconds) {\n    return seconds * ONE_SECOND_IN_TS$5;\n  };\n\n  secondsToAudioTs = function secondsToAudioTs(seconds, sampleRate) {\n    return seconds * sampleRate;\n  };\n\n  videoTsToSeconds = function videoTsToSeconds(timestamp) {\n    return timestamp / ONE_SECOND_IN_TS$5;\n  };\n\n  audioTsToSeconds = function audioTsToSeconds(timestamp, sampleRate) {\n    return timestamp / sampleRate;\n  };\n\n  audioTsToVideoTs = function audioTsToVideoTs(timestamp, sampleRate) {\n    return secondsToVideoTs(audioTsToSeconds(timestamp, sampleRate));\n  };\n\n  videoTsToAudioTs = function videoTsToAudioTs(timestamp, sampleRate) {\n    return secondsToAudioTs(videoTsToSeconds(timestamp), sampleRate);\n  };\n  /**\n   * Adjust ID3 tag or caption timing information by the timeline pts values\n   * (if keepOriginalTimestamps is false) and convert to seconds\n   */\n\n\n  metadataTsToSeconds = function metadataTsToSeconds(timestamp, timelineStartPts, keepOriginalTimestamps) {\n    return videoTsToSeconds(keepOriginalTimestamps ? timestamp : timestamp - timelineStartPts);\n  };\n\n  var clock = {\n    ONE_SECOND_IN_TS: ONE_SECOND_IN_TS$5,\n    secondsToVideoTs: secondsToVideoTs,\n    secondsToAudioTs: secondsToAudioTs,\n    videoTsToSeconds: videoTsToSeconds,\n    audioTsToSeconds: audioTsToSeconds,\n    audioTsToVideoTs: audioTsToVideoTs,\n    videoTsToAudioTs: videoTsToAudioTs,\n    metadataTsToSeconds: metadataTsToSeconds\n  };\n  var ONE_SECOND_IN_TS$4 = clock.ONE_SECOND_IN_TS;\n\n  var _AdtsStream;\n\n  var ADTS_SAMPLING_FREQUENCIES$1 = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n  /*\n   * Accepts a ElementaryStream and emits data events with parsed\n   * AAC Audio Frames of the individual packets. Input audio in ADTS\n   * format is unpacked and re-emitted as AAC frames.\n   *\n   * @see http://wiki.multimedia.cx/index.php?title=ADTS\n   * @see http://wiki.multimedia.cx/?title=Understanding_AAC\n   */\n\n  _AdtsStream = function AdtsStream(handlePartialSegments) {\n    var buffer,\n        frameNum = 0;\n\n    _AdtsStream.prototype.init.call(this);\n\n    this.skipWarn_ = function (start, end) {\n      this.trigger('log', {\n        level: 'warn',\n        message: \"adts skiping bytes \" + start + \" to \" + end + \" in frame \" + frameNum + \" outside syncword\"\n      });\n    };\n\n    this.push = function (packet) {\n      var i = 0,\n          frameLength,\n          protectionSkipBytes,\n          oldBuffer,\n          sampleCount,\n          adtsFrameDuration;\n\n      if (!handlePartialSegments) {\n        frameNum = 0;\n      }\n\n      if (packet.type !== 'audio') {\n        // ignore non-audio data\n        return;\n      } // Prepend any data in the buffer to the input data so that we can parse\n      // aac frames the cross a PES packet boundary\n\n\n      if (buffer && buffer.length) {\n        oldBuffer = buffer;\n        buffer = new Uint8Array(oldBuffer.byteLength + packet.data.byteLength);\n        buffer.set(oldBuffer);\n        buffer.set(packet.data, oldBuffer.byteLength);\n      } else {\n        buffer = packet.data;\n      } // unpack any ADTS frames which have been fully received\n      // for details on the ADTS header, see http://wiki.multimedia.cx/index.php?title=ADTS\n\n\n      var skip; // We use i + 7 here because we want to be able to parse the entire header.\n      // If we don't have enough bytes to do that, then we definitely won't have a full frame.\n\n      while (i + 7 < buffer.length) {\n        // Look for the start of an ADTS header..\n        if (buffer[i] !== 0xFF || (buffer[i + 1] & 0xF6) !== 0xF0) {\n          if (typeof skip !== 'number') {\n            skip = i;\n          } // If a valid header was not found,  jump one forward and attempt to\n          // find a valid ADTS header starting at the next byte\n\n\n          i++;\n          continue;\n        }\n\n        if (typeof skip === 'number') {\n          this.skipWarn_(skip, i);\n          skip = null;\n        } // The protection skip bit tells us if we have 2 bytes of CRC data at the\n        // end of the ADTS header\n\n\n        protectionSkipBytes = (~buffer[i + 1] & 0x01) * 2; // Frame length is a 13 bit integer starting 16 bits from the\n        // end of the sync sequence\n        // NOTE: frame length includes the size of the header\n\n        frameLength = (buffer[i + 3] & 0x03) << 11 | buffer[i + 4] << 3 | (buffer[i + 5] & 0xe0) >> 5;\n        sampleCount = ((buffer[i + 6] & 0x03) + 1) * 1024;\n        adtsFrameDuration = sampleCount * ONE_SECOND_IN_TS$4 / ADTS_SAMPLING_FREQUENCIES$1[(buffer[i + 2] & 0x3c) >>> 2]; // If we don't have enough data to actually finish this ADTS frame,\n        // then we have to wait for more data\n\n        if (buffer.byteLength - i < frameLength) {\n          break;\n        } // Otherwise, deliver the complete AAC frame\n\n\n        this.trigger('data', {\n          pts: packet.pts + frameNum * adtsFrameDuration,\n          dts: packet.dts + frameNum * adtsFrameDuration,\n          sampleCount: sampleCount,\n          audioobjecttype: (buffer[i + 2] >>> 6 & 0x03) + 1,\n          channelcount: (buffer[i + 2] & 1) << 2 | (buffer[i + 3] & 0xc0) >>> 6,\n          samplerate: ADTS_SAMPLING_FREQUENCIES$1[(buffer[i + 2] & 0x3c) >>> 2],\n          samplingfrequencyindex: (buffer[i + 2] & 0x3c) >>> 2,\n          // assume ISO/IEC 14496-12 AudioSampleEntry default of 16\n          samplesize: 16,\n          // data is the frame without it's header\n          data: buffer.subarray(i + 7 + protectionSkipBytes, i + frameLength)\n        });\n        frameNum++;\n        i += frameLength;\n      }\n\n      if (typeof skip === 'number') {\n        this.skipWarn_(skip, i);\n        skip = null;\n      } // remove processed bytes from the buffer.\n\n\n      buffer = buffer.subarray(i);\n    };\n\n    this.flush = function () {\n      frameNum = 0;\n      this.trigger('done');\n    };\n\n    this.reset = function () {\n      buffer = void 0;\n      this.trigger('reset');\n    };\n\n    this.endTimeline = function () {\n      buffer = void 0;\n      this.trigger('endedtimeline');\n    };\n  };\n\n  _AdtsStream.prototype = new stream();\n  var adts = _AdtsStream;\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n\n  var ExpGolomb;\n  /**\n   * Parser for exponential Golomb codes, a variable-bitwidth number encoding\n   * scheme used by h264.\n   */\n\n  ExpGolomb = function ExpGolomb(workingData) {\n    var // the number of bytes left to examine in workingData\n    workingBytesAvailable = workingData.byteLength,\n        // the current word being examined\n    workingWord = 0,\n        // :uint\n    // the number of bits left to examine in the current word\n    workingBitsAvailable = 0; // :uint;\n    // ():uint\n\n    this.length = function () {\n      return 8 * workingBytesAvailable;\n    }; // ():uint\n\n\n    this.bitsAvailable = function () {\n      return 8 * workingBytesAvailable + workingBitsAvailable;\n    }; // ():void\n\n\n    this.loadWord = function () {\n      var position = workingData.byteLength - workingBytesAvailable,\n          workingBytes = new Uint8Array(4),\n          availableBytes = Math.min(4, workingBytesAvailable);\n\n      if (availableBytes === 0) {\n        throw new Error('no bytes available');\n      }\n\n      workingBytes.set(workingData.subarray(position, position + availableBytes));\n      workingWord = new DataView(workingBytes.buffer).getUint32(0); // track the amount of workingData that has been processed\n\n      workingBitsAvailable = availableBytes * 8;\n      workingBytesAvailable -= availableBytes;\n    }; // (count:int):void\n\n\n    this.skipBits = function (count) {\n      var skipBytes; // :int\n\n      if (workingBitsAvailable > count) {\n        workingWord <<= count;\n        workingBitsAvailable -= count;\n      } else {\n        count -= workingBitsAvailable;\n        skipBytes = Math.floor(count / 8);\n        count -= skipBytes * 8;\n        workingBytesAvailable -= skipBytes;\n        this.loadWord();\n        workingWord <<= count;\n        workingBitsAvailable -= count;\n      }\n    }; // (size:int):uint\n\n\n    this.readBits = function (size) {\n      var bits = Math.min(workingBitsAvailable, size),\n          // :uint\n      valu = workingWord >>> 32 - bits; // :uint\n      // if size > 31, handle error\n\n      workingBitsAvailable -= bits;\n\n      if (workingBitsAvailable > 0) {\n        workingWord <<= bits;\n      } else if (workingBytesAvailable > 0) {\n        this.loadWord();\n      }\n\n      bits = size - bits;\n\n      if (bits > 0) {\n        return valu << bits | this.readBits(bits);\n      }\n\n      return valu;\n    }; // ():uint\n\n\n    this.skipLeadingZeros = function () {\n      var leadingZeroCount; // :uint\n\n      for (leadingZeroCount = 0; leadingZeroCount < workingBitsAvailable; ++leadingZeroCount) {\n        if ((workingWord & 0x80000000 >>> leadingZeroCount) !== 0) {\n          // the first bit of working word is 1\n          workingWord <<= leadingZeroCount;\n          workingBitsAvailable -= leadingZeroCount;\n          return leadingZeroCount;\n        }\n      } // we exhausted workingWord and still have not found a 1\n\n\n      this.loadWord();\n      return leadingZeroCount + this.skipLeadingZeros();\n    }; // ():void\n\n\n    this.skipUnsignedExpGolomb = function () {\n      this.skipBits(1 + this.skipLeadingZeros());\n    }; // ():void\n\n\n    this.skipExpGolomb = function () {\n      this.skipBits(1 + this.skipLeadingZeros());\n    }; // ():uint\n\n\n    this.readUnsignedExpGolomb = function () {\n      var clz = this.skipLeadingZeros(); // :uint\n\n      return this.readBits(clz + 1) - 1;\n    }; // ():int\n\n\n    this.readExpGolomb = function () {\n      var valu = this.readUnsignedExpGolomb(); // :int\n\n      if (0x01 & valu) {\n        // the number is odd if the low order bit is set\n        return 1 + valu >>> 1; // add 1 to make it even, and divide by 2\n      }\n\n      return -1 * (valu >>> 1); // divide by two then make it negative\n    }; // Some convenience functions\n    // :Boolean\n\n\n    this.readBoolean = function () {\n      return this.readBits(1) === 1;\n    }; // ():int\n\n\n    this.readUnsignedByte = function () {\n      return this.readBits(8);\n    };\n\n    this.loadWord();\n  };\n\n  var expGolomb = ExpGolomb;\n\n  var _H264Stream, _NalByteStream;\n\n  var PROFILES_WITH_OPTIONAL_SPS_DATA;\n  /**\n   * Accepts a NAL unit byte stream and unpacks the embedded NAL units.\n   */\n\n  _NalByteStream = function NalByteStream() {\n    var syncPoint = 0,\n        i,\n        buffer;\n\n    _NalByteStream.prototype.init.call(this);\n    /*\n     * Scans a byte stream and triggers a data event with the NAL units found.\n     * @param {Object} data Event received from H264Stream\n     * @param {Uint8Array} data.data The h264 byte stream to be scanned\n     *\n     * @see H264Stream.push\n     */\n\n\n    this.push = function (data) {\n      var swapBuffer;\n\n      if (!buffer) {\n        buffer = data.data;\n      } else {\n        swapBuffer = new Uint8Array(buffer.byteLength + data.data.byteLength);\n        swapBuffer.set(buffer);\n        swapBuffer.set(data.data, buffer.byteLength);\n        buffer = swapBuffer;\n      }\n\n      var len = buffer.byteLength; // Rec. ITU-T H.264, Annex B\n      // scan for NAL unit boundaries\n      // a match looks like this:\n      // 0 0 1 .. NAL .. 0 0 1\n      // ^ sync point        ^ i\n      // or this:\n      // 0 0 1 .. NAL .. 0 0 0\n      // ^ sync point        ^ i\n      // advance the sync point to a NAL start, if necessary\n\n      for (; syncPoint < len - 3; syncPoint++) {\n        if (buffer[syncPoint + 2] === 1) {\n          // the sync point is properly aligned\n          i = syncPoint + 5;\n          break;\n        }\n      }\n\n      while (i < len) {\n        // look at the current byte to determine if we've hit the end of\n        // a NAL unit boundary\n        switch (buffer[i]) {\n          case 0:\n            // skip past non-sync sequences\n            if (buffer[i - 1] !== 0) {\n              i += 2;\n              break;\n            } else if (buffer[i - 2] !== 0) {\n              i++;\n              break;\n            } // deliver the NAL unit if it isn't empty\n\n\n            if (syncPoint + 3 !== i - 2) {\n              this.trigger('data', buffer.subarray(syncPoint + 3, i - 2));\n            } // drop trailing zeroes\n\n\n            do {\n              i++;\n            } while (buffer[i] !== 1 && i < len);\n\n            syncPoint = i - 2;\n            i += 3;\n            break;\n\n          case 1:\n            // skip past non-sync sequences\n            if (buffer[i - 1] !== 0 || buffer[i - 2] !== 0) {\n              i += 3;\n              break;\n            } // deliver the NAL unit\n\n\n            this.trigger('data', buffer.subarray(syncPoint + 3, i - 2));\n            syncPoint = i - 2;\n            i += 3;\n            break;\n\n          default:\n            // the current byte isn't a one or zero, so it cannot be part\n            // of a sync sequence\n            i += 3;\n            break;\n        }\n      } // filter out the NAL units that were delivered\n\n\n      buffer = buffer.subarray(syncPoint);\n      i -= syncPoint;\n      syncPoint = 0;\n    };\n\n    this.reset = function () {\n      buffer = null;\n      syncPoint = 0;\n      this.trigger('reset');\n    };\n\n    this.flush = function () {\n      // deliver the last buffered NAL unit\n      if (buffer && buffer.byteLength > 3) {\n        this.trigger('data', buffer.subarray(syncPoint + 3));\n      } // reset the stream state\n\n\n      buffer = null;\n      syncPoint = 0;\n      this.trigger('done');\n    };\n\n    this.endTimeline = function () {\n      this.flush();\n      this.trigger('endedtimeline');\n    };\n  };\n\n  _NalByteStream.prototype = new stream(); // values of profile_idc that indicate additional fields are included in the SPS\n  // see Recommendation ITU-T H.264 (4/2013),\n  // 7.3.2.1.1 Sequence parameter set data syntax\n\n  PROFILES_WITH_OPTIONAL_SPS_DATA = {\n    100: true,\n    110: true,\n    122: true,\n    244: true,\n    44: true,\n    83: true,\n    86: true,\n    118: true,\n    128: true,\n    // TODO: the three profiles below don't\n    // appear to have sps data in the specificiation anymore?\n    138: true,\n    139: true,\n    134: true\n  };\n  /**\n   * Accepts input from a ElementaryStream and produces H.264 NAL unit data\n   * events.\n   */\n\n  _H264Stream = function H264Stream() {\n    var nalByteStream = new _NalByteStream(),\n        self,\n        trackId,\n        currentPts,\n        currentDts,\n        discardEmulationPreventionBytes,\n        readSequenceParameterSet,\n        skipScalingList;\n\n    _H264Stream.prototype.init.call(this);\n\n    self = this;\n    /*\n     * Pushes a packet from a stream onto the NalByteStream\n     *\n     * @param {Object} packet - A packet received from a stream\n     * @param {Uint8Array} packet.data - The raw bytes of the packet\n     * @param {Number} packet.dts - Decode timestamp of the packet\n     * @param {Number} packet.pts - Presentation timestamp of the packet\n     * @param {Number} packet.trackId - The id of the h264 track this packet came from\n     * @param {('video'|'audio')} packet.type - The type of packet\n     *\n     */\n\n    this.push = function (packet) {\n      if (packet.type !== 'video') {\n        return;\n      }\n\n      trackId = packet.trackId;\n      currentPts = packet.pts;\n      currentDts = packet.dts;\n      nalByteStream.push(packet);\n    };\n    /*\n     * Identify NAL unit types and pass on the NALU, trackId, presentation and decode timestamps\n     * for the NALUs to the next stream component.\n     * Also, preprocess caption and sequence parameter NALUs.\n     *\n     * @param {Uint8Array} data - A NAL unit identified by `NalByteStream.push`\n     * @see NalByteStream.push\n     */\n\n\n    nalByteStream.on('data', function (data) {\n      var event = {\n        trackId: trackId,\n        pts: currentPts,\n        dts: currentDts,\n        data: data,\n        nalUnitTypeCode: data[0] & 0x1f\n      };\n\n      switch (event.nalUnitTypeCode) {\n        case 0x05:\n          event.nalUnitType = 'slice_layer_without_partitioning_rbsp_idr';\n          break;\n\n        case 0x06:\n          event.nalUnitType = 'sei_rbsp';\n          event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));\n          break;\n\n        case 0x07:\n          event.nalUnitType = 'seq_parameter_set_rbsp';\n          event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));\n          event.config = readSequenceParameterSet(event.escapedRBSP);\n          break;\n\n        case 0x08:\n          event.nalUnitType = 'pic_parameter_set_rbsp';\n          break;\n\n        case 0x09:\n          event.nalUnitType = 'access_unit_delimiter_rbsp';\n          break;\n      } // This triggers data on the H264Stream\n\n\n      self.trigger('data', event);\n    });\n    nalByteStream.on('done', function () {\n      self.trigger('done');\n    });\n    nalByteStream.on('partialdone', function () {\n      self.trigger('partialdone');\n    });\n    nalByteStream.on('reset', function () {\n      self.trigger('reset');\n    });\n    nalByteStream.on('endedtimeline', function () {\n      self.trigger('endedtimeline');\n    });\n\n    this.flush = function () {\n      nalByteStream.flush();\n    };\n\n    this.partialFlush = function () {\n      nalByteStream.partialFlush();\n    };\n\n    this.reset = function () {\n      nalByteStream.reset();\n    };\n\n    this.endTimeline = function () {\n      nalByteStream.endTimeline();\n    };\n    /**\n     * Advance the ExpGolomb decoder past a scaling list. The scaling\n     * list is optionally transmitted as part of a sequence parameter\n     * set and is not relevant to transmuxing.\n     * @param count {number} the number of entries in this scaling list\n     * @param expGolombDecoder {object} an ExpGolomb pointed to the\n     * start of a scaling list\n     * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1\n     */\n\n\n    skipScalingList = function skipScalingList(count, expGolombDecoder) {\n      var lastScale = 8,\n          nextScale = 8,\n          j,\n          deltaScale;\n\n      for (j = 0; j < count; j++) {\n        if (nextScale !== 0) {\n          deltaScale = expGolombDecoder.readExpGolomb();\n          nextScale = (lastScale + deltaScale + 256) % 256;\n        }\n\n        lastScale = nextScale === 0 ? lastScale : nextScale;\n      }\n    };\n    /**\n     * Expunge any \"Emulation Prevention\" bytes from a \"Raw Byte\n     * Sequence Payload\"\n     * @param data {Uint8Array} the bytes of a RBSP from a NAL\n     * unit\n     * @return {Uint8Array} the RBSP without any Emulation\n     * Prevention Bytes\n     */\n\n\n    discardEmulationPreventionBytes = function discardEmulationPreventionBytes(data) {\n      var length = data.byteLength,\n          emulationPreventionBytesPositions = [],\n          i = 1,\n          newLength,\n          newData; // Find all `Emulation Prevention Bytes`\n\n      while (i < length - 2) {\n        if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n          emulationPreventionBytesPositions.push(i + 2);\n          i += 2;\n        } else {\n          i++;\n        }\n      } // If no Emulation Prevention Bytes were found just return the original\n      // array\n\n\n      if (emulationPreventionBytesPositions.length === 0) {\n        return data;\n      } // Create a new array to hold the NAL unit data\n\n\n      newLength = length - emulationPreventionBytesPositions.length;\n      newData = new Uint8Array(newLength);\n      var sourceIndex = 0;\n\n      for (i = 0; i < newLength; sourceIndex++, i++) {\n        if (sourceIndex === emulationPreventionBytesPositions[0]) {\n          // Skip this byte\n          sourceIndex++; // Remove this position index\n\n          emulationPreventionBytesPositions.shift();\n        }\n\n        newData[i] = data[sourceIndex];\n      }\n\n      return newData;\n    };\n    /**\n     * Read a sequence parameter set and return some interesting video\n     * properties. A sequence parameter set is the H264 metadata that\n     * describes the properties of upcoming video frames.\n     * @param data {Uint8Array} the bytes of a sequence parameter set\n     * @return {object} an object with configuration parsed from the\n     * sequence parameter set, including the dimensions of the\n     * associated video frames.\n     */\n\n\n    readSequenceParameterSet = function readSequenceParameterSet(data) {\n      var frameCropLeftOffset = 0,\n          frameCropRightOffset = 0,\n          frameCropTopOffset = 0,\n          frameCropBottomOffset = 0,\n          expGolombDecoder,\n          profileIdc,\n          levelIdc,\n          profileCompatibility,\n          chromaFormatIdc,\n          picOrderCntType,\n          numRefFramesInPicOrderCntCycle,\n          picWidthInMbsMinus1,\n          picHeightInMapUnitsMinus1,\n          frameMbsOnlyFlag,\n          scalingListCount,\n          sarRatio = [1, 1],\n          aspectRatioIdc,\n          i;\n      expGolombDecoder = new expGolomb(data);\n      profileIdc = expGolombDecoder.readUnsignedByte(); // profile_idc\n\n      profileCompatibility = expGolombDecoder.readUnsignedByte(); // constraint_set[0-5]_flag\n\n      levelIdc = expGolombDecoder.readUnsignedByte(); // level_idc u(8)\n\n      expGolombDecoder.skipUnsignedExpGolomb(); // seq_parameter_set_id\n      // some profiles have more optional data we don't need\n\n      if (PROFILES_WITH_OPTIONAL_SPS_DATA[profileIdc]) {\n        chromaFormatIdc = expGolombDecoder.readUnsignedExpGolomb();\n\n        if (chromaFormatIdc === 3) {\n          expGolombDecoder.skipBits(1); // separate_colour_plane_flag\n        }\n\n        expGolombDecoder.skipUnsignedExpGolomb(); // bit_depth_luma_minus8\n\n        expGolombDecoder.skipUnsignedExpGolomb(); // bit_depth_chroma_minus8\n\n        expGolombDecoder.skipBits(1); // qpprime_y_zero_transform_bypass_flag\n\n        if (expGolombDecoder.readBoolean()) {\n          // seq_scaling_matrix_present_flag\n          scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;\n\n          for (i = 0; i < scalingListCount; i++) {\n            if (expGolombDecoder.readBoolean()) {\n              // seq_scaling_list_present_flag[ i ]\n              if (i < 6) {\n                skipScalingList(16, expGolombDecoder);\n              } else {\n                skipScalingList(64, expGolombDecoder);\n              }\n            }\n          }\n        }\n      }\n\n      expGolombDecoder.skipUnsignedExpGolomb(); // log2_max_frame_num_minus4\n\n      picOrderCntType = expGolombDecoder.readUnsignedExpGolomb();\n\n      if (picOrderCntType === 0) {\n        expGolombDecoder.readUnsignedExpGolomb(); // log2_max_pic_order_cnt_lsb_minus4\n      } else if (picOrderCntType === 1) {\n        expGolombDecoder.skipBits(1); // delta_pic_order_always_zero_flag\n\n        expGolombDecoder.skipExpGolomb(); // offset_for_non_ref_pic\n\n        expGolombDecoder.skipExpGolomb(); // offset_for_top_to_bottom_field\n\n        numRefFramesInPicOrderCntCycle = expGolombDecoder.readUnsignedExpGolomb();\n\n        for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n          expGolombDecoder.skipExpGolomb(); // offset_for_ref_frame[ i ]\n        }\n      }\n\n      expGolombDecoder.skipUnsignedExpGolomb(); // max_num_ref_frames\n\n      expGolombDecoder.skipBits(1); // gaps_in_frame_num_value_allowed_flag\n\n      picWidthInMbsMinus1 = expGolombDecoder.readUnsignedExpGolomb();\n      picHeightInMapUnitsMinus1 = expGolombDecoder.readUnsignedExpGolomb();\n      frameMbsOnlyFlag = expGolombDecoder.readBits(1);\n\n      if (frameMbsOnlyFlag === 0) {\n        expGolombDecoder.skipBits(1); // mb_adaptive_frame_field_flag\n      }\n\n      expGolombDecoder.skipBits(1); // direct_8x8_inference_flag\n\n      if (expGolombDecoder.readBoolean()) {\n        // frame_cropping_flag\n        frameCropLeftOffset = expGolombDecoder.readUnsignedExpGolomb();\n        frameCropRightOffset = expGolombDecoder.readUnsignedExpGolomb();\n        frameCropTopOffset = expGolombDecoder.readUnsignedExpGolomb();\n        frameCropBottomOffset = expGolombDecoder.readUnsignedExpGolomb();\n      }\n\n      if (expGolombDecoder.readBoolean()) {\n        // vui_parameters_present_flag\n        if (expGolombDecoder.readBoolean()) {\n          // aspect_ratio_info_present_flag\n          aspectRatioIdc = expGolombDecoder.readUnsignedByte();\n\n          switch (aspectRatioIdc) {\n            case 1:\n              sarRatio = [1, 1];\n              break;\n\n            case 2:\n              sarRatio = [12, 11];\n              break;\n\n            case 3:\n              sarRatio = [10, 11];\n              break;\n\n            case 4:\n              sarRatio = [16, 11];\n              break;\n\n            case 5:\n              sarRatio = [40, 33];\n              break;\n\n            case 6:\n              sarRatio = [24, 11];\n              break;\n\n            case 7:\n              sarRatio = [20, 11];\n              break;\n\n            case 8:\n              sarRatio = [32, 11];\n              break;\n\n            case 9:\n              sarRatio = [80, 33];\n              break;\n\n            case 10:\n              sarRatio = [18, 11];\n              break;\n\n            case 11:\n              sarRatio = [15, 11];\n              break;\n\n            case 12:\n              sarRatio = [64, 33];\n              break;\n\n            case 13:\n              sarRatio = [160, 99];\n              break;\n\n            case 14:\n              sarRatio = [4, 3];\n              break;\n\n            case 15:\n              sarRatio = [3, 2];\n              break;\n\n            case 16:\n              sarRatio = [2, 1];\n              break;\n\n            case 255:\n              {\n                sarRatio = [expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte(), expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte()];\n                break;\n              }\n          }\n\n          if (sarRatio) {\n            sarRatio[0] / sarRatio[1];\n          }\n        }\n      }\n\n      return {\n        profileIdc: profileIdc,\n        levelIdc: levelIdc,\n        profileCompatibility: profileCompatibility,\n        width: (picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2,\n        height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - frameCropTopOffset * 2 - frameCropBottomOffset * 2,\n        // sar is sample aspect ratio\n        sarRatio: sarRatio\n      };\n    };\n  };\n\n  _H264Stream.prototype = new stream();\n  var h264 = {\n    H264Stream: _H264Stream,\n    NalByteStream: _NalByteStream\n  };\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n\n  var codecs = {\n    Adts: adts,\n    h264: h264\n  };\n  var MAX_UINT32$1 = Math.pow(2, 32);\n\n  var getUint64$4 = function getUint64(uint8) {\n    var dv = new DataView(uint8.buffer, uint8.byteOffset, uint8.byteLength);\n    var value;\n\n    if (dv.getBigUint64) {\n      value = dv.getBigUint64(0);\n\n      if (value < Number.MAX_SAFE_INTEGER) {\n        return Number(value);\n      }\n\n      return value;\n    }\n\n    return dv.getUint32(0) * MAX_UINT32$1 + dv.getUint32(4);\n  };\n\n  var numbers = {\n    getUint64: getUint64$4,\n    MAX_UINT32: MAX_UINT32$1\n  };\n  var MAX_UINT32 = numbers.MAX_UINT32;\n  var box, dinf, esds, ftyp, mdat, mfhd, minf, moof, moov, mvex, mvhd, trak, tkhd, mdia, mdhd, hdlr, sdtp, stbl, stsd, traf, trex, trun$1, types, MAJOR_BRAND, MINOR_VERSION, AVC1_BRAND, VIDEO_HDLR, AUDIO_HDLR, HDLR_TYPES, VMHD, SMHD, DREF, STCO, STSC, STSZ, STTS; // pre-calculate constants\n\n  (function () {\n    var i;\n    types = {\n      avc1: [],\n      // codingname\n      avcC: [],\n      btrt: [],\n      dinf: [],\n      dref: [],\n      esds: [],\n      ftyp: [],\n      hdlr: [],\n      mdat: [],\n      mdhd: [],\n      mdia: [],\n      mfhd: [],\n      minf: [],\n      moof: [],\n      moov: [],\n      mp4a: [],\n      // codingname\n      mvex: [],\n      mvhd: [],\n      pasp: [],\n      sdtp: [],\n      smhd: [],\n      stbl: [],\n      stco: [],\n      stsc: [],\n      stsd: [],\n      stsz: [],\n      stts: [],\n      styp: [],\n      tfdt: [],\n      tfhd: [],\n      traf: [],\n      trak: [],\n      trun: [],\n      trex: [],\n      tkhd: [],\n      vmhd: []\n    }; // In environments where Uint8Array is undefined (e.g., IE8), skip set up so that we\n    // don't throw an error\n\n    if (typeof Uint8Array === 'undefined') {\n      return;\n    }\n\n    for (i in types) {\n      if (types.hasOwnProperty(i)) {\n        types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];\n      }\n    }\n\n    MAJOR_BRAND = new Uint8Array(['i'.charCodeAt(0), 's'.charCodeAt(0), 'o'.charCodeAt(0), 'm'.charCodeAt(0)]);\n    AVC1_BRAND = new Uint8Array(['a'.charCodeAt(0), 'v'.charCodeAt(0), 'c'.charCodeAt(0), '1'.charCodeAt(0)]);\n    MINOR_VERSION = new Uint8Array([0, 0, 0, 1]);\n    VIDEO_HDLR = new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // pre_defined\n    0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n    ]);\n    AUDIO_HDLR = new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // pre_defined\n    0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\n    ]);\n    HDLR_TYPES = {\n      video: VIDEO_HDLR,\n      audio: AUDIO_HDLR\n    };\n    DREF = new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x01, // entry_count\n    0x00, 0x00, 0x00, 0x0c, // entry_size\n    0x75, 0x72, 0x6c, 0x20, // 'url' type\n    0x00, // version 0\n    0x00, 0x00, 0x01 // entry_flags\n    ]);\n    SMHD = new Uint8Array([0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, // balance, 0 means centered\n    0x00, 0x00 // reserved\n    ]);\n    STCO = new Uint8Array([0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00 // entry_count\n    ]);\n    STSC = STCO;\n    STSZ = new Uint8Array([0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // sample_size\n    0x00, 0x00, 0x00, 0x00 // sample_count\n    ]);\n    STTS = STCO;\n    VMHD = new Uint8Array([0x00, // version\n    0x00, 0x00, 0x01, // flags\n    0x00, 0x00, // graphicsmode\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor\n    ]);\n  })();\n\n  box = function box(type) {\n    var payload = [],\n        size = 0,\n        i,\n        result,\n        view;\n\n    for (i = 1; i < arguments.length; i++) {\n      payload.push(arguments[i]);\n    }\n\n    i = payload.length; // calculate the total size we need to allocate\n\n    while (i--) {\n      size += payload[i].byteLength;\n    }\n\n    result = new Uint8Array(size + 8);\n    view = new DataView(result.buffer, result.byteOffset, result.byteLength);\n    view.setUint32(0, result.byteLength);\n    result.set(type, 4); // copy the payload into the result\n\n    for (i = 0, size = 8; i < payload.length; i++) {\n      result.set(payload[i], size);\n      size += payload[i].byteLength;\n    }\n\n    return result;\n  };\n\n  dinf = function dinf() {\n    return box(types.dinf, box(types.dref, DREF));\n  };\n\n  esds = function esds(track) {\n    return box(types.esds, new Uint8Array([0x00, // version\n    0x00, 0x00, 0x00, // flags\n    // ES_Descriptor\n    0x03, // tag, ES_DescrTag\n    0x19, // length\n    0x00, 0x00, // ES_ID\n    0x00, // streamDependenceFlag, URL_flag, reserved, streamPriority\n    // DecoderConfigDescriptor\n    0x04, // tag, DecoderConfigDescrTag\n    0x11, // length\n    0x40, // object type\n    0x15, // streamType\n    0x00, 0x06, 0x00, // bufferSizeDB\n    0x00, 0x00, 0xda, 0xc0, // maxBitrate\n    0x00, 0x00, 0xda, 0xc0, // avgBitrate\n    // DecoderSpecificInfo\n    0x05, // tag, DecoderSpecificInfoTag\n    0x02, // length\n    // ISO/IEC 14496-3, AudioSpecificConfig\n    // for samplingFrequencyIndex see ISO/IEC 13818-7:2006, 8.1.3.2.2, Table 35\n    track.audioobjecttype << 3 | track.samplingfrequencyindex >>> 1, track.samplingfrequencyindex << 7 | track.channelcount << 3, 0x06, 0x01, 0x02 // GASpecificConfig\n    ]));\n  };\n\n  ftyp = function ftyp() {\n    return box(types.ftyp, MAJOR_BRAND, MINOR_VERSION, MAJOR_BRAND, AVC1_BRAND);\n  };\n\n  hdlr = function hdlr(type) {\n    return box(types.hdlr, HDLR_TYPES[type]);\n  };\n\n  mdat = function mdat(data) {\n    return box(types.mdat, data);\n  };\n\n  mdhd = function mdhd(track) {\n    var result = new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x02, // creation_time\n    0x00, 0x00, 0x00, 0x03, // modification_time\n    0x00, 0x01, 0x5f, 0x90, // timescale, 90,000 \"ticks\" per second\n    track.duration >>> 24 & 0xFF, track.duration >>> 16 & 0xFF, track.duration >>> 8 & 0xFF, track.duration & 0xFF, // duration\n    0x55, 0xc4, // 'und' language (undetermined)\n    0x00, 0x00]); // Use the sample rate from the track metadata, when it is\n    // defined. The sample rate can be parsed out of an ADTS header, for\n    // instance.\n\n    if (track.samplerate) {\n      result[12] = track.samplerate >>> 24 & 0xFF;\n      result[13] = track.samplerate >>> 16 & 0xFF;\n      result[14] = track.samplerate >>> 8 & 0xFF;\n      result[15] = track.samplerate & 0xFF;\n    }\n\n    return box(types.mdhd, result);\n  };\n\n  mdia = function mdia(track) {\n    return box(types.mdia, mdhd(track), hdlr(track.type), minf(track));\n  };\n\n  mfhd = function mfhd(sequenceNumber) {\n    return box(types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00, // flags\n    (sequenceNumber & 0xFF000000) >> 24, (sequenceNumber & 0xFF0000) >> 16, (sequenceNumber & 0xFF00) >> 8, sequenceNumber & 0xFF // sequence_number\n    ]));\n  };\n\n  minf = function minf(track) {\n    return box(types.minf, track.type === 'video' ? box(types.vmhd, VMHD) : box(types.smhd, SMHD), dinf(), stbl(track));\n  };\n\n  moof = function moof(sequenceNumber, tracks) {\n    var trackFragments = [],\n        i = tracks.length; // build traf boxes for each track fragment\n\n    while (i--) {\n      trackFragments[i] = traf(tracks[i]);\n    }\n\n    return box.apply(null, [types.moof, mfhd(sequenceNumber)].concat(trackFragments));\n  };\n  /**\n   * Returns a movie box.\n   * @param tracks {array} the tracks associated with this movie\n   * @see ISO/IEC 14496-12:2012(E), section 8.2.1\n   */\n\n\n  moov = function moov(tracks) {\n    var i = tracks.length,\n        boxes = [];\n\n    while (i--) {\n      boxes[i] = trak(tracks[i]);\n    }\n\n    return box.apply(null, [types.moov, mvhd(0xffffffff)].concat(boxes).concat(mvex(tracks)));\n  };\n\n  mvex = function mvex(tracks) {\n    var i = tracks.length,\n        boxes = [];\n\n    while (i--) {\n      boxes[i] = trex(tracks[i]);\n    }\n\n    return box.apply(null, [types.mvex].concat(boxes));\n  };\n\n  mvhd = function mvhd(duration) {\n    var bytes = new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x01, // creation_time\n    0x00, 0x00, 0x00, 0x02, // modification_time\n    0x00, 0x01, 0x5f, 0x90, // timescale, 90,000 \"ticks\" per second\n    (duration & 0xFF000000) >> 24, (duration & 0xFF0000) >> 16, (duration & 0xFF00) >> 8, duration & 0xFF, // duration\n    0x00, 0x01, 0x00, 0x00, // 1.0 rate\n    0x01, 0x00, // 1.0 volume\n    0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined\n    0xff, 0xff, 0xff, 0xff // next_track_ID\n    ]);\n    return box(types.mvhd, bytes);\n  };\n\n  sdtp = function sdtp(track) {\n    var samples = track.samples || [],\n        bytes = new Uint8Array(4 + samples.length),\n        flags,\n        i; // leave the full box header (4 bytes) all zero\n    // write the sample table\n\n    for (i = 0; i < samples.length; i++) {\n      flags = samples[i].flags;\n      bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;\n    }\n\n    return box(types.sdtp, bytes);\n  };\n\n  stbl = function stbl(track) {\n    return box(types.stbl, stsd(track), box(types.stts, STTS), box(types.stsc, STSC), box(types.stsz, STSZ), box(types.stco, STCO));\n  };\n\n  (function () {\n    var videoSample, audioSample;\n\n    stsd = function stsd(track) {\n      return box(types.stsd, new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x01]), track.type === 'video' ? videoSample(track) : audioSample(track));\n    };\n\n    videoSample = function videoSample(track) {\n      var sps = track.sps || [],\n          pps = track.pps || [],\n          sequenceParameterSets = [],\n          pictureParameterSets = [],\n          i,\n          avc1Box; // assemble the SPSs\n\n      for (i = 0; i < sps.length; i++) {\n        sequenceParameterSets.push((sps[i].byteLength & 0xFF00) >>> 8);\n        sequenceParameterSets.push(sps[i].byteLength & 0xFF); // sequenceParameterSetLength\n\n        sequenceParameterSets = sequenceParameterSets.concat(Array.prototype.slice.call(sps[i])); // SPS\n      } // assemble the PPSs\n\n\n      for (i = 0; i < pps.length; i++) {\n        pictureParameterSets.push((pps[i].byteLength & 0xFF00) >>> 8);\n        pictureParameterSets.push(pps[i].byteLength & 0xFF);\n        pictureParameterSets = pictureParameterSets.concat(Array.prototype.slice.call(pps[i]));\n      }\n\n      avc1Box = [types.avc1, new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n      0x00, 0x00, // pre_defined\n      0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined\n      (track.width & 0xff00) >> 8, track.width & 0xff, // width\n      (track.height & 0xff00) >> 8, track.height & 0xff, // height\n      0x00, 0x48, 0x00, 0x00, // horizresolution\n      0x00, 0x48, 0x00, 0x00, // vertresolution\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // frame_count\n      0x13, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x6a, 0x73, 0x2d, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x69, 0x62, 0x2d, 0x68, 0x6c, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // compressorname\n      0x00, 0x18, // depth = 24\n      0x11, 0x11 // pre_defined = -1\n      ]), box(types.avcC, new Uint8Array([0x01, // configurationVersion\n      track.profileIdc, // AVCProfileIndication\n      track.profileCompatibility, // profile_compatibility\n      track.levelIdc, // AVCLevelIndication\n      0xff // lengthSizeMinusOne, hard-coded to 4 bytes\n      ].concat([sps.length], // numOfSequenceParameterSets\n      sequenceParameterSets, // \"SPS\"\n      [pps.length], // numOfPictureParameterSets\n      pictureParameterSets // \"PPS\"\n      ))), box(types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB\n      0x00, 0x2d, 0xc6, 0xc0, // maxBitrate\n      0x00, 0x2d, 0xc6, 0xc0 // avgBitrate\n      ]))];\n\n      if (track.sarRatio) {\n        var hSpacing = track.sarRatio[0],\n            vSpacing = track.sarRatio[1];\n        avc1Box.push(box(types.pasp, new Uint8Array([(hSpacing & 0xFF000000) >> 24, (hSpacing & 0xFF0000) >> 16, (hSpacing & 0xFF00) >> 8, hSpacing & 0xFF, (vSpacing & 0xFF000000) >> 24, (vSpacing & 0xFF0000) >> 16, (vSpacing & 0xFF00) >> 8, vSpacing & 0xFF])));\n      }\n\n      return box.apply(null, avc1Box);\n    };\n\n    audioSample = function audioSample(track) {\n      return box(types.mp4a, new Uint8Array([// SampleEntry, ISO/IEC 14496-12\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n      // AudioSampleEntry, ISO/IEC 14496-12\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      (track.channelcount & 0xff00) >> 8, track.channelcount & 0xff, // channelcount\n      (track.samplesize & 0xff00) >> 8, track.samplesize & 0xff, // samplesize\n      0x00, 0x00, // pre_defined\n      0x00, 0x00, // reserved\n      (track.samplerate & 0xff00) >> 8, track.samplerate & 0xff, 0x00, 0x00 // samplerate, 16.16\n      // MP4AudioSampleEntry, ISO/IEC 14496-14\n      ]), esds(track));\n    };\n  })();\n\n  tkhd = function tkhd(track) {\n    var result = new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x07, // flags\n    0x00, 0x00, 0x00, 0x00, // creation_time\n    0x00, 0x00, 0x00, 0x00, // modification_time\n    (track.id & 0xFF000000) >> 24, (track.id & 0xFF0000) >> 16, (track.id & 0xFF00) >> 8, track.id & 0xFF, // track_ID\n    0x00, 0x00, 0x00, 0x00, // reserved\n    (track.duration & 0xFF000000) >> 24, (track.duration & 0xFF0000) >> 16, (track.duration & 0xFF00) >> 8, track.duration & 0xFF, // duration\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, // layer\n    0x00, 0x00, // alternate_group\n    0x01, 0x00, // non-audio track volume\n    0x00, 0x00, // reserved\n    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\n    (track.width & 0xFF00) >> 8, track.width & 0xFF, 0x00, 0x00, // width\n    (track.height & 0xFF00) >> 8, track.height & 0xFF, 0x00, 0x00 // height\n    ]);\n    return box(types.tkhd, result);\n  };\n  /**\n   * Generate a track fragment (traf) box. A traf box collects metadata\n   * about tracks in a movie fragment (moof) box.\n   */\n\n\n  traf = function traf(track) {\n    var trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable, dataOffset, upperWordBaseMediaDecodeTime, lowerWordBaseMediaDecodeTime;\n    trackFragmentHeader = box(types.tfhd, new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x3a, // flags\n    (track.id & 0xFF000000) >> 24, (track.id & 0xFF0000) >> 16, (track.id & 0xFF00) >> 8, track.id & 0xFF, // track_ID\n    0x00, 0x00, 0x00, 0x01, // sample_description_index\n    0x00, 0x00, 0x00, 0x00, // default_sample_duration\n    0x00, 0x00, 0x00, 0x00, // default_sample_size\n    0x00, 0x00, 0x00, 0x00 // default_sample_flags\n    ]));\n    upperWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime / MAX_UINT32);\n    lowerWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime % MAX_UINT32);\n    trackFragmentDecodeTime = box(types.tfdt, new Uint8Array([0x01, // version 1\n    0x00, 0x00, 0x00, // flags\n    // baseMediaDecodeTime\n    upperWordBaseMediaDecodeTime >>> 24 & 0xFF, upperWordBaseMediaDecodeTime >>> 16 & 0xFF, upperWordBaseMediaDecodeTime >>> 8 & 0xFF, upperWordBaseMediaDecodeTime & 0xFF, lowerWordBaseMediaDecodeTime >>> 24 & 0xFF, lowerWordBaseMediaDecodeTime >>> 16 & 0xFF, lowerWordBaseMediaDecodeTime >>> 8 & 0xFF, lowerWordBaseMediaDecodeTime & 0xFF])); // the data offset specifies the number of bytes from the start of\n    // the containing moof to the first payload byte of the associated\n    // mdat\n\n    dataOffset = 32 + // tfhd\n    20 + // tfdt\n    8 + // traf header\n    16 + // mfhd\n    8 + // moof header\n    8; // mdat header\n    // audio tracks require less metadata\n\n    if (track.type === 'audio') {\n      trackFragmentRun = trun$1(track, dataOffset);\n      return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun);\n    } // video tracks should contain an independent and disposable samples\n    // box (sdtp)\n    // generate one and adjust offsets to match\n\n\n    sampleDependencyTable = sdtp(track);\n    trackFragmentRun = trun$1(track, sampleDependencyTable.length + dataOffset);\n    return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable);\n  };\n  /**\n   * Generate a track box.\n   * @param track {object} a track definition\n   * @return {Uint8Array} the track box\n   */\n\n\n  trak = function trak(track) {\n    track.duration = track.duration || 0xffffffff;\n    return box(types.trak, tkhd(track), mdia(track));\n  };\n\n  trex = function trex(track) {\n    var result = new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    (track.id & 0xFF000000) >> 24, (track.id & 0xFF0000) >> 16, (track.id & 0xFF00) >> 8, track.id & 0xFF, // track_ID\n    0x00, 0x00, 0x00, 0x01, // default_sample_description_index\n    0x00, 0x00, 0x00, 0x00, // default_sample_duration\n    0x00, 0x00, 0x00, 0x00, // default_sample_size\n    0x00, 0x01, 0x00, 0x01 // default_sample_flags\n    ]); // the last two bytes of default_sample_flags is the sample\n    // degradation priority, a hint about the importance of this sample\n    // relative to others. Lower the degradation priority for all sample\n    // types other than video.\n\n    if (track.type !== 'video') {\n      result[result.length - 1] = 0x00;\n    }\n\n    return box(types.trex, result);\n  };\n\n  (function () {\n    var audioTrun, videoTrun, trunHeader; // This method assumes all samples are uniform. That is, if a\n    // duration is present for the first sample, it will be present for\n    // all subsequent samples.\n    // see ISO/IEC 14496-12:2012, Section 8.8.8.1\n\n    trunHeader = function trunHeader(samples, offset) {\n      var durationPresent = 0,\n          sizePresent = 0,\n          flagsPresent = 0,\n          compositionTimeOffset = 0; // trun flag constants\n\n      if (samples.length) {\n        if (samples[0].duration !== undefined) {\n          durationPresent = 0x1;\n        }\n\n        if (samples[0].size !== undefined) {\n          sizePresent = 0x2;\n        }\n\n        if (samples[0].flags !== undefined) {\n          flagsPresent = 0x4;\n        }\n\n        if (samples[0].compositionTimeOffset !== undefined) {\n          compositionTimeOffset = 0x8;\n        }\n      }\n\n      return [0x00, // version 0\n      0x00, durationPresent | sizePresent | flagsPresent | compositionTimeOffset, 0x01, // flags\n      (samples.length & 0xFF000000) >>> 24, (samples.length & 0xFF0000) >>> 16, (samples.length & 0xFF00) >>> 8, samples.length & 0xFF, // sample_count\n      (offset & 0xFF000000) >>> 24, (offset & 0xFF0000) >>> 16, (offset & 0xFF00) >>> 8, offset & 0xFF // data_offset\n      ];\n    };\n\n    videoTrun = function videoTrun(track, offset) {\n      var bytesOffest, bytes, header, samples, sample, i;\n      samples = track.samples || [];\n      offset += 8 + 12 + 16 * samples.length;\n      header = trunHeader(samples, offset);\n      bytes = new Uint8Array(header.length + samples.length * 16);\n      bytes.set(header);\n      bytesOffest = header.length;\n\n      for (i = 0; i < samples.length; i++) {\n        sample = samples[i];\n        bytes[bytesOffest++] = (sample.duration & 0xFF000000) >>> 24;\n        bytes[bytesOffest++] = (sample.duration & 0xFF0000) >>> 16;\n        bytes[bytesOffest++] = (sample.duration & 0xFF00) >>> 8;\n        bytes[bytesOffest++] = sample.duration & 0xFF; // sample_duration\n\n        bytes[bytesOffest++] = (sample.size & 0xFF000000) >>> 24;\n        bytes[bytesOffest++] = (sample.size & 0xFF0000) >>> 16;\n        bytes[bytesOffest++] = (sample.size & 0xFF00) >>> 8;\n        bytes[bytesOffest++] = sample.size & 0xFF; // sample_size\n\n        bytes[bytesOffest++] = sample.flags.isLeading << 2 | sample.flags.dependsOn;\n        bytes[bytesOffest++] = sample.flags.isDependedOn << 6 | sample.flags.hasRedundancy << 4 | sample.flags.paddingValue << 1 | sample.flags.isNonSyncSample;\n        bytes[bytesOffest++] = sample.flags.degradationPriority & 0xF0 << 8;\n        bytes[bytesOffest++] = sample.flags.degradationPriority & 0x0F; // sample_flags\n\n        bytes[bytesOffest++] = (sample.compositionTimeOffset & 0xFF000000) >>> 24;\n        bytes[bytesOffest++] = (sample.compositionTimeOffset & 0xFF0000) >>> 16;\n        bytes[bytesOffest++] = (sample.compositionTimeOffset & 0xFF00) >>> 8;\n        bytes[bytesOffest++] = sample.compositionTimeOffset & 0xFF; // sample_composition_time_offset\n      }\n\n      return box(types.trun, bytes);\n    };\n\n    audioTrun = function audioTrun(track, offset) {\n      var bytes, bytesOffest, header, samples, sample, i;\n      samples = track.samples || [];\n      offset += 8 + 12 + 8 * samples.length;\n      header = trunHeader(samples, offset);\n      bytes = new Uint8Array(header.length + samples.length * 8);\n      bytes.set(header);\n      bytesOffest = header.length;\n\n      for (i = 0; i < samples.length; i++) {\n        sample = samples[i];\n        bytes[bytesOffest++] = (sample.duration & 0xFF000000) >>> 24;\n        bytes[bytesOffest++] = (sample.duration & 0xFF0000) >>> 16;\n        bytes[bytesOffest++] = (sample.duration & 0xFF00) >>> 8;\n        bytes[bytesOffest++] = sample.duration & 0xFF; // sample_duration\n\n        bytes[bytesOffest++] = (sample.size & 0xFF000000) >>> 24;\n        bytes[bytesOffest++] = (sample.size & 0xFF0000) >>> 16;\n        bytes[bytesOffest++] = (sample.size & 0xFF00) >>> 8;\n        bytes[bytesOffest++] = sample.size & 0xFF; // sample_size\n      }\n\n      return box(types.trun, bytes);\n    };\n\n    trun$1 = function trun(track, offset) {\n      if (track.type === 'audio') {\n        return audioTrun(track, offset);\n      }\n\n      return videoTrun(track, offset);\n    };\n  })();\n\n  var mp4Generator = {\n    ftyp: ftyp,\n    mdat: mdat,\n    moof: moof,\n    moov: moov,\n    initSegment: function initSegment(tracks) {\n      var fileType = ftyp(),\n          movie = moov(tracks),\n          result;\n      result = new Uint8Array(fileType.byteLength + movie.byteLength);\n      result.set(fileType);\n      result.set(movie, fileType.byteLength);\n      return result;\n    }\n  };\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n\n  var toUnsigned$3 = function toUnsigned(value) {\n    return value >>> 0;\n  };\n\n  var toHexString$1 = function toHexString(value) {\n    return ('00' + value.toString(16)).slice(-2);\n  };\n\n  var bin = {\n    toUnsigned: toUnsigned$3,\n    toHexString: toHexString$1\n  };\n\n  var parseType$2 = function parseType(buffer) {\n    var result = '';\n    result += String.fromCharCode(buffer[0]);\n    result += String.fromCharCode(buffer[1]);\n    result += String.fromCharCode(buffer[2]);\n    result += String.fromCharCode(buffer[3]);\n    return result;\n  };\n\n  var parseType_1 = parseType$2;\n  var toUnsigned$2 = bin.toUnsigned;\n\n  var findBox = function findBox(data, path) {\n    var results = [],\n        i,\n        size,\n        type,\n        end,\n        subresults;\n\n    if (!path.length) {\n      // short-circuit the search for empty paths\n      return null;\n    }\n\n    for (i = 0; i < data.byteLength;) {\n      size = toUnsigned$2(data[i] << 24 | data[i + 1] << 16 | data[i + 2] << 8 | data[i + 3]);\n      type = parseType_1(data.subarray(i + 4, i + 8));\n      end = size > 1 ? i + size : data.byteLength;\n\n      if (type === path[0]) {\n        if (path.length === 1) {\n          // this is the end of the path and we've found the box we were\n          // looking for\n          results.push(data.subarray(i + 8, end));\n        } else {\n          // recursively search for the next box along the path\n          subresults = findBox(data.subarray(i + 8, end), path.slice(1));\n\n          if (subresults.length) {\n            results = results.concat(subresults);\n          }\n        }\n      }\n\n      i = end;\n    } // we've finished searching all of data\n\n\n    return results;\n  };\n\n  var findBox_1 = findBox;\n\n  var tfhd = function tfhd(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4)),\n      trackId: view.getUint32(4)\n    },\n        baseDataOffsetPresent = result.flags[2] & 0x01,\n        sampleDescriptionIndexPresent = result.flags[2] & 0x02,\n        defaultSampleDurationPresent = result.flags[2] & 0x08,\n        defaultSampleSizePresent = result.flags[2] & 0x10,\n        defaultSampleFlagsPresent = result.flags[2] & 0x20,\n        durationIsEmpty = result.flags[0] & 0x010000,\n        defaultBaseIsMoof = result.flags[0] & 0x020000,\n        i;\n    i = 8;\n\n    if (baseDataOffsetPresent) {\n      i += 4; // truncate top 4 bytes\n      // FIXME: should we read the full 64 bits?\n\n      result.baseDataOffset = view.getUint32(12);\n      i += 4;\n    }\n\n    if (sampleDescriptionIndexPresent) {\n      result.sampleDescriptionIndex = view.getUint32(i);\n      i += 4;\n    }\n\n    if (defaultSampleDurationPresent) {\n      result.defaultSampleDuration = view.getUint32(i);\n      i += 4;\n    }\n\n    if (defaultSampleSizePresent) {\n      result.defaultSampleSize = view.getUint32(i);\n      i += 4;\n    }\n\n    if (defaultSampleFlagsPresent) {\n      result.defaultSampleFlags = view.getUint32(i);\n    }\n\n    if (durationIsEmpty) {\n      result.durationIsEmpty = true;\n    }\n\n    if (!baseDataOffsetPresent && defaultBaseIsMoof) {\n      result.baseDataOffsetIsMoof = true;\n    }\n\n    return result;\n  };\n\n  var parseTfhd = tfhd;\n\n  var parseSampleFlags = function parseSampleFlags(flags) {\n    return {\n      isLeading: (flags[0] & 0x0c) >>> 2,\n      dependsOn: flags[0] & 0x03,\n      isDependedOn: (flags[1] & 0xc0) >>> 6,\n      hasRedundancy: (flags[1] & 0x30) >>> 4,\n      paddingValue: (flags[1] & 0x0e) >>> 1,\n      isNonSyncSample: flags[1] & 0x01,\n      degradationPriority: flags[2] << 8 | flags[3]\n    };\n  };\n\n  var parseSampleFlags_1 = parseSampleFlags;\n\n  var trun = function trun(data) {\n    var result = {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4)),\n      samples: []\n    },\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        // Flag interpretation\n    dataOffsetPresent = result.flags[2] & 0x01,\n        // compare with 2nd byte of 0x1\n    firstSampleFlagsPresent = result.flags[2] & 0x04,\n        // compare with 2nd byte of 0x4\n    sampleDurationPresent = result.flags[1] & 0x01,\n        // compare with 2nd byte of 0x100\n    sampleSizePresent = result.flags[1] & 0x02,\n        // compare with 2nd byte of 0x200\n    sampleFlagsPresent = result.flags[1] & 0x04,\n        // compare with 2nd byte of 0x400\n    sampleCompositionTimeOffsetPresent = result.flags[1] & 0x08,\n        // compare with 2nd byte of 0x800\n    sampleCount = view.getUint32(4),\n        offset = 8,\n        sample;\n\n    if (dataOffsetPresent) {\n      // 32 bit signed integer\n      result.dataOffset = view.getInt32(offset);\n      offset += 4;\n    } // Overrides the flags for the first sample only. The order of\n    // optional values will be: duration, size, compositionTimeOffset\n\n\n    if (firstSampleFlagsPresent && sampleCount) {\n      sample = {\n        flags: parseSampleFlags_1(data.subarray(offset, offset + 4))\n      };\n      offset += 4;\n\n      if (sampleDurationPresent) {\n        sample.duration = view.getUint32(offset);\n        offset += 4;\n      }\n\n      if (sampleSizePresent) {\n        sample.size = view.getUint32(offset);\n        offset += 4;\n      }\n\n      if (sampleCompositionTimeOffsetPresent) {\n        if (result.version === 1) {\n          sample.compositionTimeOffset = view.getInt32(offset);\n        } else {\n          sample.compositionTimeOffset = view.getUint32(offset);\n        }\n\n        offset += 4;\n      }\n\n      result.samples.push(sample);\n      sampleCount--;\n    }\n\n    while (sampleCount--) {\n      sample = {};\n\n      if (sampleDurationPresent) {\n        sample.duration = view.getUint32(offset);\n        offset += 4;\n      }\n\n      if (sampleSizePresent) {\n        sample.size = view.getUint32(offset);\n        offset += 4;\n      }\n\n      if (sampleFlagsPresent) {\n        sample.flags = parseSampleFlags_1(data.subarray(offset, offset + 4));\n        offset += 4;\n      }\n\n      if (sampleCompositionTimeOffsetPresent) {\n        if (result.version === 1) {\n          sample.compositionTimeOffset = view.getInt32(offset);\n        } else {\n          sample.compositionTimeOffset = view.getUint32(offset);\n        }\n\n        offset += 4;\n      }\n\n      result.samples.push(sample);\n    }\n\n    return result;\n  };\n\n  var parseTrun = trun;\n  var toUnsigned$1 = bin.toUnsigned;\n  var getUint64$3 = numbers.getUint64;\n\n  var tfdt = function tfdt(data) {\n    var result = {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4))\n    };\n\n    if (result.version === 1) {\n      result.baseMediaDecodeTime = getUint64$3(data.subarray(4));\n    } else {\n      result.baseMediaDecodeTime = toUnsigned$1(data[4] << 24 | data[5] << 16 | data[6] << 8 | data[7]);\n    }\n\n    return result;\n  };\n\n  var parseTfdt = tfdt;\n  var toUnsigned = bin.toUnsigned;\n  var toHexString = bin.toHexString;\n  var getUint64$2 = numbers.getUint64;\n  var timescale, startTime, compositionStartTime, getVideoTrackIds, getTracks, getTimescaleFromMediaHeader;\n  /**\n   * Parses an MP4 initialization segment and extracts the timescale\n   * values for any declared tracks. Timescale values indicate the\n   * number of clock ticks per second to assume for time-based values\n   * elsewhere in the MP4.\n   *\n   * To determine the start time of an MP4, you need two pieces of\n   * information: the timescale unit and the earliest base media decode\n   * time. Multiple timescales can be specified within an MP4 but the\n   * base media decode time is always expressed in the timescale from\n   * the media header box for the track:\n   * ```\n   * moov > trak > mdia > mdhd.timescale\n   * ```\n   * @param init {Uint8Array} the bytes of the init segment\n   * @return {object} a hash of track ids to timescale values or null if\n   * the init segment is malformed.\n   */\n\n  timescale = function timescale(init) {\n    var result = {},\n        traks = findBox_1(init, ['moov', 'trak']); // mdhd timescale\n\n    return traks.reduce(function (result, trak) {\n      var tkhd, version, index, id, mdhd;\n      tkhd = findBox_1(trak, ['tkhd'])[0];\n\n      if (!tkhd) {\n        return null;\n      }\n\n      version = tkhd[0];\n      index = version === 0 ? 12 : 20;\n      id = toUnsigned(tkhd[index] << 24 | tkhd[index + 1] << 16 | tkhd[index + 2] << 8 | tkhd[index + 3]);\n      mdhd = findBox_1(trak, ['mdia', 'mdhd'])[0];\n\n      if (!mdhd) {\n        return null;\n      }\n\n      version = mdhd[0];\n      index = version === 0 ? 12 : 20;\n      result[id] = toUnsigned(mdhd[index] << 24 | mdhd[index + 1] << 16 | mdhd[index + 2] << 8 | mdhd[index + 3]);\n      return result;\n    }, result);\n  };\n  /**\n   * Determine the base media decode start time, in seconds, for an MP4\n   * fragment. If multiple fragments are specified, the earliest time is\n   * returned.\n   *\n   * The base media decode time can be parsed from track fragment\n   * metadata:\n   * ```\n   * moof > traf > tfdt.baseMediaDecodeTime\n   * ```\n   * It requires the timescale value from the mdhd to interpret.\n   *\n   * @param timescale {object} a hash of track ids to timescale values.\n   * @return {number} the earliest base media decode start time for the\n   * fragment, in seconds\n   */\n\n\n  startTime = function startTime(timescale, fragment) {\n    var trafs; // we need info from two childrend of each track fragment box\n\n    trafs = findBox_1(fragment, ['moof', 'traf']); // determine the start times for each track\n\n    var lowestTime = trafs.reduce(function (acc, traf) {\n      var tfhd = findBox_1(traf, ['tfhd'])[0]; // get the track id from the tfhd\n\n      var id = toUnsigned(tfhd[4] << 24 | tfhd[5] << 16 | tfhd[6] << 8 | tfhd[7]); // assume a 90kHz clock if no timescale was specified\n\n      var scale = timescale[id] || 90e3; // get the base media decode time from the tfdt\n\n      var tfdt = findBox_1(traf, ['tfdt'])[0];\n      var dv = new DataView(tfdt.buffer, tfdt.byteOffset, tfdt.byteLength);\n      var baseTime; // version 1 is 64 bit\n\n      if (tfdt[0] === 1) {\n        baseTime = getUint64$2(tfdt.subarray(4, 12));\n      } else {\n        baseTime = dv.getUint32(4);\n      } // convert base time to seconds if it is a valid number.\n\n\n      var seconds;\n\n      if (typeof baseTime === 'bigint') {\n        seconds = baseTime / window__default['default'].BigInt(scale);\n      } else if (typeof baseTime === 'number' && !isNaN(baseTime)) {\n        seconds = baseTime / scale;\n      }\n\n      if (seconds < Number.MAX_SAFE_INTEGER) {\n        seconds = Number(seconds);\n      }\n\n      if (seconds < acc) {\n        acc = seconds;\n      }\n\n      return acc;\n    }, Infinity);\n    return typeof lowestTime === 'bigint' || isFinite(lowestTime) ? lowestTime : 0;\n  };\n  /**\n   * Determine the composition start, in seconds, for an MP4\n   * fragment.\n   *\n   * The composition start time of a fragment can be calculated using the base\n   * media decode time, composition time offset, and timescale, as follows:\n   *\n   * compositionStartTime = (baseMediaDecodeTime + compositionTimeOffset) / timescale\n   *\n   * All of the aforementioned information is contained within a media fragment's\n   * `traf` box, except for timescale info, which comes from the initialization\n   * segment, so a track id (also contained within a `traf`) is also necessary to\n   * associate it with a timescale\n   *\n   *\n   * @param timescales {object} - a hash of track ids to timescale values.\n   * @param fragment {Unit8Array} - the bytes of a media segment\n   * @return {number} the composition start time for the fragment, in seconds\n   **/\n\n\n  compositionStartTime = function compositionStartTime(timescales, fragment) {\n    var trafBoxes = findBox_1(fragment, ['moof', 'traf']);\n    var baseMediaDecodeTime = 0;\n    var compositionTimeOffset = 0;\n    var trackId;\n\n    if (trafBoxes && trafBoxes.length) {\n      // The spec states that track run samples contained within a `traf` box are contiguous, but\n      // it does not explicitly state whether the `traf` boxes themselves are contiguous.\n      // We will assume that they are, so we only need the first to calculate start time.\n      var tfhd = findBox_1(trafBoxes[0], ['tfhd'])[0];\n      var trun = findBox_1(trafBoxes[0], ['trun'])[0];\n      var tfdt = findBox_1(trafBoxes[0], ['tfdt'])[0];\n\n      if (tfhd) {\n        var parsedTfhd = parseTfhd(tfhd);\n        trackId = parsedTfhd.trackId;\n      }\n\n      if (tfdt) {\n        var parsedTfdt = parseTfdt(tfdt);\n        baseMediaDecodeTime = parsedTfdt.baseMediaDecodeTime;\n      }\n\n      if (trun) {\n        var parsedTrun = parseTrun(trun);\n\n        if (parsedTrun.samples && parsedTrun.samples.length) {\n          compositionTimeOffset = parsedTrun.samples[0].compositionTimeOffset || 0;\n        }\n      }\n    } // Get timescale for this specific track. Assume a 90kHz clock if no timescale was\n    // specified.\n\n\n    var timescale = timescales[trackId] || 90e3; // return the composition start time, in seconds\n\n    if (typeof baseMediaDecodeTime === 'bigint') {\n      compositionTimeOffset = window__default['default'].BigInt(compositionTimeOffset);\n      timescale = window__default['default'].BigInt(timescale);\n    }\n\n    var result = (baseMediaDecodeTime + compositionTimeOffset) / timescale;\n\n    if (typeof result === 'bigint' && result < Number.MAX_SAFE_INTEGER) {\n      result = Number(result);\n    }\n\n    return result;\n  };\n  /**\n    * Find the trackIds of the video tracks in this source.\n    * Found by parsing the Handler Reference and Track Header Boxes:\n    *   moov > trak > mdia > hdlr\n    *   moov > trak > tkhd\n    *\n    * @param {Uint8Array} init - The bytes of the init segment for this source\n    * @return {Number[]} A list of trackIds\n    *\n    * @see ISO-BMFF-12/2015, Section 8.4.3\n   **/\n\n\n  getVideoTrackIds = function getVideoTrackIds(init) {\n    var traks = findBox_1(init, ['moov', 'trak']);\n    var videoTrackIds = [];\n    traks.forEach(function (trak) {\n      var hdlrs = findBox_1(trak, ['mdia', 'hdlr']);\n      var tkhds = findBox_1(trak, ['tkhd']);\n      hdlrs.forEach(function (hdlr, index) {\n        var handlerType = parseType_1(hdlr.subarray(8, 12));\n        var tkhd = tkhds[index];\n        var view;\n        var version;\n        var trackId;\n\n        if (handlerType === 'vide') {\n          view = new DataView(tkhd.buffer, tkhd.byteOffset, tkhd.byteLength);\n          version = view.getUint8(0);\n          trackId = version === 0 ? view.getUint32(12) : view.getUint32(20);\n          videoTrackIds.push(trackId);\n        }\n      });\n    });\n    return videoTrackIds;\n  };\n\n  getTimescaleFromMediaHeader = function getTimescaleFromMediaHeader(mdhd) {\n    // mdhd is a FullBox, meaning it will have its own version as the first byte\n    var version = mdhd[0];\n    var index = version === 0 ? 12 : 20;\n    return toUnsigned(mdhd[index] << 24 | mdhd[index + 1] << 16 | mdhd[index + 2] << 8 | mdhd[index + 3]);\n  };\n  /**\n   * Get all the video, audio, and hint tracks from a non fragmented\n   * mp4 segment\n   */\n\n\n  getTracks = function getTracks(init) {\n    var traks = findBox_1(init, ['moov', 'trak']);\n    var tracks = [];\n    traks.forEach(function (trak) {\n      var track = {};\n      var tkhd = findBox_1(trak, ['tkhd'])[0];\n      var view, tkhdVersion; // id\n\n      if (tkhd) {\n        view = new DataView(tkhd.buffer, tkhd.byteOffset, tkhd.byteLength);\n        tkhdVersion = view.getUint8(0);\n        track.id = tkhdVersion === 0 ? view.getUint32(12) : view.getUint32(20);\n      }\n\n      var hdlr = findBox_1(trak, ['mdia', 'hdlr'])[0]; // type\n\n      if (hdlr) {\n        var type = parseType_1(hdlr.subarray(8, 12));\n\n        if (type === 'vide') {\n          track.type = 'video';\n        } else if (type === 'soun') {\n          track.type = 'audio';\n        } else {\n          track.type = type;\n        }\n      } // codec\n\n\n      var stsd = findBox_1(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];\n\n      if (stsd) {\n        var sampleDescriptions = stsd.subarray(8); // gives the codec type string\n\n        track.codec = parseType_1(sampleDescriptions.subarray(4, 8));\n        var codecBox = findBox_1(sampleDescriptions, [track.codec])[0];\n        var codecConfig, codecConfigType;\n\n        if (codecBox) {\n          // https://tools.ietf.org/html/rfc6381#section-3.3\n          if (/^[asm]vc[1-9]$/i.test(track.codec)) {\n            // we don't need anything but the \"config\" parameter of the\n            // avc1 codecBox\n            codecConfig = codecBox.subarray(78);\n            codecConfigType = parseType_1(codecConfig.subarray(4, 8));\n\n            if (codecConfigType === 'avcC' && codecConfig.length > 11) {\n              track.codec += '.'; // left padded with zeroes for single digit hex\n              // profile idc\n\n              track.codec += toHexString(codecConfig[9]); // the byte containing the constraint_set flags\n\n              track.codec += toHexString(codecConfig[10]); // level idc\n\n              track.codec += toHexString(codecConfig[11]);\n            } else {\n              // TODO: show a warning that we couldn't parse the codec\n              // and are using the default\n              track.codec = 'avc1.4d400d';\n            }\n          } else if (/^mp4[a,v]$/i.test(track.codec)) {\n            // we do not need anything but the streamDescriptor of the mp4a codecBox\n            codecConfig = codecBox.subarray(28);\n            codecConfigType = parseType_1(codecConfig.subarray(4, 8));\n\n            if (codecConfigType === 'esds' && codecConfig.length > 20 && codecConfig[19] !== 0) {\n              track.codec += '.' + toHexString(codecConfig[19]); // this value is only a single digit\n\n              track.codec += '.' + toHexString(codecConfig[20] >>> 2 & 0x3f).replace(/^0/, '');\n            } else {\n              // TODO: show a warning that we couldn't parse the codec\n              // and are using the default\n              track.codec = 'mp4a.40.2';\n            }\n          } else {\n            // flac, opus, etc\n            track.codec = track.codec.toLowerCase();\n          }\n        }\n      }\n\n      var mdhd = findBox_1(trak, ['mdia', 'mdhd'])[0];\n\n      if (mdhd) {\n        track.timescale = getTimescaleFromMediaHeader(mdhd);\n      }\n\n      tracks.push(track);\n    });\n    return tracks;\n  };\n\n  var probe$2 = {\n    // export mp4 inspector's findBox and parseType for backwards compatibility\n    findBox: findBox_1,\n    parseType: parseType_1,\n    timescale: timescale,\n    startTime: startTime,\n    compositionStartTime: compositionStartTime,\n    videoTrackIds: getVideoTrackIds,\n    tracks: getTracks,\n    getTimescaleFromMediaHeader: getTimescaleFromMediaHeader\n  };\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n  // Convert an array of nal units into an array of frames with each frame being\n  // composed of the nal units that make up that frame\n  // Also keep track of cummulative data about the frame from the nal units such\n  // as the frame duration, starting pts, etc.\n\n  var groupNalsIntoFrames = function groupNalsIntoFrames(nalUnits) {\n    var i,\n        currentNal,\n        currentFrame = [],\n        frames = []; // TODO added for LHLS, make sure this is OK\n\n    frames.byteLength = 0;\n    frames.nalCount = 0;\n    frames.duration = 0;\n    currentFrame.byteLength = 0;\n\n    for (i = 0; i < nalUnits.length; i++) {\n      currentNal = nalUnits[i]; // Split on 'aud'-type nal units\n\n      if (currentNal.nalUnitType === 'access_unit_delimiter_rbsp') {\n        // Since the very first nal unit is expected to be an AUD\n        // only push to the frames array when currentFrame is not empty\n        if (currentFrame.length) {\n          currentFrame.duration = currentNal.dts - currentFrame.dts; // TODO added for LHLS, make sure this is OK\n\n          frames.byteLength += currentFrame.byteLength;\n          frames.nalCount += currentFrame.length;\n          frames.duration += currentFrame.duration;\n          frames.push(currentFrame);\n        }\n\n        currentFrame = [currentNal];\n        currentFrame.byteLength = currentNal.data.byteLength;\n        currentFrame.pts = currentNal.pts;\n        currentFrame.dts = currentNal.dts;\n      } else {\n        // Specifically flag key frames for ease of use later\n        if (currentNal.nalUnitType === 'slice_layer_without_partitioning_rbsp_idr') {\n          currentFrame.keyFrame = true;\n        }\n\n        currentFrame.duration = currentNal.dts - currentFrame.dts;\n        currentFrame.byteLength += currentNal.data.byteLength;\n        currentFrame.push(currentNal);\n      }\n    } // For the last frame, use the duration of the previous frame if we\n    // have nothing better to go on\n\n\n    if (frames.length && (!currentFrame.duration || currentFrame.duration <= 0)) {\n      currentFrame.duration = frames[frames.length - 1].duration;\n    } // Push the final frame\n    // TODO added for LHLS, make sure this is OK\n\n\n    frames.byteLength += currentFrame.byteLength;\n    frames.nalCount += currentFrame.length;\n    frames.duration += currentFrame.duration;\n    frames.push(currentFrame);\n    return frames;\n  }; // Convert an array of frames into an array of Gop with each Gop being composed\n  // of the frames that make up that Gop\n  // Also keep track of cummulative data about the Gop from the frames such as the\n  // Gop duration, starting pts, etc.\n\n\n  var groupFramesIntoGops = function groupFramesIntoGops(frames) {\n    var i,\n        currentFrame,\n        currentGop = [],\n        gops = []; // We must pre-set some of the values on the Gop since we\n    // keep running totals of these values\n\n    currentGop.byteLength = 0;\n    currentGop.nalCount = 0;\n    currentGop.duration = 0;\n    currentGop.pts = frames[0].pts;\n    currentGop.dts = frames[0].dts; // store some metadata about all the Gops\n\n    gops.byteLength = 0;\n    gops.nalCount = 0;\n    gops.duration = 0;\n    gops.pts = frames[0].pts;\n    gops.dts = frames[0].dts;\n\n    for (i = 0; i < frames.length; i++) {\n      currentFrame = frames[i];\n\n      if (currentFrame.keyFrame) {\n        // Since the very first frame is expected to be an keyframe\n        // only push to the gops array when currentGop is not empty\n        if (currentGop.length) {\n          gops.push(currentGop);\n          gops.byteLength += currentGop.byteLength;\n          gops.nalCount += currentGop.nalCount;\n          gops.duration += currentGop.duration;\n        }\n\n        currentGop = [currentFrame];\n        currentGop.nalCount = currentFrame.length;\n        currentGop.byteLength = currentFrame.byteLength;\n        currentGop.pts = currentFrame.pts;\n        currentGop.dts = currentFrame.dts;\n        currentGop.duration = currentFrame.duration;\n      } else {\n        currentGop.duration += currentFrame.duration;\n        currentGop.nalCount += currentFrame.length;\n        currentGop.byteLength += currentFrame.byteLength;\n        currentGop.push(currentFrame);\n      }\n    }\n\n    if (gops.length && currentGop.duration <= 0) {\n      currentGop.duration = gops[gops.length - 1].duration;\n    }\n\n    gops.byteLength += currentGop.byteLength;\n    gops.nalCount += currentGop.nalCount;\n    gops.duration += currentGop.duration; // push the final Gop\n\n    gops.push(currentGop);\n    return gops;\n  };\n  /*\n   * Search for the first keyframe in the GOPs and throw away all frames\n   * until that keyframe. Then extend the duration of the pulled keyframe\n   * and pull the PTS and DTS of the keyframe so that it covers the time\n   * range of the frames that were disposed.\n   *\n   * @param {Array} gops video GOPs\n   * @returns {Array} modified video GOPs\n   */\n\n\n  var extendFirstKeyFrame = function extendFirstKeyFrame(gops) {\n    var currentGop;\n\n    if (!gops[0][0].keyFrame && gops.length > 1) {\n      // Remove the first GOP\n      currentGop = gops.shift();\n      gops.byteLength -= currentGop.byteLength;\n      gops.nalCount -= currentGop.nalCount; // Extend the first frame of what is now the\n      // first gop to cover the time period of the\n      // frames we just removed\n\n      gops[0][0].dts = currentGop.dts;\n      gops[0][0].pts = currentGop.pts;\n      gops[0][0].duration += currentGop.duration;\n    }\n\n    return gops;\n  };\n  /**\n   * Default sample object\n   * see ISO/IEC 14496-12:2012, section 8.6.4.3\n   */\n\n\n  var createDefaultSample = function createDefaultSample() {\n    return {\n      size: 0,\n      flags: {\n        isLeading: 0,\n        dependsOn: 1,\n        isDependedOn: 0,\n        hasRedundancy: 0,\n        degradationPriority: 0,\n        isNonSyncSample: 1\n      }\n    };\n  };\n  /*\n   * Collates information from a video frame into an object for eventual\n   * entry into an MP4 sample table.\n   *\n   * @param {Object} frame the video frame\n   * @param {Number} dataOffset the byte offset to position the sample\n   * @return {Object} object containing sample table info for a frame\n   */\n\n\n  var sampleForFrame = function sampleForFrame(frame, dataOffset) {\n    var sample = createDefaultSample();\n    sample.dataOffset = dataOffset;\n    sample.compositionTimeOffset = frame.pts - frame.dts;\n    sample.duration = frame.duration;\n    sample.size = 4 * frame.length; // Space for nal unit size\n\n    sample.size += frame.byteLength;\n\n    if (frame.keyFrame) {\n      sample.flags.dependsOn = 2;\n      sample.flags.isNonSyncSample = 0;\n    }\n\n    return sample;\n  }; // generate the track's sample table from an array of gops\n\n\n  var generateSampleTable$1 = function generateSampleTable(gops, baseDataOffset) {\n    var h,\n        i,\n        sample,\n        currentGop,\n        currentFrame,\n        dataOffset = baseDataOffset || 0,\n        samples = [];\n\n    for (h = 0; h < gops.length; h++) {\n      currentGop = gops[h];\n\n      for (i = 0; i < currentGop.length; i++) {\n        currentFrame = currentGop[i];\n        sample = sampleForFrame(currentFrame, dataOffset);\n        dataOffset += sample.size;\n        samples.push(sample);\n      }\n    }\n\n    return samples;\n  }; // generate the track's raw mdat data from an array of gops\n\n\n  var concatenateNalData = function concatenateNalData(gops) {\n    var h,\n        i,\n        j,\n        currentGop,\n        currentFrame,\n        currentNal,\n        dataOffset = 0,\n        nalsByteLength = gops.byteLength,\n        numberOfNals = gops.nalCount,\n        totalByteLength = nalsByteLength + 4 * numberOfNals,\n        data = new Uint8Array(totalByteLength),\n        view = new DataView(data.buffer); // For each Gop..\n\n    for (h = 0; h < gops.length; h++) {\n      currentGop = gops[h]; // For each Frame..\n\n      for (i = 0; i < currentGop.length; i++) {\n        currentFrame = currentGop[i]; // For each NAL..\n\n        for (j = 0; j < currentFrame.length; j++) {\n          currentNal = currentFrame[j];\n          view.setUint32(dataOffset, currentNal.data.byteLength);\n          dataOffset += 4;\n          data.set(currentNal.data, dataOffset);\n          dataOffset += currentNal.data.byteLength;\n        }\n      }\n    }\n\n    return data;\n  }; // generate the track's sample table from a frame\n\n\n  var generateSampleTableForFrame = function generateSampleTableForFrame(frame, baseDataOffset) {\n    var sample,\n        dataOffset = baseDataOffset || 0,\n        samples = [];\n    sample = sampleForFrame(frame, dataOffset);\n    samples.push(sample);\n    return samples;\n  }; // generate the track's raw mdat data from a frame\n\n\n  var concatenateNalDataForFrame = function concatenateNalDataForFrame(frame) {\n    var i,\n        currentNal,\n        dataOffset = 0,\n        nalsByteLength = frame.byteLength,\n        numberOfNals = frame.length,\n        totalByteLength = nalsByteLength + 4 * numberOfNals,\n        data = new Uint8Array(totalByteLength),\n        view = new DataView(data.buffer); // For each NAL..\n\n    for (i = 0; i < frame.length; i++) {\n      currentNal = frame[i];\n      view.setUint32(dataOffset, currentNal.data.byteLength);\n      dataOffset += 4;\n      data.set(currentNal.data, dataOffset);\n      dataOffset += currentNal.data.byteLength;\n    }\n\n    return data;\n  };\n\n  var frameUtils = {\n    groupNalsIntoFrames: groupNalsIntoFrames,\n    groupFramesIntoGops: groupFramesIntoGops,\n    extendFirstKeyFrame: extendFirstKeyFrame,\n    generateSampleTable: generateSampleTable$1,\n    concatenateNalData: concatenateNalData,\n    generateSampleTableForFrame: generateSampleTableForFrame,\n    concatenateNalDataForFrame: concatenateNalDataForFrame\n  };\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n\n  var highPrefix = [33, 16, 5, 32, 164, 27];\n  var lowPrefix = [33, 65, 108, 84, 1, 2, 4, 8, 168, 2, 4, 8, 17, 191, 252];\n\n  var zeroFill = function zeroFill(count) {\n    var a = [];\n\n    while (count--) {\n      a.push(0);\n    }\n\n    return a;\n  };\n\n  var makeTable = function makeTable(metaTable) {\n    return Object.keys(metaTable).reduce(function (obj, key) {\n      obj[key] = new Uint8Array(metaTable[key].reduce(function (arr, part) {\n        return arr.concat(part);\n      }, []));\n      return obj;\n    }, {});\n  };\n\n  var silence;\n\n  var silence_1 = function silence_1() {\n    if (!silence) {\n      // Frames-of-silence to use for filling in missing AAC frames\n      var coneOfSilence = {\n        96000: [highPrefix, [227, 64], zeroFill(154), [56]],\n        88200: [highPrefix, [231], zeroFill(170), [56]],\n        64000: [highPrefix, [248, 192], zeroFill(240), [56]],\n        48000: [highPrefix, [255, 192], zeroFill(268), [55, 148, 128], zeroFill(54), [112]],\n        44100: [highPrefix, [255, 192], zeroFill(268), [55, 163, 128], zeroFill(84), [112]],\n        32000: [highPrefix, [255, 192], zeroFill(268), [55, 234], zeroFill(226), [112]],\n        24000: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 112], zeroFill(126), [224]],\n        16000: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 255], zeroFill(269), [223, 108], zeroFill(195), [1, 192]],\n        12000: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 253, 128], zeroFill(259), [56]],\n        11025: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 255, 192], zeroFill(268), [55, 175, 128], zeroFill(108), [112]],\n        8000: [lowPrefix, zeroFill(268), [3, 121, 16], zeroFill(47), [7]]\n      };\n      silence = makeTable(coneOfSilence);\n    }\n\n    return silence;\n  };\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n\n  /**\n   * Sum the `byteLength` properties of the data in each AAC frame\n   */\n\n\n  var sumFrameByteLengths = function sumFrameByteLengths(array) {\n    var i,\n        currentObj,\n        sum = 0; // sum the byteLength's all each nal unit in the frame\n\n    for (i = 0; i < array.length; i++) {\n      currentObj = array[i];\n      sum += currentObj.data.byteLength;\n    }\n\n    return sum;\n  }; // Possibly pad (prefix) the audio track with silence if appending this track\n  // would lead to the introduction of a gap in the audio buffer\n\n\n  var prefixWithSilence = function prefixWithSilence(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime) {\n    var baseMediaDecodeTimeTs,\n        frameDuration = 0,\n        audioGapDuration = 0,\n        audioFillFrameCount = 0,\n        audioFillDuration = 0,\n        silentFrame,\n        i,\n        firstFrame;\n\n    if (!frames.length) {\n      return;\n    }\n\n    baseMediaDecodeTimeTs = clock.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate); // determine frame clock duration based on sample rate, round up to avoid overfills\n\n    frameDuration = Math.ceil(clock.ONE_SECOND_IN_TS / (track.samplerate / 1024));\n\n    if (audioAppendStartTs && videoBaseMediaDecodeTime) {\n      // insert the shortest possible amount (audio gap or audio to video gap)\n      audioGapDuration = baseMediaDecodeTimeTs - Math.max(audioAppendStartTs, videoBaseMediaDecodeTime); // number of full frames in the audio gap\n\n      audioFillFrameCount = Math.floor(audioGapDuration / frameDuration);\n      audioFillDuration = audioFillFrameCount * frameDuration;\n    } // don't attempt to fill gaps smaller than a single frame or larger\n    // than a half second\n\n\n    if (audioFillFrameCount < 1 || audioFillDuration > clock.ONE_SECOND_IN_TS / 2) {\n      return;\n    }\n\n    silentFrame = silence_1()[track.samplerate];\n\n    if (!silentFrame) {\n      // we don't have a silent frame pregenerated for the sample rate, so use a frame\n      // from the content instead\n      silentFrame = frames[0].data;\n    }\n\n    for (i = 0; i < audioFillFrameCount; i++) {\n      firstFrame = frames[0];\n      frames.splice(0, 0, {\n        data: silentFrame,\n        dts: firstFrame.dts - frameDuration,\n        pts: firstFrame.pts - frameDuration\n      });\n    }\n\n    track.baseMediaDecodeTime -= Math.floor(clock.videoTsToAudioTs(audioFillDuration, track.samplerate));\n    return audioFillDuration;\n  }; // If the audio segment extends before the earliest allowed dts\n  // value, remove AAC frames until starts at or after the earliest\n  // allowed DTS so that we don't end up with a negative baseMedia-\n  // DecodeTime for the audio track\n\n\n  var trimAdtsFramesByEarliestDts = function trimAdtsFramesByEarliestDts(adtsFrames, track, earliestAllowedDts) {\n    if (track.minSegmentDts >= earliestAllowedDts) {\n      return adtsFrames;\n    } // We will need to recalculate the earliest segment Dts\n\n\n    track.minSegmentDts = Infinity;\n    return adtsFrames.filter(function (currentFrame) {\n      // If this is an allowed frame, keep it and record it's Dts\n      if (currentFrame.dts >= earliestAllowedDts) {\n        track.minSegmentDts = Math.min(track.minSegmentDts, currentFrame.dts);\n        track.minSegmentPts = track.minSegmentDts;\n        return true;\n      } // Otherwise, discard it\n\n\n      return false;\n    });\n  }; // generate the track's raw mdat data from an array of frames\n\n\n  var generateSampleTable = function generateSampleTable(frames) {\n    var i,\n        currentFrame,\n        samples = [];\n\n    for (i = 0; i < frames.length; i++) {\n      currentFrame = frames[i];\n      samples.push({\n        size: currentFrame.data.byteLength,\n        duration: 1024 // For AAC audio, all samples contain 1024 samples\n\n      });\n    }\n\n    return samples;\n  }; // generate the track's sample table from an array of frames\n\n\n  var concatenateFrameData = function concatenateFrameData(frames) {\n    var i,\n        currentFrame,\n        dataOffset = 0,\n        data = new Uint8Array(sumFrameByteLengths(frames));\n\n    for (i = 0; i < frames.length; i++) {\n      currentFrame = frames[i];\n      data.set(currentFrame.data, dataOffset);\n      dataOffset += currentFrame.data.byteLength;\n    }\n\n    return data;\n  };\n\n  var audioFrameUtils = {\n    prefixWithSilence: prefixWithSilence,\n    trimAdtsFramesByEarliestDts: trimAdtsFramesByEarliestDts,\n    generateSampleTable: generateSampleTable,\n    concatenateFrameData: concatenateFrameData\n  };\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n\n  var ONE_SECOND_IN_TS$3 = clock.ONE_SECOND_IN_TS;\n  /**\n   * Store information about the start and end of the track and the\n   * duration for each frame/sample we process in order to calculate\n   * the baseMediaDecodeTime\n   */\n\n  var collectDtsInfo = function collectDtsInfo(track, data) {\n    if (typeof data.pts === 'number') {\n      if (track.timelineStartInfo.pts === undefined) {\n        track.timelineStartInfo.pts = data.pts;\n      }\n\n      if (track.minSegmentPts === undefined) {\n        track.minSegmentPts = data.pts;\n      } else {\n        track.minSegmentPts = Math.min(track.minSegmentPts, data.pts);\n      }\n\n      if (track.maxSegmentPts === undefined) {\n        track.maxSegmentPts = data.pts;\n      } else {\n        track.maxSegmentPts = Math.max(track.maxSegmentPts, data.pts);\n      }\n    }\n\n    if (typeof data.dts === 'number') {\n      if (track.timelineStartInfo.dts === undefined) {\n        track.timelineStartInfo.dts = data.dts;\n      }\n\n      if (track.minSegmentDts === undefined) {\n        track.minSegmentDts = data.dts;\n      } else {\n        track.minSegmentDts = Math.min(track.minSegmentDts, data.dts);\n      }\n\n      if (track.maxSegmentDts === undefined) {\n        track.maxSegmentDts = data.dts;\n      } else {\n        track.maxSegmentDts = Math.max(track.maxSegmentDts, data.dts);\n      }\n    }\n  };\n  /**\n   * Clear values used to calculate the baseMediaDecodeTime between\n   * tracks\n   */\n\n\n  var clearDtsInfo = function clearDtsInfo(track) {\n    delete track.minSegmentDts;\n    delete track.maxSegmentDts;\n    delete track.minSegmentPts;\n    delete track.maxSegmentPts;\n  };\n  /**\n   * Calculate the track's baseMediaDecodeTime based on the earliest\n   * DTS the transmuxer has ever seen and the minimum DTS for the\n   * current track\n   * @param track {object} track metadata configuration\n   * @param keepOriginalTimestamps {boolean} If true, keep the timestamps\n   *        in the source; false to adjust the first segment to start at 0.\n   */\n\n\n  var calculateTrackBaseMediaDecodeTime = function calculateTrackBaseMediaDecodeTime(track, keepOriginalTimestamps) {\n    var baseMediaDecodeTime,\n        scale,\n        minSegmentDts = track.minSegmentDts; // Optionally adjust the time so the first segment starts at zero.\n\n    if (!keepOriginalTimestamps) {\n      minSegmentDts -= track.timelineStartInfo.dts;\n    } // track.timelineStartInfo.baseMediaDecodeTime is the location, in time, where\n    // we want the start of the first segment to be placed\n\n\n    baseMediaDecodeTime = track.timelineStartInfo.baseMediaDecodeTime; // Add to that the distance this segment is from the very first\n\n    baseMediaDecodeTime += minSegmentDts; // baseMediaDecodeTime must not become negative\n\n    baseMediaDecodeTime = Math.max(0, baseMediaDecodeTime);\n\n    if (track.type === 'audio') {\n      // Audio has a different clock equal to the sampling_rate so we need to\n      // scale the PTS values into the clock rate of the track\n      scale = track.samplerate / ONE_SECOND_IN_TS$3;\n      baseMediaDecodeTime *= scale;\n      baseMediaDecodeTime = Math.floor(baseMediaDecodeTime);\n    }\n\n    return baseMediaDecodeTime;\n  };\n\n  var trackDecodeInfo = {\n    clearDtsInfo: clearDtsInfo,\n    calculateTrackBaseMediaDecodeTime: calculateTrackBaseMediaDecodeTime,\n    collectDtsInfo: collectDtsInfo\n  };\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   *\n   * Reads in-band caption information from a video elementary\n   * stream. Captions must follow the CEA-708 standard for injection\n   * into an MPEG-2 transport streams.\n   * @see https://en.wikipedia.org/wiki/CEA-708\n   * @see https://www.gpo.gov/fdsys/pkg/CFR-2007-title47-vol1/pdf/CFR-2007-title47-vol1-sec15-119.pdf\n   */\n  // payload type field to indicate how they are to be\n  // interpreted. CEAS-708 caption content is always transmitted with\n  // payload type 0x04.\n\n  var USER_DATA_REGISTERED_ITU_T_T35 = 4,\n      RBSP_TRAILING_BITS = 128;\n  /**\n    * Parse a supplemental enhancement information (SEI) NAL unit.\n    * Stops parsing once a message of type ITU T T35 has been found.\n    *\n    * @param bytes {Uint8Array} the bytes of a SEI NAL unit\n    * @return {object} the parsed SEI payload\n    * @see Rec. ITU-T H.264, 7.3.2.3.1\n    */\n\n  var parseSei = function parseSei(bytes) {\n    var i = 0,\n        result = {\n      payloadType: -1,\n      payloadSize: 0\n    },\n        payloadType = 0,\n        payloadSize = 0; // go through the sei_rbsp parsing each each individual sei_message\n\n    while (i < bytes.byteLength) {\n      // stop once we have hit the end of the sei_rbsp\n      if (bytes[i] === RBSP_TRAILING_BITS) {\n        break;\n      } // Parse payload type\n\n\n      while (bytes[i] === 0xFF) {\n        payloadType += 255;\n        i++;\n      }\n\n      payloadType += bytes[i++]; // Parse payload size\n\n      while (bytes[i] === 0xFF) {\n        payloadSize += 255;\n        i++;\n      }\n\n      payloadSize += bytes[i++]; // this sei_message is a 608/708 caption so save it and break\n      // there can only ever be one caption message in a frame's sei\n\n      if (!result.payload && payloadType === USER_DATA_REGISTERED_ITU_T_T35) {\n        var userIdentifier = String.fromCharCode(bytes[i + 3], bytes[i + 4], bytes[i + 5], bytes[i + 6]);\n\n        if (userIdentifier === 'GA94') {\n          result.payloadType = payloadType;\n          result.payloadSize = payloadSize;\n          result.payload = bytes.subarray(i, i + payloadSize);\n          break;\n        } else {\n          result.payload = void 0;\n        }\n      } // skip the payload and parse the next message\n\n\n      i += payloadSize;\n      payloadType = 0;\n      payloadSize = 0;\n    }\n\n    return result;\n  }; // see ANSI/SCTE 128-1 (2013), section 8.1\n\n\n  var parseUserData = function parseUserData(sei) {\n    // itu_t_t35_contry_code must be 181 (United States) for\n    // captions\n    if (sei.payload[0] !== 181) {\n      return null;\n    } // itu_t_t35_provider_code should be 49 (ATSC) for captions\n\n\n    if ((sei.payload[1] << 8 | sei.payload[2]) !== 49) {\n      return null;\n    } // the user_identifier should be \"GA94\" to indicate ATSC1 data\n\n\n    if (String.fromCharCode(sei.payload[3], sei.payload[4], sei.payload[5], sei.payload[6]) !== 'GA94') {\n      return null;\n    } // finally, user_data_type_code should be 0x03 for caption data\n\n\n    if (sei.payload[7] !== 0x03) {\n      return null;\n    } // return the user_data_type_structure and strip the trailing\n    // marker bits\n\n\n    return sei.payload.subarray(8, sei.payload.length - 1);\n  }; // see CEA-708-D, section 4.4\n\n\n  var parseCaptionPackets = function parseCaptionPackets(pts, userData) {\n    var results = [],\n        i,\n        count,\n        offset,\n        data; // if this is just filler, return immediately\n\n    if (!(userData[0] & 0x40)) {\n      return results;\n    } // parse out the cc_data_1 and cc_data_2 fields\n\n\n    count = userData[0] & 0x1f;\n\n    for (i = 0; i < count; i++) {\n      offset = i * 3;\n      data = {\n        type: userData[offset + 2] & 0x03,\n        pts: pts\n      }; // capture cc data when cc_valid is 1\n\n      if (userData[offset + 2] & 0x04) {\n        data.ccData = userData[offset + 3] << 8 | userData[offset + 4];\n        results.push(data);\n      }\n    }\n\n    return results;\n  };\n\n  var discardEmulationPreventionBytes$1 = function discardEmulationPreventionBytes(data) {\n    var length = data.byteLength,\n        emulationPreventionBytesPositions = [],\n        i = 1,\n        newLength,\n        newData; // Find all `Emulation Prevention Bytes`\n\n    while (i < length - 2) {\n      if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n        emulationPreventionBytesPositions.push(i + 2);\n        i += 2;\n      } else {\n        i++;\n      }\n    } // If no Emulation Prevention Bytes were found just return the original\n    // array\n\n\n    if (emulationPreventionBytesPositions.length === 0) {\n      return data;\n    } // Create a new array to hold the NAL unit data\n\n\n    newLength = length - emulationPreventionBytesPositions.length;\n    newData = new Uint8Array(newLength);\n    var sourceIndex = 0;\n\n    for (i = 0; i < newLength; sourceIndex++, i++) {\n      if (sourceIndex === emulationPreventionBytesPositions[0]) {\n        // Skip this byte\n        sourceIndex++; // Remove this position index\n\n        emulationPreventionBytesPositions.shift();\n      }\n\n      newData[i] = data[sourceIndex];\n    }\n\n    return newData;\n  }; // exports\n\n\n  var captionPacketParser = {\n    parseSei: parseSei,\n    parseUserData: parseUserData,\n    parseCaptionPackets: parseCaptionPackets,\n    discardEmulationPreventionBytes: discardEmulationPreventionBytes$1,\n    USER_DATA_REGISTERED_ITU_T_T35: USER_DATA_REGISTERED_ITU_T_T35\n  }; // Link To Transport\n  // -----------------\n\n  var CaptionStream$1 = function CaptionStream(options) {\n    options = options || {};\n    CaptionStream.prototype.init.call(this); // parse708captions flag, default to true\n\n    this.parse708captions_ = typeof options.parse708captions === 'boolean' ? options.parse708captions : true;\n    this.captionPackets_ = [];\n    this.ccStreams_ = [new Cea608Stream(0, 0), // eslint-disable-line no-use-before-define\n    new Cea608Stream(0, 1), // eslint-disable-line no-use-before-define\n    new Cea608Stream(1, 0), // eslint-disable-line no-use-before-define\n    new Cea608Stream(1, 1) // eslint-disable-line no-use-before-define\n    ];\n\n    if (this.parse708captions_) {\n      this.cc708Stream_ = new Cea708Stream({\n        captionServices: options.captionServices\n      }); // eslint-disable-line no-use-before-define\n    }\n\n    this.reset(); // forward data and done events from CCs to this CaptionStream\n\n    this.ccStreams_.forEach(function (cc) {\n      cc.on('data', this.trigger.bind(this, 'data'));\n      cc.on('partialdone', this.trigger.bind(this, 'partialdone'));\n      cc.on('done', this.trigger.bind(this, 'done'));\n    }, this);\n\n    if (this.parse708captions_) {\n      this.cc708Stream_.on('data', this.trigger.bind(this, 'data'));\n      this.cc708Stream_.on('partialdone', this.trigger.bind(this, 'partialdone'));\n      this.cc708Stream_.on('done', this.trigger.bind(this, 'done'));\n    }\n  };\n\n  CaptionStream$1.prototype = new stream();\n\n  CaptionStream$1.prototype.push = function (event) {\n    var sei, userData, newCaptionPackets; // only examine SEI NALs\n\n    if (event.nalUnitType !== 'sei_rbsp') {\n      return;\n    } // parse the sei\n\n\n    sei = captionPacketParser.parseSei(event.escapedRBSP); // no payload data, skip\n\n    if (!sei.payload) {\n      return;\n    } // ignore everything but user_data_registered_itu_t_t35\n\n\n    if (sei.payloadType !== captionPacketParser.USER_DATA_REGISTERED_ITU_T_T35) {\n      return;\n    } // parse out the user data payload\n\n\n    userData = captionPacketParser.parseUserData(sei); // ignore unrecognized userData\n\n    if (!userData) {\n      return;\n    } // Sometimes, the same segment # will be downloaded twice. To stop the\n    // caption data from being processed twice, we track the latest dts we've\n    // received and ignore everything with a dts before that. However, since\n    // data for a specific dts can be split across packets on either side of\n    // a segment boundary, we need to make sure we *don't* ignore the packets\n    // from the *next* segment that have dts === this.latestDts_. By constantly\n    // tracking the number of packets received with dts === this.latestDts_, we\n    // know how many should be ignored once we start receiving duplicates.\n\n\n    if (event.dts < this.latestDts_) {\n      // We've started getting older data, so set the flag.\n      this.ignoreNextEqualDts_ = true;\n      return;\n    } else if (event.dts === this.latestDts_ && this.ignoreNextEqualDts_) {\n      this.numSameDts_--;\n\n      if (!this.numSameDts_) {\n        // We've received the last duplicate packet, time to start processing again\n        this.ignoreNextEqualDts_ = false;\n      }\n\n      return;\n    } // parse out CC data packets and save them for later\n\n\n    newCaptionPackets = captionPacketParser.parseCaptionPackets(event.pts, userData);\n    this.captionPackets_ = this.captionPackets_.concat(newCaptionPackets);\n\n    if (this.latestDts_ !== event.dts) {\n      this.numSameDts_ = 0;\n    }\n\n    this.numSameDts_++;\n    this.latestDts_ = event.dts;\n  };\n\n  CaptionStream$1.prototype.flushCCStreams = function (flushType) {\n    this.ccStreams_.forEach(function (cc) {\n      return flushType === 'flush' ? cc.flush() : cc.partialFlush();\n    }, this);\n  };\n\n  CaptionStream$1.prototype.flushStream = function (flushType) {\n    // make sure we actually parsed captions before proceeding\n    if (!this.captionPackets_.length) {\n      this.flushCCStreams(flushType);\n      return;\n    } // In Chrome, the Array#sort function is not stable so add a\n    // presortIndex that we can use to ensure we get a stable-sort\n\n\n    this.captionPackets_.forEach(function (elem, idx) {\n      elem.presortIndex = idx;\n    }); // sort caption byte-pairs based on their PTS values\n\n    this.captionPackets_.sort(function (a, b) {\n      if (a.pts === b.pts) {\n        return a.presortIndex - b.presortIndex;\n      }\n\n      return a.pts - b.pts;\n    });\n    this.captionPackets_.forEach(function (packet) {\n      if (packet.type < 2) {\n        // Dispatch packet to the right Cea608Stream\n        this.dispatchCea608Packet(packet);\n      } else {\n        // Dispatch packet to the Cea708Stream\n        this.dispatchCea708Packet(packet);\n      }\n    }, this);\n    this.captionPackets_.length = 0;\n    this.flushCCStreams(flushType);\n  };\n\n  CaptionStream$1.prototype.flush = function () {\n    return this.flushStream('flush');\n  }; // Only called if handling partial data\n\n\n  CaptionStream$1.prototype.partialFlush = function () {\n    return this.flushStream('partialFlush');\n  };\n\n  CaptionStream$1.prototype.reset = function () {\n    this.latestDts_ = null;\n    this.ignoreNextEqualDts_ = false;\n    this.numSameDts_ = 0;\n    this.activeCea608Channel_ = [null, null];\n    this.ccStreams_.forEach(function (ccStream) {\n      ccStream.reset();\n    });\n  }; // From the CEA-608 spec:\n\n  /*\n   * When XDS sub-packets are interleaved with other services, the end of each sub-packet shall be followed\n   * by a control pair to change to a different service. When any of the control codes from 0x10 to 0x1F is\n   * used to begin a control code pair, it indicates the return to captioning or Text data. The control code pair\n   * and subsequent data should then be processed according to the FCC rules. It may be necessary for the\n   * line 21 data encoder to automatically insert a control code pair (i.e. RCL, RU2, RU3, RU4, RDC, or RTD)\n   * to switch to captioning or Text.\n  */\n  // With that in mind, we ignore any data between an XDS control code and a\n  // subsequent closed-captioning control code.\n\n\n  CaptionStream$1.prototype.dispatchCea608Packet = function (packet) {\n    // NOTE: packet.type is the CEA608 field\n    if (this.setsTextOrXDSActive(packet)) {\n      this.activeCea608Channel_[packet.type] = null;\n    } else if (this.setsChannel1Active(packet)) {\n      this.activeCea608Channel_[packet.type] = 0;\n    } else if (this.setsChannel2Active(packet)) {\n      this.activeCea608Channel_[packet.type] = 1;\n    }\n\n    if (this.activeCea608Channel_[packet.type] === null) {\n      // If we haven't received anything to set the active channel, or the\n      // packets are Text/XDS data, discard the data; we don't want jumbled\n      // captions\n      return;\n    }\n\n    this.ccStreams_[(packet.type << 1) + this.activeCea608Channel_[packet.type]].push(packet);\n  };\n\n  CaptionStream$1.prototype.setsChannel1Active = function (packet) {\n    return (packet.ccData & 0x7800) === 0x1000;\n  };\n\n  CaptionStream$1.prototype.setsChannel2Active = function (packet) {\n    return (packet.ccData & 0x7800) === 0x1800;\n  };\n\n  CaptionStream$1.prototype.setsTextOrXDSActive = function (packet) {\n    return (packet.ccData & 0x7100) === 0x0100 || (packet.ccData & 0x78fe) === 0x102a || (packet.ccData & 0x78fe) === 0x182a;\n  };\n\n  CaptionStream$1.prototype.dispatchCea708Packet = function (packet) {\n    if (this.parse708captions_) {\n      this.cc708Stream_.push(packet);\n    }\n  }; // ----------------------\n  // Session to Application\n  // ----------------------\n  // This hash maps special and extended character codes to their\n  // proper Unicode equivalent. The first one-byte key is just a\n  // non-standard character code. The two-byte keys that follow are\n  // the extended CEA708 character codes, along with the preceding\n  // 0x10 extended character byte to distinguish these codes from\n  // non-extended character codes. Every CEA708 character code that\n  // is not in this object maps directly to a standard unicode\n  // character code.\n  // The transparent space and non-breaking transparent space are\n  // technically not fully supported since there is no code to\n  // make them transparent, so they have normal non-transparent\n  // stand-ins.\n  // The special closed caption (CC) character isn't a standard\n  // unicode character, so a fairly similar unicode character was\n  // chosen in it's place.\n\n\n  var CHARACTER_TRANSLATION_708 = {\n    0x7f: 0x266a,\n    // \n    0x1020: 0x20,\n    // Transparent Space\n    0x1021: 0xa0,\n    // Nob-breaking Transparent Space\n    0x1025: 0x2026,\n    // \n    0x102a: 0x0160,\n    // \n    0x102c: 0x0152,\n    // \n    0x1030: 0x2588,\n    // \n    0x1031: 0x2018,\n    // \n    0x1032: 0x2019,\n    // \n    0x1033: 0x201c,\n    // \n    0x1034: 0x201d,\n    // \n    0x1035: 0x2022,\n    // \n    0x1039: 0x2122,\n    // \n    0x103a: 0x0161,\n    // \n    0x103c: 0x0153,\n    // \n    0x103d: 0x2120,\n    // \n    0x103f: 0x0178,\n    // \n    0x1076: 0x215b,\n    // \n    0x1077: 0x215c,\n    // \n    0x1078: 0x215d,\n    // \n    0x1079: 0x215e,\n    // \n    0x107a: 0x23d0,\n    // \n    0x107b: 0x23a4,\n    // \n    0x107c: 0x23a3,\n    // \n    0x107d: 0x23af,\n    // \n    0x107e: 0x23a6,\n    // \n    0x107f: 0x23a1,\n    // \n    0x10a0: 0x3138 //  (CC char)\n\n  };\n\n  var get708CharFromCode = function get708CharFromCode(code) {\n    var newCode = CHARACTER_TRANSLATION_708[code] || code;\n\n    if (code & 0x1000 && code === newCode) {\n      // Invalid extended code\n      return '';\n    }\n\n    return String.fromCharCode(newCode);\n  };\n\n  var within708TextBlock = function within708TextBlock(b) {\n    return 0x20 <= b && b <= 0x7f || 0xa0 <= b && b <= 0xff;\n  };\n\n  var Cea708Window = function Cea708Window(windowNum) {\n    this.windowNum = windowNum;\n    this.reset();\n  };\n\n  Cea708Window.prototype.reset = function () {\n    this.clearText();\n    this.pendingNewLine = false;\n    this.winAttr = {};\n    this.penAttr = {};\n    this.penLoc = {};\n    this.penColor = {}; // These default values are arbitrary,\n    // defineWindow will usually override them\n\n    this.visible = 0;\n    this.rowLock = 0;\n    this.columnLock = 0;\n    this.priority = 0;\n    this.relativePositioning = 0;\n    this.anchorVertical = 0;\n    this.anchorHorizontal = 0;\n    this.anchorPoint = 0;\n    this.rowCount = 1;\n    this.virtualRowCount = this.rowCount + 1;\n    this.columnCount = 41;\n    this.windowStyle = 0;\n    this.penStyle = 0;\n  };\n\n  Cea708Window.prototype.getText = function () {\n    return this.rows.join('\\n');\n  };\n\n  Cea708Window.prototype.clearText = function () {\n    this.rows = [''];\n    this.rowIdx = 0;\n  };\n\n  Cea708Window.prototype.newLine = function (pts) {\n    if (this.rows.length >= this.virtualRowCount && typeof this.beforeRowOverflow === 'function') {\n      this.beforeRowOverflow(pts);\n    }\n\n    if (this.rows.length > 0) {\n      this.rows.push('');\n      this.rowIdx++;\n    } // Show all virtual rows since there's no visible scrolling\n\n\n    while (this.rows.length > this.virtualRowCount) {\n      this.rows.shift();\n      this.rowIdx--;\n    }\n  };\n\n  Cea708Window.prototype.isEmpty = function () {\n    if (this.rows.length === 0) {\n      return true;\n    } else if (this.rows.length === 1) {\n      return this.rows[0] === '';\n    }\n\n    return false;\n  };\n\n  Cea708Window.prototype.addText = function (text) {\n    this.rows[this.rowIdx] += text;\n  };\n\n  Cea708Window.prototype.backspace = function () {\n    if (!this.isEmpty()) {\n      var row = this.rows[this.rowIdx];\n      this.rows[this.rowIdx] = row.substr(0, row.length - 1);\n    }\n  };\n\n  var Cea708Service = function Cea708Service(serviceNum, encoding, stream) {\n    this.serviceNum = serviceNum;\n    this.text = '';\n    this.currentWindow = new Cea708Window(-1);\n    this.windows = [];\n    this.stream = stream; // Try to setup a TextDecoder if an `encoding` value was provided\n\n    if (typeof encoding === 'string') {\n      this.createTextDecoder(encoding);\n    }\n  };\n  /**\n   * Initialize service windows\n   * Must be run before service use\n   *\n   * @param  {Integer}  pts               PTS value\n   * @param  {Function} beforeRowOverflow Function to execute before row overflow of a window\n   */\n\n\n  Cea708Service.prototype.init = function (pts, beforeRowOverflow) {\n    this.startPts = pts;\n\n    for (var win = 0; win < 8; win++) {\n      this.windows[win] = new Cea708Window(win);\n\n      if (typeof beforeRowOverflow === 'function') {\n        this.windows[win].beforeRowOverflow = beforeRowOverflow;\n      }\n    }\n  };\n  /**\n   * Set current window of service to be affected by commands\n   *\n   * @param  {Integer} windowNum Window number\n   */\n\n\n  Cea708Service.prototype.setCurrentWindow = function (windowNum) {\n    this.currentWindow = this.windows[windowNum];\n  };\n  /**\n   * Try to create a TextDecoder if it is natively supported\n   */\n\n\n  Cea708Service.prototype.createTextDecoder = function (encoding) {\n    if (typeof TextDecoder === 'undefined') {\n      this.stream.trigger('log', {\n        level: 'warn',\n        message: 'The `encoding` option is unsupported without TextDecoder support'\n      });\n    } else {\n      try {\n        this.textDecoder_ = new TextDecoder(encoding);\n      } catch (error) {\n        this.stream.trigger('log', {\n          level: 'warn',\n          message: 'TextDecoder could not be created with ' + encoding + ' encoding. ' + error\n        });\n      }\n    }\n  };\n\n  var Cea708Stream = function Cea708Stream(options) {\n    options = options || {};\n    Cea708Stream.prototype.init.call(this);\n    var self = this;\n    var captionServices = options.captionServices || {};\n    var captionServiceEncodings = {};\n    var serviceProps; // Get service encodings from captionServices option block\n\n    Object.keys(captionServices).forEach(function (serviceName) {\n      serviceProps = captionServices[serviceName];\n\n      if (/^SERVICE/.test(serviceName)) {\n        captionServiceEncodings[serviceName] = serviceProps.encoding;\n      }\n    });\n    this.serviceEncodings = captionServiceEncodings;\n    this.current708Packet = null;\n    this.services = {};\n\n    this.push = function (packet) {\n      if (packet.type === 3) {\n        // 708 packet start\n        self.new708Packet();\n        self.add708Bytes(packet);\n      } else {\n        if (self.current708Packet === null) {\n          // This should only happen at the start of a file if there's no packet start.\n          self.new708Packet();\n        }\n\n        self.add708Bytes(packet);\n      }\n    };\n  };\n\n  Cea708Stream.prototype = new stream();\n  /**\n   * Push current 708 packet, create new 708 packet.\n   */\n\n  Cea708Stream.prototype.new708Packet = function () {\n    if (this.current708Packet !== null) {\n      this.push708Packet();\n    }\n\n    this.current708Packet = {\n      data: [],\n      ptsVals: []\n    };\n  };\n  /**\n   * Add pts and both bytes from packet into current 708 packet.\n   */\n\n\n  Cea708Stream.prototype.add708Bytes = function (packet) {\n    var data = packet.ccData;\n    var byte0 = data >>> 8;\n    var byte1 = data & 0xff; // I would just keep a list of packets instead of bytes, but it isn't clear in the spec\n    // that service blocks will always line up with byte pairs.\n\n    this.current708Packet.ptsVals.push(packet.pts);\n    this.current708Packet.data.push(byte0);\n    this.current708Packet.data.push(byte1);\n  };\n  /**\n   * Parse completed 708 packet into service blocks and push each service block.\n   */\n\n\n  Cea708Stream.prototype.push708Packet = function () {\n    var packet708 = this.current708Packet;\n    var packetData = packet708.data;\n    var serviceNum = null;\n    var blockSize = null;\n    var i = 0;\n    var b = packetData[i++];\n    packet708.seq = b >> 6;\n    packet708.sizeCode = b & 0x3f; // 0b00111111;\n\n    for (; i < packetData.length; i++) {\n      b = packetData[i++];\n      serviceNum = b >> 5;\n      blockSize = b & 0x1f; // 0b00011111\n\n      if (serviceNum === 7 && blockSize > 0) {\n        // Extended service num\n        b = packetData[i++];\n        serviceNum = b;\n      }\n\n      this.pushServiceBlock(serviceNum, i, blockSize);\n\n      if (blockSize > 0) {\n        i += blockSize - 1;\n      }\n    }\n  };\n  /**\n   * Parse service block, execute commands, read text.\n   *\n   * Note: While many of these commands serve important purposes,\n   * many others just parse out the parameters or attributes, but\n   * nothing is done with them because this is not a full and complete\n   * implementation of the entire 708 spec.\n   *\n   * @param  {Integer} serviceNum Service number\n   * @param  {Integer} start      Start index of the 708 packet data\n   * @param  {Integer} size       Block size\n   */\n\n\n  Cea708Stream.prototype.pushServiceBlock = function (serviceNum, start, size) {\n    var b;\n    var i = start;\n    var packetData = this.current708Packet.data;\n    var service = this.services[serviceNum];\n\n    if (!service) {\n      service = this.initService(serviceNum, i);\n    }\n\n    for (; i < start + size && i < packetData.length; i++) {\n      b = packetData[i];\n\n      if (within708TextBlock(b)) {\n        i = this.handleText(i, service);\n      } else if (b === 0x18) {\n        i = this.multiByteCharacter(i, service);\n      } else if (b === 0x10) {\n        i = this.extendedCommands(i, service);\n      } else if (0x80 <= b && b <= 0x87) {\n        i = this.setCurrentWindow(i, service);\n      } else if (0x98 <= b && b <= 0x9f) {\n        i = this.defineWindow(i, service);\n      } else if (b === 0x88) {\n        i = this.clearWindows(i, service);\n      } else if (b === 0x8c) {\n        i = this.deleteWindows(i, service);\n      } else if (b === 0x89) {\n        i = this.displayWindows(i, service);\n      } else if (b === 0x8a) {\n        i = this.hideWindows(i, service);\n      } else if (b === 0x8b) {\n        i = this.toggleWindows(i, service);\n      } else if (b === 0x97) {\n        i = this.setWindowAttributes(i, service);\n      } else if (b === 0x90) {\n        i = this.setPenAttributes(i, service);\n      } else if (b === 0x91) {\n        i = this.setPenColor(i, service);\n      } else if (b === 0x92) {\n        i = this.setPenLocation(i, service);\n      } else if (b === 0x8f) {\n        service = this.reset(i, service);\n      } else if (b === 0x08) {\n        // BS: Backspace\n        service.currentWindow.backspace();\n      } else if (b === 0x0c) {\n        // FF: Form feed\n        service.currentWindow.clearText();\n      } else if (b === 0x0d) {\n        // CR: Carriage return\n        service.currentWindow.pendingNewLine = true;\n      } else if (b === 0x0e) {\n        // HCR: Horizontal carriage return\n        service.currentWindow.clearText();\n      } else if (b === 0x8d) {\n        // DLY: Delay, nothing to do\n        i++;\n      } else ;\n    }\n  };\n  /**\n   * Execute an extended command\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.extendedCommands = function (i, service) {\n    var packetData = this.current708Packet.data;\n    var b = packetData[++i];\n\n    if (within708TextBlock(b)) {\n      i = this.handleText(i, service, {\n        isExtended: true\n      });\n    }\n\n    return i;\n  };\n  /**\n   * Get PTS value of a given byte index\n   *\n   * @param  {Integer} byteIndex  Index of the byte\n   * @return {Integer}            PTS\n   */\n\n\n  Cea708Stream.prototype.getPts = function (byteIndex) {\n    // There's 1 pts value per 2 bytes\n    return this.current708Packet.ptsVals[Math.floor(byteIndex / 2)];\n  };\n  /**\n   * Initializes a service\n   *\n   * @param  {Integer} serviceNum Service number\n   * @return {Service}            Initialized service object\n   */\n\n\n  Cea708Stream.prototype.initService = function (serviceNum, i) {\n    var serviceName = 'SERVICE' + serviceNum;\n    var self = this;\n    var serviceName;\n    var encoding;\n\n    if (serviceName in this.serviceEncodings) {\n      encoding = this.serviceEncodings[serviceName];\n    }\n\n    this.services[serviceNum] = new Cea708Service(serviceNum, encoding, self);\n    this.services[serviceNum].init(this.getPts(i), function (pts) {\n      self.flushDisplayed(pts, self.services[serviceNum]);\n    });\n    return this.services[serviceNum];\n  };\n  /**\n   * Execute text writing to current window\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.handleText = function (i, service, options) {\n    var isExtended = options && options.isExtended;\n    var isMultiByte = options && options.isMultiByte;\n    var packetData = this.current708Packet.data;\n    var extended = isExtended ? 0x1000 : 0x0000;\n    var currentByte = packetData[i];\n    var nextByte = packetData[i + 1];\n    var win = service.currentWindow;\n    var char;\n    var charCodeArray; // Use the TextDecoder if one was created for this service\n\n    if (service.textDecoder_ && !isExtended) {\n      if (isMultiByte) {\n        charCodeArray = [currentByte, nextByte];\n        i++;\n      } else {\n        charCodeArray = [currentByte];\n      }\n\n      char = service.textDecoder_.decode(new Uint8Array(charCodeArray));\n    } else {\n      char = get708CharFromCode(extended | currentByte);\n    }\n\n    if (win.pendingNewLine && !win.isEmpty()) {\n      win.newLine(this.getPts(i));\n    }\n\n    win.pendingNewLine = false;\n    win.addText(char);\n    return i;\n  };\n  /**\n   * Handle decoding of multibyte character\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.multiByteCharacter = function (i, service) {\n    var packetData = this.current708Packet.data;\n    var firstByte = packetData[i + 1];\n    var secondByte = packetData[i + 2];\n\n    if (within708TextBlock(firstByte) && within708TextBlock(secondByte)) {\n      i = this.handleText(++i, service, {\n        isMultiByte: true\n      });\n    }\n\n    return i;\n  };\n  /**\n   * Parse and execute the CW# command.\n   *\n   * Set the current window.\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.setCurrentWindow = function (i, service) {\n    var packetData = this.current708Packet.data;\n    var b = packetData[i];\n    var windowNum = b & 0x07;\n    service.setCurrentWindow(windowNum);\n    return i;\n  };\n  /**\n   * Parse and execute the DF# command.\n   *\n   * Define a window and set it as the current window.\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.defineWindow = function (i, service) {\n    var packetData = this.current708Packet.data;\n    var b = packetData[i];\n    var windowNum = b & 0x07;\n    service.setCurrentWindow(windowNum);\n    var win = service.currentWindow;\n    b = packetData[++i];\n    win.visible = (b & 0x20) >> 5; // v\n\n    win.rowLock = (b & 0x10) >> 4; // rl\n\n    win.columnLock = (b & 0x08) >> 3; // cl\n\n    win.priority = b & 0x07; // p\n\n    b = packetData[++i];\n    win.relativePositioning = (b & 0x80) >> 7; // rp\n\n    win.anchorVertical = b & 0x7f; // av\n\n    b = packetData[++i];\n    win.anchorHorizontal = b; // ah\n\n    b = packetData[++i];\n    win.anchorPoint = (b & 0xf0) >> 4; // ap\n\n    win.rowCount = b & 0x0f; // rc\n\n    b = packetData[++i];\n    win.columnCount = b & 0x3f; // cc\n\n    b = packetData[++i];\n    win.windowStyle = (b & 0x38) >> 3; // ws\n\n    win.penStyle = b & 0x07; // ps\n    // The spec says there are (rowCount+1) \"virtual rows\"\n\n    win.virtualRowCount = win.rowCount + 1;\n    return i;\n  };\n  /**\n   * Parse and execute the SWA command.\n   *\n   * Set attributes of the current window.\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.setWindowAttributes = function (i, service) {\n    var packetData = this.current708Packet.data;\n    var b = packetData[i];\n    var winAttr = service.currentWindow.winAttr;\n    b = packetData[++i];\n    winAttr.fillOpacity = (b & 0xc0) >> 6; // fo\n\n    winAttr.fillRed = (b & 0x30) >> 4; // fr\n\n    winAttr.fillGreen = (b & 0x0c) >> 2; // fg\n\n    winAttr.fillBlue = b & 0x03; // fb\n\n    b = packetData[++i];\n    winAttr.borderType = (b & 0xc0) >> 6; // bt\n\n    winAttr.borderRed = (b & 0x30) >> 4; // br\n\n    winAttr.borderGreen = (b & 0x0c) >> 2; // bg\n\n    winAttr.borderBlue = b & 0x03; // bb\n\n    b = packetData[++i];\n    winAttr.borderType += (b & 0x80) >> 5; // bt\n\n    winAttr.wordWrap = (b & 0x40) >> 6; // ww\n\n    winAttr.printDirection = (b & 0x30) >> 4; // pd\n\n    winAttr.scrollDirection = (b & 0x0c) >> 2; // sd\n\n    winAttr.justify = b & 0x03; // j\n\n    b = packetData[++i];\n    winAttr.effectSpeed = (b & 0xf0) >> 4; // es\n\n    winAttr.effectDirection = (b & 0x0c) >> 2; // ed\n\n    winAttr.displayEffect = b & 0x03; // de\n\n    return i;\n  };\n  /**\n   * Gather text from all displayed windows and push a caption to output.\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   */\n\n\n  Cea708Stream.prototype.flushDisplayed = function (pts, service) {\n    var displayedText = []; // TODO: Positioning not supported, displaying multiple windows will not necessarily\n    // display text in the correct order, but sample files so far have not shown any issue.\n\n    for (var winId = 0; winId < 8; winId++) {\n      if (service.windows[winId].visible && !service.windows[winId].isEmpty()) {\n        displayedText.push(service.windows[winId].getText());\n      }\n    }\n\n    service.endPts = pts;\n    service.text = displayedText.join('\\n\\n');\n    this.pushCaption(service);\n    service.startPts = pts;\n  };\n  /**\n   * Push a caption to output if the caption contains text.\n   *\n   * @param  {Service} service  The service object to be affected\n   */\n\n\n  Cea708Stream.prototype.pushCaption = function (service) {\n    if (service.text !== '') {\n      this.trigger('data', {\n        startPts: service.startPts,\n        endPts: service.endPts,\n        text: service.text,\n        stream: 'cc708_' + service.serviceNum\n      });\n      service.text = '';\n      service.startPts = service.endPts;\n    }\n  };\n  /**\n   * Parse and execute the DSW command.\n   *\n   * Set visible property of windows based on the parsed bitmask.\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.displayWindows = function (i, service) {\n    var packetData = this.current708Packet.data;\n    var b = packetData[++i];\n    var pts = this.getPts(i);\n    this.flushDisplayed(pts, service);\n\n    for (var winId = 0; winId < 8; winId++) {\n      if (b & 0x01 << winId) {\n        service.windows[winId].visible = 1;\n      }\n    }\n\n    return i;\n  };\n  /**\n   * Parse and execute the HDW command.\n   *\n   * Set visible property of windows based on the parsed bitmask.\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.hideWindows = function (i, service) {\n    var packetData = this.current708Packet.data;\n    var b = packetData[++i];\n    var pts = this.getPts(i);\n    this.flushDisplayed(pts, service);\n\n    for (var winId = 0; winId < 8; winId++) {\n      if (b & 0x01 << winId) {\n        service.windows[winId].visible = 0;\n      }\n    }\n\n    return i;\n  };\n  /**\n   * Parse and execute the TGW command.\n   *\n   * Set visible property of windows based on the parsed bitmask.\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.toggleWindows = function (i, service) {\n    var packetData = this.current708Packet.data;\n    var b = packetData[++i];\n    var pts = this.getPts(i);\n    this.flushDisplayed(pts, service);\n\n    for (var winId = 0; winId < 8; winId++) {\n      if (b & 0x01 << winId) {\n        service.windows[winId].visible ^= 1;\n      }\n    }\n\n    return i;\n  };\n  /**\n   * Parse and execute the CLW command.\n   *\n   * Clear text of windows based on the parsed bitmask.\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.clearWindows = function (i, service) {\n    var packetData = this.current708Packet.data;\n    var b = packetData[++i];\n    var pts = this.getPts(i);\n    this.flushDisplayed(pts, service);\n\n    for (var winId = 0; winId < 8; winId++) {\n      if (b & 0x01 << winId) {\n        service.windows[winId].clearText();\n      }\n    }\n\n    return i;\n  };\n  /**\n   * Parse and execute the DLW command.\n   *\n   * Re-initialize windows based on the parsed bitmask.\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.deleteWindows = function (i, service) {\n    var packetData = this.current708Packet.data;\n    var b = packetData[++i];\n    var pts = this.getPts(i);\n    this.flushDisplayed(pts, service);\n\n    for (var winId = 0; winId < 8; winId++) {\n      if (b & 0x01 << winId) {\n        service.windows[winId].reset();\n      }\n    }\n\n    return i;\n  };\n  /**\n   * Parse and execute the SPA command.\n   *\n   * Set pen attributes of the current window.\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.setPenAttributes = function (i, service) {\n    var packetData = this.current708Packet.data;\n    var b = packetData[i];\n    var penAttr = service.currentWindow.penAttr;\n    b = packetData[++i];\n    penAttr.textTag = (b & 0xf0) >> 4; // tt\n\n    penAttr.offset = (b & 0x0c) >> 2; // o\n\n    penAttr.penSize = b & 0x03; // s\n\n    b = packetData[++i];\n    penAttr.italics = (b & 0x80) >> 7; // i\n\n    penAttr.underline = (b & 0x40) >> 6; // u\n\n    penAttr.edgeType = (b & 0x38) >> 3; // et\n\n    penAttr.fontStyle = b & 0x07; // fs\n\n    return i;\n  };\n  /**\n   * Parse and execute the SPC command.\n   *\n   * Set pen color of the current window.\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.setPenColor = function (i, service) {\n    var packetData = this.current708Packet.data;\n    var b = packetData[i];\n    var penColor = service.currentWindow.penColor;\n    b = packetData[++i];\n    penColor.fgOpacity = (b & 0xc0) >> 6; // fo\n\n    penColor.fgRed = (b & 0x30) >> 4; // fr\n\n    penColor.fgGreen = (b & 0x0c) >> 2; // fg\n\n    penColor.fgBlue = b & 0x03; // fb\n\n    b = packetData[++i];\n    penColor.bgOpacity = (b & 0xc0) >> 6; // bo\n\n    penColor.bgRed = (b & 0x30) >> 4; // br\n\n    penColor.bgGreen = (b & 0x0c) >> 2; // bg\n\n    penColor.bgBlue = b & 0x03; // bb\n\n    b = packetData[++i];\n    penColor.edgeRed = (b & 0x30) >> 4; // er\n\n    penColor.edgeGreen = (b & 0x0c) >> 2; // eg\n\n    penColor.edgeBlue = b & 0x03; // eb\n\n    return i;\n  };\n  /**\n   * Parse and execute the SPL command.\n   *\n   * Set pen location of the current window.\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.setPenLocation = function (i, service) {\n    var packetData = this.current708Packet.data;\n    var b = packetData[i];\n    var penLoc = service.currentWindow.penLoc; // Positioning isn't really supported at the moment, so this essentially just inserts a linebreak\n\n    service.currentWindow.pendingNewLine = true;\n    b = packetData[++i];\n    penLoc.row = b & 0x0f; // r\n\n    b = packetData[++i];\n    penLoc.column = b & 0x3f; // c\n\n    return i;\n  };\n  /**\n   * Execute the RST command.\n   *\n   * Reset service to a clean slate. Re-initialize.\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Service}          Re-initialized service\n   */\n\n\n  Cea708Stream.prototype.reset = function (i, service) {\n    var pts = this.getPts(i);\n    this.flushDisplayed(pts, service);\n    return this.initService(service.serviceNum, i);\n  }; // This hash maps non-ASCII, special, and extended character codes to their\n  // proper Unicode equivalent. The first keys that are only a single byte\n  // are the non-standard ASCII characters, which simply map the CEA608 byte\n  // to the standard ASCII/Unicode. The two-byte keys that follow are the CEA608\n  // character codes, but have their MSB bitmasked with 0x03 so that a lookup\n  // can be performed regardless of the field and data channel on which the\n  // character code was received.\n\n\n  var CHARACTER_TRANSLATION = {\n    0x2a: 0xe1,\n    // \n    0x5c: 0xe9,\n    // \n    0x5e: 0xed,\n    // \n    0x5f: 0xf3,\n    // \n    0x60: 0xfa,\n    // \n    0x7b: 0xe7,\n    // \n    0x7c: 0xf7,\n    // \n    0x7d: 0xd1,\n    // \n    0x7e: 0xf1,\n    // \n    0x7f: 0x2588,\n    // \n    0x0130: 0xae,\n    // \n    0x0131: 0xb0,\n    // \n    0x0132: 0xbd,\n    // \n    0x0133: 0xbf,\n    // \n    0x0134: 0x2122,\n    // \n    0x0135: 0xa2,\n    // \n    0x0136: 0xa3,\n    // \n    0x0137: 0x266a,\n    // \n    0x0138: 0xe0,\n    // \n    0x0139: 0xa0,\n    //\n    0x013a: 0xe8,\n    // \n    0x013b: 0xe2,\n    // \n    0x013c: 0xea,\n    // \n    0x013d: 0xee,\n    // \n    0x013e: 0xf4,\n    // \n    0x013f: 0xfb,\n    // \n    0x0220: 0xc1,\n    // \n    0x0221: 0xc9,\n    // \n    0x0222: 0xd3,\n    // \n    0x0223: 0xda,\n    // \n    0x0224: 0xdc,\n    // \n    0x0225: 0xfc,\n    // \n    0x0226: 0x2018,\n    // \n    0x0227: 0xa1,\n    // \n    0x0228: 0x2a,\n    // *\n    0x0229: 0x27,\n    // '\n    0x022a: 0x2014,\n    // \n    0x022b: 0xa9,\n    // \n    0x022c: 0x2120,\n    // \n    0x022d: 0x2022,\n    // \n    0x022e: 0x201c,\n    // \n    0x022f: 0x201d,\n    // \n    0x0230: 0xc0,\n    // \n    0x0231: 0xc2,\n    // \n    0x0232: 0xc7,\n    // \n    0x0233: 0xc8,\n    // \n    0x0234: 0xca,\n    // \n    0x0235: 0xcb,\n    // \n    0x0236: 0xeb,\n    // \n    0x0237: 0xce,\n    // \n    0x0238: 0xcf,\n    // \n    0x0239: 0xef,\n    // \n    0x023a: 0xd4,\n    // \n    0x023b: 0xd9,\n    // \n    0x023c: 0xf9,\n    // \n    0x023d: 0xdb,\n    // \n    0x023e: 0xab,\n    // \n    0x023f: 0xbb,\n    // \n    0x0320: 0xc3,\n    // \n    0x0321: 0xe3,\n    // \n    0x0322: 0xcd,\n    // \n    0x0323: 0xcc,\n    // \n    0x0324: 0xec,\n    // \n    0x0325: 0xd2,\n    // \n    0x0326: 0xf2,\n    // \n    0x0327: 0xd5,\n    // \n    0x0328: 0xf5,\n    // \n    0x0329: 0x7b,\n    // {\n    0x032a: 0x7d,\n    // }\n    0x032b: 0x5c,\n    // \\\n    0x032c: 0x5e,\n    // ^\n    0x032d: 0x5f,\n    // _\n    0x032e: 0x7c,\n    // |\n    0x032f: 0x7e,\n    // ~\n    0x0330: 0xc4,\n    // \n    0x0331: 0xe4,\n    // \n    0x0332: 0xd6,\n    // \n    0x0333: 0xf6,\n    // \n    0x0334: 0xdf,\n    // \n    0x0335: 0xa5,\n    // \n    0x0336: 0xa4,\n    // \n    0x0337: 0x2502,\n    // \n    0x0338: 0xc5,\n    // \n    0x0339: 0xe5,\n    // \n    0x033a: 0xd8,\n    // \n    0x033b: 0xf8,\n    // \n    0x033c: 0x250c,\n    // \n    0x033d: 0x2510,\n    // \n    0x033e: 0x2514,\n    // \n    0x033f: 0x2518 // \n\n  };\n\n  var getCharFromCode = function getCharFromCode(code) {\n    if (code === null) {\n      return '';\n    }\n\n    code = CHARACTER_TRANSLATION[code] || code;\n    return String.fromCharCode(code);\n  }; // the index of the last row in a CEA-608 display buffer\n\n\n  var BOTTOM_ROW = 14; // This array is used for mapping PACs -> row #, since there's no way of\n  // getting it through bit logic.\n\n  var ROWS = [0x1100, 0x1120, 0x1200, 0x1220, 0x1500, 0x1520, 0x1600, 0x1620, 0x1700, 0x1720, 0x1000, 0x1300, 0x1320, 0x1400, 0x1420]; // CEA-608 captions are rendered onto a 34x15 matrix of character\n  // cells. The \"bottom\" row is the last element in the outer array.\n\n  var createDisplayBuffer = function createDisplayBuffer() {\n    var result = [],\n        i = BOTTOM_ROW + 1;\n\n    while (i--) {\n      result.push('');\n    }\n\n    return result;\n  };\n\n  var Cea608Stream = function Cea608Stream(field, dataChannel) {\n    Cea608Stream.prototype.init.call(this);\n    this.field_ = field || 0;\n    this.dataChannel_ = dataChannel || 0;\n    this.name_ = 'CC' + ((this.field_ << 1 | this.dataChannel_) + 1);\n    this.setConstants();\n    this.reset();\n\n    this.push = function (packet) {\n      var data, swap, char0, char1, text; // remove the parity bits\n\n      data = packet.ccData & 0x7f7f; // ignore duplicate control codes; the spec demands they're sent twice\n\n      if (data === this.lastControlCode_) {\n        this.lastControlCode_ = null;\n        return;\n      } // Store control codes\n\n\n      if ((data & 0xf000) === 0x1000) {\n        this.lastControlCode_ = data;\n      } else if (data !== this.PADDING_) {\n        this.lastControlCode_ = null;\n      }\n\n      char0 = data >>> 8;\n      char1 = data & 0xff;\n\n      if (data === this.PADDING_) {\n        return;\n      } else if (data === this.RESUME_CAPTION_LOADING_) {\n        this.mode_ = 'popOn';\n      } else if (data === this.END_OF_CAPTION_) {\n        // If an EOC is received while in paint-on mode, the displayed caption\n        // text should be swapped to non-displayed memory as if it was a pop-on\n        // caption. Because of that, we should explicitly switch back to pop-on\n        // mode\n        this.mode_ = 'popOn';\n        this.clearFormatting(packet.pts); // if a caption was being displayed, it's gone now\n\n        this.flushDisplayed(packet.pts); // flip memory\n\n        swap = this.displayed_;\n        this.displayed_ = this.nonDisplayed_;\n        this.nonDisplayed_ = swap; // start measuring the time to display the caption\n\n        this.startPts_ = packet.pts;\n      } else if (data === this.ROLL_UP_2_ROWS_) {\n        this.rollUpRows_ = 2;\n        this.setRollUp(packet.pts);\n      } else if (data === this.ROLL_UP_3_ROWS_) {\n        this.rollUpRows_ = 3;\n        this.setRollUp(packet.pts);\n      } else if (data === this.ROLL_UP_4_ROWS_) {\n        this.rollUpRows_ = 4;\n        this.setRollUp(packet.pts);\n      } else if (data === this.CARRIAGE_RETURN_) {\n        this.clearFormatting(packet.pts);\n        this.flushDisplayed(packet.pts);\n        this.shiftRowsUp_();\n        this.startPts_ = packet.pts;\n      } else if (data === this.BACKSPACE_) {\n        if (this.mode_ === 'popOn') {\n          this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1);\n        } else {\n          this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1);\n        }\n      } else if (data === this.ERASE_DISPLAYED_MEMORY_) {\n        this.flushDisplayed(packet.pts);\n        this.displayed_ = createDisplayBuffer();\n      } else if (data === this.ERASE_NON_DISPLAYED_MEMORY_) {\n        this.nonDisplayed_ = createDisplayBuffer();\n      } else if (data === this.RESUME_DIRECT_CAPTIONING_) {\n        if (this.mode_ !== 'paintOn') {\n          // NOTE: This should be removed when proper caption positioning is\n          // implemented\n          this.flushDisplayed(packet.pts);\n          this.displayed_ = createDisplayBuffer();\n        }\n\n        this.mode_ = 'paintOn';\n        this.startPts_ = packet.pts; // Append special characters to caption text\n      } else if (this.isSpecialCharacter(char0, char1)) {\n        // Bitmask char0 so that we can apply character transformations\n        // regardless of field and data channel.\n        // Then byte-shift to the left and OR with char1 so we can pass the\n        // entire character code to `getCharFromCode`.\n        char0 = (char0 & 0x03) << 8;\n        text = getCharFromCode(char0 | char1);\n        this[this.mode_](packet.pts, text);\n        this.column_++; // Append extended characters to caption text\n      } else if (this.isExtCharacter(char0, char1)) {\n        // Extended characters always follow their \"non-extended\" equivalents.\n        // IE if a \"\" is desired, you'll always receive \"e\"; non-compliant\n        // decoders are supposed to drop the \"\", while compliant decoders\n        // backspace the \"e\" and insert \"\".\n        // Delete the previous character\n        if (this.mode_ === 'popOn') {\n          this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1);\n        } else {\n          this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1);\n        } // Bitmask char0 so that we can apply character transformations\n        // regardless of field and data channel.\n        // Then byte-shift to the left and OR with char1 so we can pass the\n        // entire character code to `getCharFromCode`.\n\n\n        char0 = (char0 & 0x03) << 8;\n        text = getCharFromCode(char0 | char1);\n        this[this.mode_](packet.pts, text);\n        this.column_++; // Process mid-row codes\n      } else if (this.isMidRowCode(char0, char1)) {\n        // Attributes are not additive, so clear all formatting\n        this.clearFormatting(packet.pts); // According to the standard, mid-row codes\n        // should be replaced with spaces, so add one now\n\n        this[this.mode_](packet.pts, ' ');\n        this.column_++;\n\n        if ((char1 & 0xe) === 0xe) {\n          this.addFormatting(packet.pts, ['i']);\n        }\n\n        if ((char1 & 0x1) === 0x1) {\n          this.addFormatting(packet.pts, ['u']);\n        } // Detect offset control codes and adjust cursor\n\n      } else if (this.isOffsetControlCode(char0, char1)) {\n        // Cursor position is set by indent PAC (see below) in 4-column\n        // increments, with an additional offset code of 1-3 to reach any\n        // of the 32 columns specified by CEA-608. So all we need to do\n        // here is increment the column cursor by the given offset.\n        this.column_ += char1 & 0x03; // Detect PACs (Preamble Address Codes)\n      } else if (this.isPAC(char0, char1)) {\n        // There's no logic for PAC -> row mapping, so we have to just\n        // find the row code in an array and use its index :(\n        var row = ROWS.indexOf(data & 0x1f20); // Configure the caption window if we're in roll-up mode\n\n        if (this.mode_ === 'rollUp') {\n          // This implies that the base row is incorrectly set.\n          // As per the recommendation in CEA-608(Base Row Implementation), defer to the number\n          // of roll-up rows set.\n          if (row - this.rollUpRows_ + 1 < 0) {\n            row = this.rollUpRows_ - 1;\n          }\n\n          this.setRollUp(packet.pts, row);\n        }\n\n        if (row !== this.row_) {\n          // formatting is only persistent for current row\n          this.clearFormatting(packet.pts);\n          this.row_ = row;\n        } // All PACs can apply underline, so detect and apply\n        // (All odd-numbered second bytes set underline)\n\n\n        if (char1 & 0x1 && this.formatting_.indexOf('u') === -1) {\n          this.addFormatting(packet.pts, ['u']);\n        }\n\n        if ((data & 0x10) === 0x10) {\n          // We've got an indent level code. Each successive even number\n          // increments the column cursor by 4, so we can get the desired\n          // column position by bit-shifting to the right (to get n/2)\n          // and multiplying by 4.\n          this.column_ = ((data & 0xe) >> 1) * 4;\n        }\n\n        if (this.isColorPAC(char1)) {\n          // it's a color code, though we only support white, which\n          // can be either normal or italicized. white italics can be\n          // either 0x4e or 0x6e depending on the row, so we just\n          // bitwise-and with 0xe to see if italics should be turned on\n          if ((char1 & 0xe) === 0xe) {\n            this.addFormatting(packet.pts, ['i']);\n          }\n        } // We have a normal character in char0, and possibly one in char1\n\n      } else if (this.isNormalChar(char0)) {\n        if (char1 === 0x00) {\n          char1 = null;\n        }\n\n        text = getCharFromCode(char0);\n        text += getCharFromCode(char1);\n        this[this.mode_](packet.pts, text);\n        this.column_ += text.length;\n      } // finish data processing\n\n    };\n  };\n\n  Cea608Stream.prototype = new stream(); // Trigger a cue point that captures the current state of the\n  // display buffer\n\n  Cea608Stream.prototype.flushDisplayed = function (pts) {\n    var content = this.displayed_ // remove spaces from the start and end of the string\n    .map(function (row, index) {\n      try {\n        return row.trim();\n      } catch (e) {\n        // Ordinarily, this shouldn't happen. However, caption\n        // parsing errors should not throw exceptions and\n        // break playback.\n        this.trigger('log', {\n          level: 'warn',\n          message: 'Skipping a malformed 608 caption at index ' + index + '.'\n        });\n        return '';\n      }\n    }, this) // combine all text rows to display in one cue\n    .join('\\n') // and remove blank rows from the start and end, but not the middle\n    .replace(/^\\n+|\\n+$/g, '');\n\n    if (content.length) {\n      this.trigger('data', {\n        startPts: this.startPts_,\n        endPts: pts,\n        text: content,\n        stream: this.name_\n      });\n    }\n  };\n  /**\n   * Zero out the data, used for startup and on seek\n   */\n\n\n  Cea608Stream.prototype.reset = function () {\n    this.mode_ = 'popOn'; // When in roll-up mode, the index of the last row that will\n    // actually display captions. If a caption is shifted to a row\n    // with a lower index than this, it is cleared from the display\n    // buffer\n\n    this.topRow_ = 0;\n    this.startPts_ = 0;\n    this.displayed_ = createDisplayBuffer();\n    this.nonDisplayed_ = createDisplayBuffer();\n    this.lastControlCode_ = null; // Track row and column for proper line-breaking and spacing\n\n    this.column_ = 0;\n    this.row_ = BOTTOM_ROW;\n    this.rollUpRows_ = 2; // This variable holds currently-applied formatting\n\n    this.formatting_ = [];\n  };\n  /**\n   * Sets up control code and related constants for this instance\n   */\n\n\n  Cea608Stream.prototype.setConstants = function () {\n    // The following attributes have these uses:\n    // ext_ :    char0 for mid-row codes, and the base for extended\n    //           chars (ext_+0, ext_+1, and ext_+2 are char0s for\n    //           extended codes)\n    // control_: char0 for control codes, except byte-shifted to the\n    //           left so that we can do this.control_ | CONTROL_CODE\n    // offset_:  char0 for tab offset codes\n    //\n    // It's also worth noting that control codes, and _only_ control codes,\n    // differ between field 1 and field2. Field 2 control codes are always\n    // their field 1 value plus 1. That's why there's the \"| field\" on the\n    // control value.\n    if (this.dataChannel_ === 0) {\n      this.BASE_ = 0x10;\n      this.EXT_ = 0x11;\n      this.CONTROL_ = (0x14 | this.field_) << 8;\n      this.OFFSET_ = 0x17;\n    } else if (this.dataChannel_ === 1) {\n      this.BASE_ = 0x18;\n      this.EXT_ = 0x19;\n      this.CONTROL_ = (0x1c | this.field_) << 8;\n      this.OFFSET_ = 0x1f;\n    } // Constants for the LSByte command codes recognized by Cea608Stream. This\n    // list is not exhaustive. For a more comprehensive listing and semantics see\n    // http://www.gpo.gov/fdsys/pkg/CFR-2010-title47-vol1/pdf/CFR-2010-title47-vol1-sec15-119.pdf\n    // Padding\n\n\n    this.PADDING_ = 0x0000; // Pop-on Mode\n\n    this.RESUME_CAPTION_LOADING_ = this.CONTROL_ | 0x20;\n    this.END_OF_CAPTION_ = this.CONTROL_ | 0x2f; // Roll-up Mode\n\n    this.ROLL_UP_2_ROWS_ = this.CONTROL_ | 0x25;\n    this.ROLL_UP_3_ROWS_ = this.CONTROL_ | 0x26;\n    this.ROLL_UP_4_ROWS_ = this.CONTROL_ | 0x27;\n    this.CARRIAGE_RETURN_ = this.CONTROL_ | 0x2d; // paint-on mode\n\n    this.RESUME_DIRECT_CAPTIONING_ = this.CONTROL_ | 0x29; // Erasure\n\n    this.BACKSPACE_ = this.CONTROL_ | 0x21;\n    this.ERASE_DISPLAYED_MEMORY_ = this.CONTROL_ | 0x2c;\n    this.ERASE_NON_DISPLAYED_MEMORY_ = this.CONTROL_ | 0x2e;\n  };\n  /**\n   * Detects if the 2-byte packet data is a special character\n   *\n   * Special characters have a second byte in the range 0x30 to 0x3f,\n   * with the first byte being 0x11 (for data channel 1) or 0x19 (for\n   * data channel 2).\n   *\n   * @param  {Integer} char0 The first byte\n   * @param  {Integer} char1 The second byte\n   * @return {Boolean}       Whether the 2 bytes are an special character\n   */\n\n\n  Cea608Stream.prototype.isSpecialCharacter = function (char0, char1) {\n    return char0 === this.EXT_ && char1 >= 0x30 && char1 <= 0x3f;\n  };\n  /**\n   * Detects if the 2-byte packet data is an extended character\n   *\n   * Extended characters have a second byte in the range 0x20 to 0x3f,\n   * with the first byte being 0x12 or 0x13 (for data channel 1) or\n   * 0x1a or 0x1b (for data channel 2).\n   *\n   * @param  {Integer} char0 The first byte\n   * @param  {Integer} char1 The second byte\n   * @return {Boolean}       Whether the 2 bytes are an extended character\n   */\n\n\n  Cea608Stream.prototype.isExtCharacter = function (char0, char1) {\n    return (char0 === this.EXT_ + 1 || char0 === this.EXT_ + 2) && char1 >= 0x20 && char1 <= 0x3f;\n  };\n  /**\n   * Detects if the 2-byte packet is a mid-row code\n   *\n   * Mid-row codes have a second byte in the range 0x20 to 0x2f, with\n   * the first byte being 0x11 (for data channel 1) or 0x19 (for data\n   * channel 2).\n   *\n   * @param  {Integer} char0 The first byte\n   * @param  {Integer} char1 The second byte\n   * @return {Boolean}       Whether the 2 bytes are a mid-row code\n   */\n\n\n  Cea608Stream.prototype.isMidRowCode = function (char0, char1) {\n    return char0 === this.EXT_ && char1 >= 0x20 && char1 <= 0x2f;\n  };\n  /**\n   * Detects if the 2-byte packet is an offset control code\n   *\n   * Offset control codes have a second byte in the range 0x21 to 0x23,\n   * with the first byte being 0x17 (for data channel 1) or 0x1f (for\n   * data channel 2).\n   *\n   * @param  {Integer} char0 The first byte\n   * @param  {Integer} char1 The second byte\n   * @return {Boolean}       Whether the 2 bytes are an offset control code\n   */\n\n\n  Cea608Stream.prototype.isOffsetControlCode = function (char0, char1) {\n    return char0 === this.OFFSET_ && char1 >= 0x21 && char1 <= 0x23;\n  };\n  /**\n   * Detects if the 2-byte packet is a Preamble Address Code\n   *\n   * PACs have a first byte in the range 0x10 to 0x17 (for data channel 1)\n   * or 0x18 to 0x1f (for data channel 2), with the second byte in the\n   * range 0x40 to 0x7f.\n   *\n   * @param  {Integer} char0 The first byte\n   * @param  {Integer} char1 The second byte\n   * @return {Boolean}       Whether the 2 bytes are a PAC\n   */\n\n\n  Cea608Stream.prototype.isPAC = function (char0, char1) {\n    return char0 >= this.BASE_ && char0 < this.BASE_ + 8 && char1 >= 0x40 && char1 <= 0x7f;\n  };\n  /**\n   * Detects if a packet's second byte is in the range of a PAC color code\n   *\n   * PAC color codes have the second byte be in the range 0x40 to 0x4f, or\n   * 0x60 to 0x6f.\n   *\n   * @param  {Integer} char1 The second byte\n   * @return {Boolean}       Whether the byte is a color PAC\n   */\n\n\n  Cea608Stream.prototype.isColorPAC = function (char1) {\n    return char1 >= 0x40 && char1 <= 0x4f || char1 >= 0x60 && char1 <= 0x7f;\n  };\n  /**\n   * Detects if a single byte is in the range of a normal character\n   *\n   * Normal text bytes are in the range 0x20 to 0x7f.\n   *\n   * @param  {Integer} char  The byte\n   * @return {Boolean}       Whether the byte is a normal character\n   */\n\n\n  Cea608Stream.prototype.isNormalChar = function (char) {\n    return char >= 0x20 && char <= 0x7f;\n  };\n  /**\n   * Configures roll-up\n   *\n   * @param  {Integer} pts         Current PTS\n   * @param  {Integer} newBaseRow  Used by PACs to slide the current window to\n   *                               a new position\n   */\n\n\n  Cea608Stream.prototype.setRollUp = function (pts, newBaseRow) {\n    // Reset the base row to the bottom row when switching modes\n    if (this.mode_ !== 'rollUp') {\n      this.row_ = BOTTOM_ROW;\n      this.mode_ = 'rollUp'; // Spec says to wipe memories when switching to roll-up\n\n      this.flushDisplayed(pts);\n      this.nonDisplayed_ = createDisplayBuffer();\n      this.displayed_ = createDisplayBuffer();\n    }\n\n    if (newBaseRow !== undefined && newBaseRow !== this.row_) {\n      // move currently displayed captions (up or down) to the new base row\n      for (var i = 0; i < this.rollUpRows_; i++) {\n        this.displayed_[newBaseRow - i] = this.displayed_[this.row_ - i];\n        this.displayed_[this.row_ - i] = '';\n      }\n    }\n\n    if (newBaseRow === undefined) {\n      newBaseRow = this.row_;\n    }\n\n    this.topRow_ = newBaseRow - this.rollUpRows_ + 1;\n  }; // Adds the opening HTML tag for the passed character to the caption text,\n  // and keeps track of it for later closing\n\n\n  Cea608Stream.prototype.addFormatting = function (pts, format) {\n    this.formatting_ = this.formatting_.concat(format);\n    var text = format.reduce(function (text, format) {\n      return text + '<' + format + '>';\n    }, '');\n    this[this.mode_](pts, text);\n  }; // Adds HTML closing tags for current formatting to caption text and\n  // clears remembered formatting\n\n\n  Cea608Stream.prototype.clearFormatting = function (pts) {\n    if (!this.formatting_.length) {\n      return;\n    }\n\n    var text = this.formatting_.reverse().reduce(function (text, format) {\n      return text + '</' + format + '>';\n    }, '');\n    this.formatting_ = [];\n    this[this.mode_](pts, text);\n  }; // Mode Implementations\n\n\n  Cea608Stream.prototype.popOn = function (pts, text) {\n    var baseRow = this.nonDisplayed_[this.row_]; // buffer characters\n\n    baseRow += text;\n    this.nonDisplayed_[this.row_] = baseRow;\n  };\n\n  Cea608Stream.prototype.rollUp = function (pts, text) {\n    var baseRow = this.displayed_[this.row_];\n    baseRow += text;\n    this.displayed_[this.row_] = baseRow;\n  };\n\n  Cea608Stream.prototype.shiftRowsUp_ = function () {\n    var i; // clear out inactive rows\n\n    for (i = 0; i < this.topRow_; i++) {\n      this.displayed_[i] = '';\n    }\n\n    for (i = this.row_ + 1; i < BOTTOM_ROW + 1; i++) {\n      this.displayed_[i] = '';\n    } // shift displayed rows up\n\n\n    for (i = this.topRow_; i < this.row_; i++) {\n      this.displayed_[i] = this.displayed_[i + 1];\n    } // clear out the bottom row\n\n\n    this.displayed_[this.row_] = '';\n  };\n\n  Cea608Stream.prototype.paintOn = function (pts, text) {\n    var baseRow = this.displayed_[this.row_];\n    baseRow += text;\n    this.displayed_[this.row_] = baseRow;\n  }; // exports\n\n\n  var captionStream = {\n    CaptionStream: CaptionStream$1,\n    Cea608Stream: Cea608Stream,\n    Cea708Stream: Cea708Stream\n  };\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n\n  var streamTypes = {\n    H264_STREAM_TYPE: 0x1B,\n    ADTS_STREAM_TYPE: 0x0F,\n    METADATA_STREAM_TYPE: 0x15\n  };\n  var MAX_TS = 8589934592;\n  var RO_THRESH = 4294967296;\n  var TYPE_SHARED = 'shared';\n\n  var handleRollover$1 = function handleRollover(value, reference) {\n    var direction = 1;\n\n    if (value > reference) {\n      // If the current timestamp value is greater than our reference timestamp and we detect a\n      // timestamp rollover, this means the roll over is happening in the opposite direction.\n      // Example scenario: Enter a long stream/video just after a rollover occurred. The reference\n      // point will be set to a small number, e.g. 1. The user then seeks backwards over the\n      // rollover point. In loading this segment, the timestamp values will be very large,\n      // e.g. 2^33 - 1. Since this comes before the data we loaded previously, we want to adjust\n      // the time stamp to be `value - 2^33`.\n      direction = -1;\n    } // Note: A seek forwards or back that is greater than the RO_THRESH (2^32, ~13 hours) will\n    // cause an incorrect adjustment.\n\n\n    while (Math.abs(reference - value) > RO_THRESH) {\n      value += direction * MAX_TS;\n    }\n\n    return value;\n  };\n\n  var TimestampRolloverStream$1 = function TimestampRolloverStream(type) {\n    var lastDTS, referenceDTS;\n    TimestampRolloverStream.prototype.init.call(this); // The \"shared\" type is used in cases where a stream will contain muxed\n    // video and audio. We could use `undefined` here, but having a string\n    // makes debugging a little clearer.\n\n    this.type_ = type || TYPE_SHARED;\n\n    this.push = function (data) {\n      // Any \"shared\" rollover streams will accept _all_ data. Otherwise,\n      // streams will only accept data that matches their type.\n      if (this.type_ !== TYPE_SHARED && data.type !== this.type_) {\n        return;\n      }\n\n      if (referenceDTS === undefined) {\n        referenceDTS = data.dts;\n      }\n\n      data.dts = handleRollover$1(data.dts, referenceDTS);\n      data.pts = handleRollover$1(data.pts, referenceDTS);\n      lastDTS = data.dts;\n      this.trigger('data', data);\n    };\n\n    this.flush = function () {\n      referenceDTS = lastDTS;\n      this.trigger('done');\n    };\n\n    this.endTimeline = function () {\n      this.flush();\n      this.trigger('endedtimeline');\n    };\n\n    this.discontinuity = function () {\n      referenceDTS = void 0;\n      lastDTS = void 0;\n    };\n\n    this.reset = function () {\n      this.discontinuity();\n      this.trigger('reset');\n    };\n  };\n\n  TimestampRolloverStream$1.prototype = new stream();\n  var timestampRolloverStream = {\n    TimestampRolloverStream: TimestampRolloverStream$1,\n    handleRollover: handleRollover$1\n  };\n\n  var percentEncode$1 = function percentEncode(bytes, start, end) {\n    var i,\n        result = '';\n\n    for (i = start; i < end; i++) {\n      result += '%' + ('00' + bytes[i].toString(16)).slice(-2);\n    }\n\n    return result;\n  },\n      // return the string representation of the specified byte range,\n  // interpreted as UTf-8.\n  parseUtf8 = function parseUtf8(bytes, start, end) {\n    return decodeURIComponent(percentEncode$1(bytes, start, end));\n  },\n      // return the string representation of the specified byte range,\n  // interpreted as ISO-8859-1.\n  parseIso88591$1 = function parseIso88591(bytes, start, end) {\n    return unescape(percentEncode$1(bytes, start, end)); // jshint ignore:line\n  },\n      parseSyncSafeInteger$1 = function parseSyncSafeInteger(data) {\n    return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];\n  },\n      tagParsers = {\n    TXXX: function TXXX(tag) {\n      var i;\n\n      if (tag.data[0] !== 3) {\n        // ignore frames with unrecognized character encodings\n        return;\n      }\n\n      for (i = 1; i < tag.data.length; i++) {\n        if (tag.data[i] === 0) {\n          // parse the text fields\n          tag.description = parseUtf8(tag.data, 1, i); // do not include the null terminator in the tag value\n\n          tag.value = parseUtf8(tag.data, i + 1, tag.data.length).replace(/\\0*$/, '');\n          break;\n        }\n      }\n\n      tag.data = tag.value;\n    },\n    WXXX: function WXXX(tag) {\n      var i;\n\n      if (tag.data[0] !== 3) {\n        // ignore frames with unrecognized character encodings\n        return;\n      }\n\n      for (i = 1; i < tag.data.length; i++) {\n        if (tag.data[i] === 0) {\n          // parse the description and URL fields\n          tag.description = parseUtf8(tag.data, 1, i);\n          tag.url = parseUtf8(tag.data, i + 1, tag.data.length);\n          break;\n        }\n      }\n    },\n    PRIV: function PRIV(tag) {\n      var i;\n\n      for (i = 0; i < tag.data.length; i++) {\n        if (tag.data[i] === 0) {\n          // parse the description and URL fields\n          tag.owner = parseIso88591$1(tag.data, 0, i);\n          break;\n        }\n      }\n\n      tag.privateData = tag.data.subarray(i + 1);\n      tag.data = tag.privateData;\n    }\n  },\n      _MetadataStream;\n\n  _MetadataStream = function MetadataStream(options) {\n    var settings = {\n      // the bytes of the program-level descriptor field in MP2T\n      // see ISO/IEC 13818-1:2013 (E), section 2.6 \"Program and\n      // program element descriptors\"\n      descriptor: options && options.descriptor\n    },\n        // the total size in bytes of the ID3 tag being parsed\n    tagSize = 0,\n        // tag data that is not complete enough to be parsed\n    buffer = [],\n        // the total number of bytes currently in the buffer\n    bufferSize = 0,\n        i;\n\n    _MetadataStream.prototype.init.call(this); // calculate the text track in-band metadata track dispatch type\n    // https://html.spec.whatwg.org/multipage/embedded-content.html#steps-to-expose-a-media-resource-specific-text-track\n\n\n    this.dispatchType = streamTypes.METADATA_STREAM_TYPE.toString(16);\n\n    if (settings.descriptor) {\n      for (i = 0; i < settings.descriptor.length; i++) {\n        this.dispatchType += ('00' + settings.descriptor[i].toString(16)).slice(-2);\n      }\n    }\n\n    this.push = function (chunk) {\n      var tag, frameStart, frameSize, frame, i, frameHeader;\n\n      if (chunk.type !== 'timed-metadata') {\n        return;\n      } // if data_alignment_indicator is set in the PES header,\n      // we must have the start of a new ID3 tag. Assume anything\n      // remaining in the buffer was malformed and throw it out\n\n\n      if (chunk.dataAlignmentIndicator) {\n        bufferSize = 0;\n        buffer.length = 0;\n      } // ignore events that don't look like ID3 data\n\n\n      if (buffer.length === 0 && (chunk.data.length < 10 || chunk.data[0] !== 'I'.charCodeAt(0) || chunk.data[1] !== 'D'.charCodeAt(0) || chunk.data[2] !== '3'.charCodeAt(0))) {\n        this.trigger('log', {\n          level: 'warn',\n          message: 'Skipping unrecognized metadata packet'\n        });\n        return;\n      } // add this chunk to the data we've collected so far\n\n\n      buffer.push(chunk);\n      bufferSize += chunk.data.byteLength; // grab the size of the entire frame from the ID3 header\n\n      if (buffer.length === 1) {\n        // the frame size is transmitted as a 28-bit integer in the\n        // last four bytes of the ID3 header.\n        // The most significant bit of each byte is dropped and the\n        // results concatenated to recover the actual value.\n        tagSize = parseSyncSafeInteger$1(chunk.data.subarray(6, 10)); // ID3 reports the tag size excluding the header but it's more\n        // convenient for our comparisons to include it\n\n        tagSize += 10;\n      } // if the entire frame has not arrived, wait for more data\n\n\n      if (bufferSize < tagSize) {\n        return;\n      } // collect the entire frame so it can be parsed\n\n\n      tag = {\n        data: new Uint8Array(tagSize),\n        frames: [],\n        pts: buffer[0].pts,\n        dts: buffer[0].dts\n      };\n\n      for (i = 0; i < tagSize;) {\n        tag.data.set(buffer[0].data.subarray(0, tagSize - i), i);\n        i += buffer[0].data.byteLength;\n        bufferSize -= buffer[0].data.byteLength;\n        buffer.shift();\n      } // find the start of the first frame and the end of the tag\n\n\n      frameStart = 10;\n\n      if (tag.data[5] & 0x40) {\n        // advance the frame start past the extended header\n        frameStart += 4; // header size field\n\n        frameStart += parseSyncSafeInteger$1(tag.data.subarray(10, 14)); // clip any padding off the end\n\n        tagSize -= parseSyncSafeInteger$1(tag.data.subarray(16, 20));\n      } // parse one or more ID3 frames\n      // http://id3.org/id3v2.3.0#ID3v2_frame_overview\n\n\n      do {\n        // determine the number of bytes in this frame\n        frameSize = parseSyncSafeInteger$1(tag.data.subarray(frameStart + 4, frameStart + 8));\n\n        if (frameSize < 1) {\n          this.trigger('log', {\n            level: 'warn',\n            message: 'Malformed ID3 frame encountered. Skipping metadata parsing.'\n          });\n          return;\n        }\n\n        frameHeader = String.fromCharCode(tag.data[frameStart], tag.data[frameStart + 1], tag.data[frameStart + 2], tag.data[frameStart + 3]);\n        frame = {\n          id: frameHeader,\n          data: tag.data.subarray(frameStart + 10, frameStart + frameSize + 10)\n        };\n        frame.key = frame.id;\n\n        if (tagParsers[frame.id]) {\n          tagParsers[frame.id](frame); // handle the special PRIV frame used to indicate the start\n          // time for raw AAC data\n\n          if (frame.owner === 'com.apple.streaming.transportStreamTimestamp') {\n            var d = frame.data,\n                size = (d[3] & 0x01) << 30 | d[4] << 22 | d[5] << 14 | d[6] << 6 | d[7] >>> 2;\n            size *= 4;\n            size += d[7] & 0x03;\n            frame.timeStamp = size; // in raw AAC, all subsequent data will be timestamped based\n            // on the value of this frame\n            // we couldn't have known the appropriate pts and dts before\n            // parsing this ID3 tag so set those values now\n\n            if (tag.pts === undefined && tag.dts === undefined) {\n              tag.pts = frame.timeStamp;\n              tag.dts = frame.timeStamp;\n            }\n\n            this.trigger('timestamp', frame);\n          }\n        }\n\n        tag.frames.push(frame);\n        frameStart += 10; // advance past the frame header\n\n        frameStart += frameSize; // advance past the frame body\n      } while (frameStart < tagSize);\n\n      this.trigger('data', tag);\n    };\n  };\n\n  _MetadataStream.prototype = new stream();\n  var metadataStream = _MetadataStream;\n  var TimestampRolloverStream = timestampRolloverStream.TimestampRolloverStream; // object types\n\n  var _TransportPacketStream, _TransportParseStream, _ElementaryStream; // constants\n\n\n  var MP2T_PACKET_LENGTH$1 = 188,\n      // bytes\n  SYNC_BYTE$1 = 0x47;\n  /**\n   * Splits an incoming stream of binary data into MPEG-2 Transport\n   * Stream packets.\n   */\n\n  _TransportPacketStream = function TransportPacketStream() {\n    var buffer = new Uint8Array(MP2T_PACKET_LENGTH$1),\n        bytesInBuffer = 0;\n\n    _TransportPacketStream.prototype.init.call(this); // Deliver new bytes to the stream.\n\n    /**\n     * Split a stream of data into M2TS packets\n    **/\n\n\n    this.push = function (bytes) {\n      var startIndex = 0,\n          endIndex = MP2T_PACKET_LENGTH$1,\n          everything; // If there are bytes remaining from the last segment, prepend them to the\n      // bytes that were pushed in\n\n      if (bytesInBuffer) {\n        everything = new Uint8Array(bytes.byteLength + bytesInBuffer);\n        everything.set(buffer.subarray(0, bytesInBuffer));\n        everything.set(bytes, bytesInBuffer);\n        bytesInBuffer = 0;\n      } else {\n        everything = bytes;\n      } // While we have enough data for a packet\n\n\n      while (endIndex < everything.byteLength) {\n        // Look for a pair of start and end sync bytes in the data..\n        if (everything[startIndex] === SYNC_BYTE$1 && everything[endIndex] === SYNC_BYTE$1) {\n          // We found a packet so emit it and jump one whole packet forward in\n          // the stream\n          this.trigger('data', everything.subarray(startIndex, endIndex));\n          startIndex += MP2T_PACKET_LENGTH$1;\n          endIndex += MP2T_PACKET_LENGTH$1;\n          continue;\n        } // If we get here, we have somehow become de-synchronized and we need to step\n        // forward one byte at a time until we find a pair of sync bytes that denote\n        // a packet\n\n\n        startIndex++;\n        endIndex++;\n      } // If there was some data left over at the end of the segment that couldn't\n      // possibly be a whole packet, keep it because it might be the start of a packet\n      // that continues in the next segment\n\n\n      if (startIndex < everything.byteLength) {\n        buffer.set(everything.subarray(startIndex), 0);\n        bytesInBuffer = everything.byteLength - startIndex;\n      }\n    };\n    /**\n     * Passes identified M2TS packets to the TransportParseStream to be parsed\n    **/\n\n\n    this.flush = function () {\n      // If the buffer contains a whole packet when we are being flushed, emit it\n      // and empty the buffer. Otherwise hold onto the data because it may be\n      // important for decoding the next segment\n      if (bytesInBuffer === MP2T_PACKET_LENGTH$1 && buffer[0] === SYNC_BYTE$1) {\n        this.trigger('data', buffer);\n        bytesInBuffer = 0;\n      }\n\n      this.trigger('done');\n    };\n\n    this.endTimeline = function () {\n      this.flush();\n      this.trigger('endedtimeline');\n    };\n\n    this.reset = function () {\n      bytesInBuffer = 0;\n      this.trigger('reset');\n    };\n  };\n\n  _TransportPacketStream.prototype = new stream();\n  /**\n   * Accepts an MP2T TransportPacketStream and emits data events with parsed\n   * forms of the individual transport stream packets.\n   */\n\n  _TransportParseStream = function TransportParseStream() {\n    var parsePsi, parsePat, parsePmt, self;\n\n    _TransportParseStream.prototype.init.call(this);\n\n    self = this;\n    this.packetsWaitingForPmt = [];\n    this.programMapTable = undefined;\n\n    parsePsi = function parsePsi(payload, psi) {\n      var offset = 0; // PSI packets may be split into multiple sections and those\n      // sections may be split into multiple packets. If a PSI\n      // section starts in this packet, the payload_unit_start_indicator\n      // will be true and the first byte of the payload will indicate\n      // the offset from the current position to the start of the\n      // section.\n\n      if (psi.payloadUnitStartIndicator) {\n        offset += payload[offset] + 1;\n      }\n\n      if (psi.type === 'pat') {\n        parsePat(payload.subarray(offset), psi);\n      } else {\n        parsePmt(payload.subarray(offset), psi);\n      }\n    };\n\n    parsePat = function parsePat(payload, pat) {\n      pat.section_number = payload[7]; // eslint-disable-line camelcase\n\n      pat.last_section_number = payload[8]; // eslint-disable-line camelcase\n      // skip the PSI header and parse the first PMT entry\n\n      self.pmtPid = (payload[10] & 0x1F) << 8 | payload[11];\n      pat.pmtPid = self.pmtPid;\n    };\n    /**\n     * Parse out the relevant fields of a Program Map Table (PMT).\n     * @param payload {Uint8Array} the PMT-specific portion of an MP2T\n     * packet. The first byte in this array should be the table_id\n     * field.\n     * @param pmt {object} the object that should be decorated with\n     * fields parsed from the PMT.\n     */\n\n\n    parsePmt = function parsePmt(payload, pmt) {\n      var sectionLength, tableEnd, programInfoLength, offset; // PMTs can be sent ahead of the time when they should actually\n      // take effect. We don't believe this should ever be the case\n      // for HLS but we'll ignore \"forward\" PMT declarations if we see\n      // them. Future PMT declarations have the current_next_indicator\n      // set to zero.\n\n      if (!(payload[5] & 0x01)) {\n        return;\n      } // overwrite any existing program map table\n\n\n      self.programMapTable = {\n        video: null,\n        audio: null,\n        'timed-metadata': {}\n      }; // the mapping table ends at the end of the current section\n\n      sectionLength = (payload[1] & 0x0f) << 8 | payload[2];\n      tableEnd = 3 + sectionLength - 4; // to determine where the table is, we have to figure out how\n      // long the program info descriptors are\n\n      programInfoLength = (payload[10] & 0x0f) << 8 | payload[11]; // advance the offset to the first entry in the mapping table\n\n      offset = 12 + programInfoLength;\n\n      while (offset < tableEnd) {\n        var streamType = payload[offset];\n        var pid = (payload[offset + 1] & 0x1F) << 8 | payload[offset + 2]; // only map a single elementary_pid for audio and video stream types\n        // TODO: should this be done for metadata too? for now maintain behavior of\n        //       multiple metadata streams\n\n        if (streamType === streamTypes.H264_STREAM_TYPE && self.programMapTable.video === null) {\n          self.programMapTable.video = pid;\n        } else if (streamType === streamTypes.ADTS_STREAM_TYPE && self.programMapTable.audio === null) {\n          self.programMapTable.audio = pid;\n        } else if (streamType === streamTypes.METADATA_STREAM_TYPE) {\n          // map pid to stream type for metadata streams\n          self.programMapTable['timed-metadata'][pid] = streamType;\n        } // move to the next table entry\n        // skip past the elementary stream descriptors, if present\n\n\n        offset += ((payload[offset + 3] & 0x0F) << 8 | payload[offset + 4]) + 5;\n      } // record the map on the packet as well\n\n\n      pmt.programMapTable = self.programMapTable;\n    };\n    /**\n     * Deliver a new MP2T packet to the next stream in the pipeline.\n     */\n\n\n    this.push = function (packet) {\n      var result = {},\n          offset = 4;\n      result.payloadUnitStartIndicator = !!(packet[1] & 0x40); // pid is a 13-bit field starting at the last bit of packet[1]\n\n      result.pid = packet[1] & 0x1f;\n      result.pid <<= 8;\n      result.pid |= packet[2]; // if an adaption field is present, its length is specified by the\n      // fifth byte of the TS packet header. The adaptation field is\n      // used to add stuffing to PES packets that don't fill a complete\n      // TS packet, and to specify some forms of timing and control data\n      // that we do not currently use.\n\n      if ((packet[3] & 0x30) >>> 4 > 0x01) {\n        offset += packet[offset] + 1;\n      } // parse the rest of the packet based on the type\n\n\n      if (result.pid === 0) {\n        result.type = 'pat';\n        parsePsi(packet.subarray(offset), result);\n        this.trigger('data', result);\n      } else if (result.pid === this.pmtPid) {\n        result.type = 'pmt';\n        parsePsi(packet.subarray(offset), result);\n        this.trigger('data', result); // if there are any packets waiting for a PMT to be found, process them now\n\n        while (this.packetsWaitingForPmt.length) {\n          this.processPes_.apply(this, this.packetsWaitingForPmt.shift());\n        }\n      } else if (this.programMapTable === undefined) {\n        // When we have not seen a PMT yet, defer further processing of\n        // PES packets until one has been parsed\n        this.packetsWaitingForPmt.push([packet, offset, result]);\n      } else {\n        this.processPes_(packet, offset, result);\n      }\n    };\n\n    this.processPes_ = function (packet, offset, result) {\n      // set the appropriate stream type\n      if (result.pid === this.programMapTable.video) {\n        result.streamType = streamTypes.H264_STREAM_TYPE;\n      } else if (result.pid === this.programMapTable.audio) {\n        result.streamType = streamTypes.ADTS_STREAM_TYPE;\n      } else {\n        // if not video or audio, it is timed-metadata or unknown\n        // if unknown, streamType will be undefined\n        result.streamType = this.programMapTable['timed-metadata'][result.pid];\n      }\n\n      result.type = 'pes';\n      result.data = packet.subarray(offset);\n      this.trigger('data', result);\n    };\n  };\n\n  _TransportParseStream.prototype = new stream();\n  _TransportParseStream.STREAM_TYPES = {\n    h264: 0x1b,\n    adts: 0x0f\n  };\n  /**\n   * Reconsistutes program elementary stream (PES) packets from parsed\n   * transport stream packets. That is, if you pipe an\n   * mp2t.TransportParseStream into a mp2t.ElementaryStream, the output\n   * events will be events which capture the bytes for individual PES\n   * packets plus relevant metadata that has been extracted from the\n   * container.\n   */\n\n  _ElementaryStream = function ElementaryStream() {\n    var self = this,\n        segmentHadPmt = false,\n        // PES packet fragments\n    video = {\n      data: [],\n      size: 0\n    },\n        audio = {\n      data: [],\n      size: 0\n    },\n        timedMetadata = {\n      data: [],\n      size: 0\n    },\n        programMapTable,\n        parsePes = function parsePes(payload, pes) {\n      var ptsDtsFlags;\n      var startPrefix = payload[0] << 16 | payload[1] << 8 | payload[2]; // default to an empty array\n\n      pes.data = new Uint8Array(); // In certain live streams, the start of a TS fragment has ts packets\n      // that are frame data that is continuing from the previous fragment. This\n      // is to check that the pes data is the start of a new pes payload\n\n      if (startPrefix !== 1) {\n        return;\n      } // get the packet length, this will be 0 for video\n\n\n      pes.packetLength = 6 + (payload[4] << 8 | payload[5]); // find out if this packets starts a new keyframe\n\n      pes.dataAlignmentIndicator = (payload[6] & 0x04) !== 0; // PES packets may be annotated with a PTS value, or a PTS value\n      // and a DTS value. Determine what combination of values is\n      // available to work with.\n\n      ptsDtsFlags = payload[7]; // PTS and DTS are normally stored as a 33-bit number.  Javascript\n      // performs all bitwise operations on 32-bit integers but javascript\n      // supports a much greater range (52-bits) of integer using standard\n      // mathematical operations.\n      // We construct a 31-bit value using bitwise operators over the 31\n      // most significant bits and then multiply by 4 (equal to a left-shift\n      // of 2) before we add the final 2 least significant bits of the\n      // timestamp (equal to an OR.)\n\n      if (ptsDtsFlags & 0xC0) {\n        // the PTS and DTS are not written out directly. For information\n        // on how they are encoded, see\n        // http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n        pes.pts = (payload[9] & 0x0E) << 27 | (payload[10] & 0xFF) << 20 | (payload[11] & 0xFE) << 12 | (payload[12] & 0xFF) << 5 | (payload[13] & 0xFE) >>> 3;\n        pes.pts *= 4; // Left shift by 2\n\n        pes.pts += (payload[13] & 0x06) >>> 1; // OR by the two LSBs\n\n        pes.dts = pes.pts;\n\n        if (ptsDtsFlags & 0x40) {\n          pes.dts = (payload[14] & 0x0E) << 27 | (payload[15] & 0xFF) << 20 | (payload[16] & 0xFE) << 12 | (payload[17] & 0xFF) << 5 | (payload[18] & 0xFE) >>> 3;\n          pes.dts *= 4; // Left shift by 2\n\n          pes.dts += (payload[18] & 0x06) >>> 1; // OR by the two LSBs\n        }\n      } // the data section starts immediately after the PES header.\n      // pes_header_data_length specifies the number of header bytes\n      // that follow the last byte of the field.\n\n\n      pes.data = payload.subarray(9 + payload[8]);\n    },\n\n    /**\n      * Pass completely parsed PES packets to the next stream in the pipeline\n     **/\n    flushStream = function flushStream(stream, type, forceFlush) {\n      var packetData = new Uint8Array(stream.size),\n          event = {\n        type: type\n      },\n          i = 0,\n          offset = 0,\n          packetFlushable = false,\n          fragment; // do nothing if there is not enough buffered data for a complete\n      // PES header\n\n      if (!stream.data.length || stream.size < 9) {\n        return;\n      }\n\n      event.trackId = stream.data[0].pid; // reassemble the packet\n\n      for (i = 0; i < stream.data.length; i++) {\n        fragment = stream.data[i];\n        packetData.set(fragment.data, offset);\n        offset += fragment.data.byteLength;\n      } // parse assembled packet's PES header\n\n\n      parsePes(packetData, event); // non-video PES packets MUST have a non-zero PES_packet_length\n      // check that there is enough stream data to fill the packet\n\n      packetFlushable = type === 'video' || event.packetLength <= stream.size; // flush pending packets if the conditions are right\n\n      if (forceFlush || packetFlushable) {\n        stream.size = 0;\n        stream.data.length = 0;\n      } // only emit packets that are complete. this is to avoid assembling\n      // incomplete PES packets due to poor segmentation\n\n\n      if (packetFlushable) {\n        self.trigger('data', event);\n      }\n    };\n\n    _ElementaryStream.prototype.init.call(this);\n    /**\n     * Identifies M2TS packet types and parses PES packets using metadata\n     * parsed from the PMT\n     **/\n\n\n    this.push = function (data) {\n      ({\n        pat: function pat() {// we have to wait for the PMT to arrive as well before we\n          // have any meaningful metadata\n        },\n        pes: function pes() {\n          var stream, streamType;\n\n          switch (data.streamType) {\n            case streamTypes.H264_STREAM_TYPE:\n              stream = video;\n              streamType = 'video';\n              break;\n\n            case streamTypes.ADTS_STREAM_TYPE:\n              stream = audio;\n              streamType = 'audio';\n              break;\n\n            case streamTypes.METADATA_STREAM_TYPE:\n              stream = timedMetadata;\n              streamType = 'timed-metadata';\n              break;\n\n            default:\n              // ignore unknown stream types\n              return;\n          } // if a new packet is starting, we can flush the completed\n          // packet\n\n\n          if (data.payloadUnitStartIndicator) {\n            flushStream(stream, streamType, true);\n          } // buffer this fragment until we are sure we've received the\n          // complete payload\n\n\n          stream.data.push(data);\n          stream.size += data.data.byteLength;\n        },\n        pmt: function pmt() {\n          var event = {\n            type: 'metadata',\n            tracks: []\n          };\n          programMapTable = data.programMapTable; // translate audio and video streams to tracks\n\n          if (programMapTable.video !== null) {\n            event.tracks.push({\n              timelineStartInfo: {\n                baseMediaDecodeTime: 0\n              },\n              id: +programMapTable.video,\n              codec: 'avc',\n              type: 'video'\n            });\n          }\n\n          if (programMapTable.audio !== null) {\n            event.tracks.push({\n              timelineStartInfo: {\n                baseMediaDecodeTime: 0\n              },\n              id: +programMapTable.audio,\n              codec: 'adts',\n              type: 'audio'\n            });\n          }\n\n          segmentHadPmt = true;\n          self.trigger('data', event);\n        }\n      })[data.type]();\n    };\n\n    this.reset = function () {\n      video.size = 0;\n      video.data.length = 0;\n      audio.size = 0;\n      audio.data.length = 0;\n      this.trigger('reset');\n    };\n    /**\n     * Flush any remaining input. Video PES packets may be of variable\n     * length. Normally, the start of a new video packet can trigger the\n     * finalization of the previous packet. That is not possible if no\n     * more video is forthcoming, however. In that case, some other\n     * mechanism (like the end of the file) has to be employed. When it is\n     * clear that no additional data is forthcoming, calling this method\n     * will flush the buffered packets.\n     */\n\n\n    this.flushStreams_ = function () {\n      // !!THIS ORDER IS IMPORTANT!!\n      // video first then audio\n      flushStream(video, 'video');\n      flushStream(audio, 'audio');\n      flushStream(timedMetadata, 'timed-metadata');\n    };\n\n    this.flush = function () {\n      // if on flush we haven't had a pmt emitted\n      // and we have a pmt to emit. emit the pmt\n      // so that we trigger a trackinfo downstream.\n      if (!segmentHadPmt && programMapTable) {\n        var pmt = {\n          type: 'metadata',\n          tracks: []\n        }; // translate audio and video streams to tracks\n\n        if (programMapTable.video !== null) {\n          pmt.tracks.push({\n            timelineStartInfo: {\n              baseMediaDecodeTime: 0\n            },\n            id: +programMapTable.video,\n            codec: 'avc',\n            type: 'video'\n          });\n        }\n\n        if (programMapTable.audio !== null) {\n          pmt.tracks.push({\n            timelineStartInfo: {\n              baseMediaDecodeTime: 0\n            },\n            id: +programMapTable.audio,\n            codec: 'adts',\n            type: 'audio'\n          });\n        }\n\n        self.trigger('data', pmt);\n      }\n\n      segmentHadPmt = false;\n      this.flushStreams_();\n      this.trigger('done');\n    };\n  };\n\n  _ElementaryStream.prototype = new stream();\n  var m2ts$1 = {\n    PAT_PID: 0x0000,\n    MP2T_PACKET_LENGTH: MP2T_PACKET_LENGTH$1,\n    TransportPacketStream: _TransportPacketStream,\n    TransportParseStream: _TransportParseStream,\n    ElementaryStream: _ElementaryStream,\n    TimestampRolloverStream: TimestampRolloverStream,\n    CaptionStream: captionStream.CaptionStream,\n    Cea608Stream: captionStream.Cea608Stream,\n    Cea708Stream: captionStream.Cea708Stream,\n    MetadataStream: metadataStream\n  };\n\n  for (var type in streamTypes) {\n    if (streamTypes.hasOwnProperty(type)) {\n      m2ts$1[type] = streamTypes[type];\n    }\n  }\n\n  var m2ts_1 = m2ts$1;\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   *\n   * Utilities to detect basic properties and metadata about Aac data.\n   */\n\n  var ADTS_SAMPLING_FREQUENCIES = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n\n  var parseId3TagSize = function parseId3TagSize(header, byteIndex) {\n    var returnSize = header[byteIndex + 6] << 21 | header[byteIndex + 7] << 14 | header[byteIndex + 8] << 7 | header[byteIndex + 9],\n        flags = header[byteIndex + 5],\n        footerPresent = (flags & 16) >> 4; // if we get a negative returnSize clamp it to 0\n\n    returnSize = returnSize >= 0 ? returnSize : 0;\n\n    if (footerPresent) {\n      return returnSize + 20;\n    }\n\n    return returnSize + 10;\n  };\n\n  var getId3Offset = function getId3Offset(data, offset) {\n    if (data.length - offset < 10 || data[offset] !== 'I'.charCodeAt(0) || data[offset + 1] !== 'D'.charCodeAt(0) || data[offset + 2] !== '3'.charCodeAt(0)) {\n      return offset;\n    }\n\n    offset += parseId3TagSize(data, offset);\n    return getId3Offset(data, offset);\n  }; // TODO: use vhs-utils\n\n\n  var isLikelyAacData$2 = function isLikelyAacData(data) {\n    var offset = getId3Offset(data, 0);\n    return data.length >= offset + 2 && (data[offset] & 0xFF) === 0xFF && (data[offset + 1] & 0xF0) === 0xF0 && // verify that the 2 layer bits are 0, aka this\n    // is not mp3 data but aac data.\n    (data[offset + 1] & 0x16) === 0x10;\n  };\n\n  var parseSyncSafeInteger = function parseSyncSafeInteger(data) {\n    return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];\n  }; // return a percent-encoded representation of the specified byte range\n  // @see http://en.wikipedia.org/wiki/Percent-encoding\n\n\n  var percentEncode = function percentEncode(bytes, start, end) {\n    var i,\n        result = '';\n\n    for (i = start; i < end; i++) {\n      result += '%' + ('00' + bytes[i].toString(16)).slice(-2);\n    }\n\n    return result;\n  }; // return the string representation of the specified byte range,\n  // interpreted as ISO-8859-1.\n\n\n  var parseIso88591 = function parseIso88591(bytes, start, end) {\n    return unescape(percentEncode(bytes, start, end)); // jshint ignore:line\n  };\n\n  var parseAdtsSize = function parseAdtsSize(header, byteIndex) {\n    var lowThree = (header[byteIndex + 5] & 0xE0) >> 5,\n        middle = header[byteIndex + 4] << 3,\n        highTwo = header[byteIndex + 3] & 0x3 << 11;\n    return highTwo | middle | lowThree;\n  };\n\n  var parseType$1 = function parseType(header, byteIndex) {\n    if (header[byteIndex] === 'I'.charCodeAt(0) && header[byteIndex + 1] === 'D'.charCodeAt(0) && header[byteIndex + 2] === '3'.charCodeAt(0)) {\n      return 'timed-metadata';\n    } else if (header[byteIndex] & 0xff === 0xff && (header[byteIndex + 1] & 0xf0) === 0xf0) {\n      return 'audio';\n    }\n\n    return null;\n  };\n\n  var parseSampleRate = function parseSampleRate(packet) {\n    var i = 0;\n\n    while (i + 5 < packet.length) {\n      if (packet[i] !== 0xFF || (packet[i + 1] & 0xF6) !== 0xF0) {\n        // If a valid header was not found,  jump one forward and attempt to\n        // find a valid ADTS header starting at the next byte\n        i++;\n        continue;\n      }\n\n      return ADTS_SAMPLING_FREQUENCIES[(packet[i + 2] & 0x3c) >>> 2];\n    }\n\n    return null;\n  };\n\n  var parseAacTimestamp = function parseAacTimestamp(packet) {\n    var frameStart, frameSize, frame, frameHeader; // find the start of the first frame and the end of the tag\n\n    frameStart = 10;\n\n    if (packet[5] & 0x40) {\n      // advance the frame start past the extended header\n      frameStart += 4; // header size field\n\n      frameStart += parseSyncSafeInteger(packet.subarray(10, 14));\n    } // parse one or more ID3 frames\n    // http://id3.org/id3v2.3.0#ID3v2_frame_overview\n\n\n    do {\n      // determine the number of bytes in this frame\n      frameSize = parseSyncSafeInteger(packet.subarray(frameStart + 4, frameStart + 8));\n\n      if (frameSize < 1) {\n        return null;\n      }\n\n      frameHeader = String.fromCharCode(packet[frameStart], packet[frameStart + 1], packet[frameStart + 2], packet[frameStart + 3]);\n\n      if (frameHeader === 'PRIV') {\n        frame = packet.subarray(frameStart + 10, frameStart + frameSize + 10);\n\n        for (var i = 0; i < frame.byteLength; i++) {\n          if (frame[i] === 0) {\n            var owner = parseIso88591(frame, 0, i);\n\n            if (owner === 'com.apple.streaming.transportStreamTimestamp') {\n              var d = frame.subarray(i + 1);\n              var size = (d[3] & 0x01) << 30 | d[4] << 22 | d[5] << 14 | d[6] << 6 | d[7] >>> 2;\n              size *= 4;\n              size += d[7] & 0x03;\n              return size;\n            }\n\n            break;\n          }\n        }\n      }\n\n      frameStart += 10; // advance past the frame header\n\n      frameStart += frameSize; // advance past the frame body\n    } while (frameStart < packet.byteLength);\n\n    return null;\n  };\n\n  var utils = {\n    isLikelyAacData: isLikelyAacData$2,\n    parseId3TagSize: parseId3TagSize,\n    parseAdtsSize: parseAdtsSize,\n    parseType: parseType$1,\n    parseSampleRate: parseSampleRate,\n    parseAacTimestamp: parseAacTimestamp\n  };\n\n  var _AacStream;\n  /**\n   * Splits an incoming stream of binary data into ADTS and ID3 Frames.\n   */\n\n\n  _AacStream = function AacStream() {\n    var everything = new Uint8Array(),\n        timeStamp = 0;\n\n    _AacStream.prototype.init.call(this);\n\n    this.setTimestamp = function (timestamp) {\n      timeStamp = timestamp;\n    };\n\n    this.push = function (bytes) {\n      var frameSize = 0,\n          byteIndex = 0,\n          bytesLeft,\n          chunk,\n          packet,\n          tempLength; // If there are bytes remaining from the last segment, prepend them to the\n      // bytes that were pushed in\n\n      if (everything.length) {\n        tempLength = everything.length;\n        everything = new Uint8Array(bytes.byteLength + tempLength);\n        everything.set(everything.subarray(0, tempLength));\n        everything.set(bytes, tempLength);\n      } else {\n        everything = bytes;\n      }\n\n      while (everything.length - byteIndex >= 3) {\n        if (everything[byteIndex] === 'I'.charCodeAt(0) && everything[byteIndex + 1] === 'D'.charCodeAt(0) && everything[byteIndex + 2] === '3'.charCodeAt(0)) {\n          // Exit early because we don't have enough to parse\n          // the ID3 tag header\n          if (everything.length - byteIndex < 10) {\n            break;\n          } // check framesize\n\n\n          frameSize = utils.parseId3TagSize(everything, byteIndex); // Exit early if we don't have enough in the buffer\n          // to emit a full packet\n          // Add to byteIndex to support multiple ID3 tags in sequence\n\n          if (byteIndex + frameSize > everything.length) {\n            break;\n          }\n\n          chunk = {\n            type: 'timed-metadata',\n            data: everything.subarray(byteIndex, byteIndex + frameSize)\n          };\n          this.trigger('data', chunk);\n          byteIndex += frameSize;\n          continue;\n        } else if ((everything[byteIndex] & 0xff) === 0xff && (everything[byteIndex + 1] & 0xf0) === 0xf0) {\n          // Exit early because we don't have enough to parse\n          // the ADTS frame header\n          if (everything.length - byteIndex < 7) {\n            break;\n          }\n\n          frameSize = utils.parseAdtsSize(everything, byteIndex); // Exit early if we don't have enough in the buffer\n          // to emit a full packet\n\n          if (byteIndex + frameSize > everything.length) {\n            break;\n          }\n\n          packet = {\n            type: 'audio',\n            data: everything.subarray(byteIndex, byteIndex + frameSize),\n            pts: timeStamp,\n            dts: timeStamp\n          };\n          this.trigger('data', packet);\n          byteIndex += frameSize;\n          continue;\n        }\n\n        byteIndex++;\n      }\n\n      bytesLeft = everything.length - byteIndex;\n\n      if (bytesLeft > 0) {\n        everything = everything.subarray(byteIndex);\n      } else {\n        everything = new Uint8Array();\n      }\n    };\n\n    this.reset = function () {\n      everything = new Uint8Array();\n      this.trigger('reset');\n    };\n\n    this.endTimeline = function () {\n      everything = new Uint8Array();\n      this.trigger('endedtimeline');\n    };\n  };\n\n  _AacStream.prototype = new stream();\n  var aac = _AacStream; // constants\n\n  var AUDIO_PROPERTIES = ['audioobjecttype', 'channelcount', 'samplerate', 'samplingfrequencyindex', 'samplesize'];\n  var audioProperties = AUDIO_PROPERTIES;\n  var VIDEO_PROPERTIES = ['width', 'height', 'profileIdc', 'levelIdc', 'profileCompatibility', 'sarRatio'];\n  var videoProperties = VIDEO_PROPERTIES;\n  var H264Stream$1 = h264.H264Stream;\n  var isLikelyAacData$1 = utils.isLikelyAacData;\n  var ONE_SECOND_IN_TS$2 = clock.ONE_SECOND_IN_TS; // object types\n\n  var _VideoSegmentStream$1, _AudioSegmentStream$1, _Transmuxer$1, _CoalesceStream;\n\n  var retriggerForStream = function retriggerForStream(key, event) {\n    event.stream = key;\n    this.trigger('log', event);\n  };\n\n  var addPipelineLogRetriggers = function addPipelineLogRetriggers(transmuxer, pipeline) {\n    var keys = Object.keys(pipeline);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]; // skip non-stream keys and headOfPipeline\n      // which is just a duplicate\n\n      if (key === 'headOfPipeline' || !pipeline[key].on) {\n        continue;\n      }\n\n      pipeline[key].on('log', retriggerForStream.bind(transmuxer, key));\n    }\n  };\n  /**\n   * Compare two arrays (even typed) for same-ness\n   */\n\n\n  var arrayEquals = function arrayEquals(a, b) {\n    var i;\n\n    if (a.length !== b.length) {\n      return false;\n    } // compare the value of each element in the array\n\n\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  var generateSegmentTimingInfo = function generateSegmentTimingInfo(baseMediaDecodeTime, startDts, startPts, endDts, endPts, prependedContentDuration) {\n    var ptsOffsetFromDts = startPts - startDts,\n        decodeDuration = endDts - startDts,\n        presentationDuration = endPts - startPts; // The PTS and DTS values are based on the actual stream times from the segment,\n    // however, the player time values will reflect a start from the baseMediaDecodeTime.\n    // In order to provide relevant values for the player times, base timing info on the\n    // baseMediaDecodeTime and the DTS and PTS durations of the segment.\n\n    return {\n      start: {\n        dts: baseMediaDecodeTime,\n        pts: baseMediaDecodeTime + ptsOffsetFromDts\n      },\n      end: {\n        dts: baseMediaDecodeTime + decodeDuration,\n        pts: baseMediaDecodeTime + presentationDuration\n      },\n      prependedContentDuration: prependedContentDuration,\n      baseMediaDecodeTime: baseMediaDecodeTime\n    };\n  };\n  /**\n   * Constructs a single-track, ISO BMFF media segment from AAC data\n   * events. The output of this stream can be fed to a SourceBuffer\n   * configured with a suitable initialization segment.\n   * @param track {object} track metadata configuration\n   * @param options {object} transmuxer options object\n   * @param options.keepOriginalTimestamps {boolean} If true, keep the timestamps\n   *        in the source; false to adjust the first segment to start at 0.\n   */\n\n\n  _AudioSegmentStream$1 = function AudioSegmentStream(track, options) {\n    var adtsFrames = [],\n        sequenceNumber,\n        earliestAllowedDts = 0,\n        audioAppendStartTs = 0,\n        videoBaseMediaDecodeTime = Infinity;\n    options = options || {};\n    sequenceNumber = options.firstSequenceNumber || 0;\n\n    _AudioSegmentStream$1.prototype.init.call(this);\n\n    this.push = function (data) {\n      trackDecodeInfo.collectDtsInfo(track, data);\n\n      if (track) {\n        audioProperties.forEach(function (prop) {\n          track[prop] = data[prop];\n        });\n      } // buffer audio data until end() is called\n\n\n      adtsFrames.push(data);\n    };\n\n    this.setEarliestDts = function (earliestDts) {\n      earliestAllowedDts = earliestDts;\n    };\n\n    this.setVideoBaseMediaDecodeTime = function (baseMediaDecodeTime) {\n      videoBaseMediaDecodeTime = baseMediaDecodeTime;\n    };\n\n    this.setAudioAppendStart = function (timestamp) {\n      audioAppendStartTs = timestamp;\n    };\n\n    this.flush = function () {\n      var frames, moof, mdat, boxes, frameDuration, segmentDuration, videoClockCyclesOfSilencePrefixed; // return early if no audio data has been observed\n\n      if (adtsFrames.length === 0) {\n        this.trigger('done', 'AudioSegmentStream');\n        return;\n      }\n\n      frames = audioFrameUtils.trimAdtsFramesByEarliestDts(adtsFrames, track, earliestAllowedDts);\n      track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps); // amount of audio filled but the value is in video clock rather than audio clock\n\n      videoClockCyclesOfSilencePrefixed = audioFrameUtils.prefixWithSilence(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime); // we have to build the index from byte locations to\n      // samples (that is, adts frames) in the audio data\n\n      track.samples = audioFrameUtils.generateSampleTable(frames); // concatenate the audio data to constuct the mdat\n\n      mdat = mp4Generator.mdat(audioFrameUtils.concatenateFrameData(frames));\n      adtsFrames = [];\n      moof = mp4Generator.moof(sequenceNumber, [track]);\n      boxes = new Uint8Array(moof.byteLength + mdat.byteLength); // bump the sequence number for next time\n\n      sequenceNumber++;\n      boxes.set(moof);\n      boxes.set(mdat, moof.byteLength);\n      trackDecodeInfo.clearDtsInfo(track);\n      frameDuration = Math.ceil(ONE_SECOND_IN_TS$2 * 1024 / track.samplerate); // TODO this check was added to maintain backwards compatibility (particularly with\n      // tests) on adding the timingInfo event. However, it seems unlikely that there's a\n      // valid use-case where an init segment/data should be triggered without associated\n      // frames. Leaving for now, but should be looked into.\n\n      if (frames.length) {\n        segmentDuration = frames.length * frameDuration;\n        this.trigger('segmentTimingInfo', generateSegmentTimingInfo( // The audio track's baseMediaDecodeTime is in audio clock cycles, but the\n        // frame info is in video clock cycles. Convert to match expectation of\n        // listeners (that all timestamps will be based on video clock cycles).\n        clock.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate), // frame times are already in video clock, as is segment duration\n        frames[0].dts, frames[0].pts, frames[0].dts + segmentDuration, frames[0].pts + segmentDuration, videoClockCyclesOfSilencePrefixed || 0));\n        this.trigger('timingInfo', {\n          start: frames[0].pts,\n          end: frames[0].pts + segmentDuration\n        });\n      }\n\n      this.trigger('data', {\n        track: track,\n        boxes: boxes\n      });\n      this.trigger('done', 'AudioSegmentStream');\n    };\n\n    this.reset = function () {\n      trackDecodeInfo.clearDtsInfo(track);\n      adtsFrames = [];\n      this.trigger('reset');\n    };\n  };\n\n  _AudioSegmentStream$1.prototype = new stream();\n  /**\n   * Constructs a single-track, ISO BMFF media segment from H264 data\n   * events. The output of this stream can be fed to a SourceBuffer\n   * configured with a suitable initialization segment.\n   * @param track {object} track metadata configuration\n   * @param options {object} transmuxer options object\n   * @param options.alignGopsAtEnd {boolean} If true, start from the end of the\n   *        gopsToAlignWith list when attempting to align gop pts\n   * @param options.keepOriginalTimestamps {boolean} If true, keep the timestamps\n   *        in the source; false to adjust the first segment to start at 0.\n   */\n\n  _VideoSegmentStream$1 = function VideoSegmentStream(track, options) {\n    var sequenceNumber,\n        nalUnits = [],\n        gopsToAlignWith = [],\n        config,\n        pps;\n    options = options || {};\n    sequenceNumber = options.firstSequenceNumber || 0;\n\n    _VideoSegmentStream$1.prototype.init.call(this);\n\n    delete track.minPTS;\n    this.gopCache_ = [];\n    /**\n      * Constructs a ISO BMFF segment given H264 nalUnits\n      * @param {Object} nalUnit A data event representing a nalUnit\n      * @param {String} nalUnit.nalUnitType\n      * @param {Object} nalUnit.config Properties for a mp4 track\n      * @param {Uint8Array} nalUnit.data The nalUnit bytes\n      * @see lib/codecs/h264.js\n     **/\n\n    this.push = function (nalUnit) {\n      trackDecodeInfo.collectDtsInfo(track, nalUnit); // record the track config\n\n      if (nalUnit.nalUnitType === 'seq_parameter_set_rbsp' && !config) {\n        config = nalUnit.config;\n        track.sps = [nalUnit.data];\n        videoProperties.forEach(function (prop) {\n          track[prop] = config[prop];\n        }, this);\n      }\n\n      if (nalUnit.nalUnitType === 'pic_parameter_set_rbsp' && !pps) {\n        pps = nalUnit.data;\n        track.pps = [nalUnit.data];\n      } // buffer video until flush() is called\n\n\n      nalUnits.push(nalUnit);\n    };\n    /**\n      * Pass constructed ISO BMFF track and boxes on to the\n      * next stream in the pipeline\n     **/\n\n\n    this.flush = function () {\n      var frames,\n          gopForFusion,\n          gops,\n          moof,\n          mdat,\n          boxes,\n          prependedContentDuration = 0,\n          firstGop,\n          lastGop; // Throw away nalUnits at the start of the byte stream until\n      // we find the first AUD\n\n      while (nalUnits.length) {\n        if (nalUnits[0].nalUnitType === 'access_unit_delimiter_rbsp') {\n          break;\n        }\n\n        nalUnits.shift();\n      } // Return early if no video data has been observed\n\n\n      if (nalUnits.length === 0) {\n        this.resetStream_();\n        this.trigger('done', 'VideoSegmentStream');\n        return;\n      } // Organize the raw nal-units into arrays that represent\n      // higher-level constructs such as frames and gops\n      // (group-of-pictures)\n\n\n      frames = frameUtils.groupNalsIntoFrames(nalUnits);\n      gops = frameUtils.groupFramesIntoGops(frames); // If the first frame of this fragment is not a keyframe we have\n      // a problem since MSE (on Chrome) requires a leading keyframe.\n      //\n      // We have two approaches to repairing this situation:\n      // 1) GOP-FUSION:\n      //    This is where we keep track of the GOPS (group-of-pictures)\n      //    from previous fragments and attempt to find one that we can\n      //    prepend to the current fragment in order to create a valid\n      //    fragment.\n      // 2) KEYFRAME-PULLING:\n      //    Here we search for the first keyframe in the fragment and\n      //    throw away all the frames between the start of the fragment\n      //    and that keyframe. We then extend the duration and pull the\n      //    PTS of the keyframe forward so that it covers the time range\n      //    of the frames that were disposed of.\n      //\n      // #1 is far prefereable over #2 which can cause \"stuttering\" but\n      // requires more things to be just right.\n\n      if (!gops[0][0].keyFrame) {\n        // Search for a gop for fusion from our gopCache\n        gopForFusion = this.getGopForFusion_(nalUnits[0], track);\n\n        if (gopForFusion) {\n          // in order to provide more accurate timing information about the segment, save\n          // the number of seconds prepended to the original segment due to GOP fusion\n          prependedContentDuration = gopForFusion.duration;\n          gops.unshift(gopForFusion); // Adjust Gops' metadata to account for the inclusion of the\n          // new gop at the beginning\n\n          gops.byteLength += gopForFusion.byteLength;\n          gops.nalCount += gopForFusion.nalCount;\n          gops.pts = gopForFusion.pts;\n          gops.dts = gopForFusion.dts;\n          gops.duration += gopForFusion.duration;\n        } else {\n          // If we didn't find a candidate gop fall back to keyframe-pulling\n          gops = frameUtils.extendFirstKeyFrame(gops);\n        }\n      } // Trim gops to align with gopsToAlignWith\n\n\n      if (gopsToAlignWith.length) {\n        var alignedGops;\n\n        if (options.alignGopsAtEnd) {\n          alignedGops = this.alignGopsAtEnd_(gops);\n        } else {\n          alignedGops = this.alignGopsAtStart_(gops);\n        }\n\n        if (!alignedGops) {\n          // save all the nals in the last GOP into the gop cache\n          this.gopCache_.unshift({\n            gop: gops.pop(),\n            pps: track.pps,\n            sps: track.sps\n          }); // Keep a maximum of 6 GOPs in the cache\n\n          this.gopCache_.length = Math.min(6, this.gopCache_.length); // Clear nalUnits\n\n          nalUnits = []; // return early no gops can be aligned with desired gopsToAlignWith\n\n          this.resetStream_();\n          this.trigger('done', 'VideoSegmentStream');\n          return;\n        } // Some gops were trimmed. clear dts info so minSegmentDts and pts are correct\n        // when recalculated before sending off to CoalesceStream\n\n\n        trackDecodeInfo.clearDtsInfo(track);\n        gops = alignedGops;\n      }\n\n      trackDecodeInfo.collectDtsInfo(track, gops); // First, we have to build the index from byte locations to\n      // samples (that is, frames) in the video data\n\n      track.samples = frameUtils.generateSampleTable(gops); // Concatenate the video data and construct the mdat\n\n      mdat = mp4Generator.mdat(frameUtils.concatenateNalData(gops));\n      track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);\n      this.trigger('processedGopsInfo', gops.map(function (gop) {\n        return {\n          pts: gop.pts,\n          dts: gop.dts,\n          byteLength: gop.byteLength\n        };\n      }));\n      firstGop = gops[0];\n      lastGop = gops[gops.length - 1];\n      this.trigger('segmentTimingInfo', generateSegmentTimingInfo(track.baseMediaDecodeTime, firstGop.dts, firstGop.pts, lastGop.dts + lastGop.duration, lastGop.pts + lastGop.duration, prependedContentDuration));\n      this.trigger('timingInfo', {\n        start: gops[0].pts,\n        end: gops[gops.length - 1].pts + gops[gops.length - 1].duration\n      }); // save all the nals in the last GOP into the gop cache\n\n      this.gopCache_.unshift({\n        gop: gops.pop(),\n        pps: track.pps,\n        sps: track.sps\n      }); // Keep a maximum of 6 GOPs in the cache\n\n      this.gopCache_.length = Math.min(6, this.gopCache_.length); // Clear nalUnits\n\n      nalUnits = [];\n      this.trigger('baseMediaDecodeTime', track.baseMediaDecodeTime);\n      this.trigger('timelineStartInfo', track.timelineStartInfo);\n      moof = mp4Generator.moof(sequenceNumber, [track]); // it would be great to allocate this array up front instead of\n      // throwing away hundreds of media segment fragments\n\n      boxes = new Uint8Array(moof.byteLength + mdat.byteLength); // Bump the sequence number for next time\n\n      sequenceNumber++;\n      boxes.set(moof);\n      boxes.set(mdat, moof.byteLength);\n      this.trigger('data', {\n        track: track,\n        boxes: boxes\n      });\n      this.resetStream_(); // Continue with the flush process now\n\n      this.trigger('done', 'VideoSegmentStream');\n    };\n\n    this.reset = function () {\n      this.resetStream_();\n      nalUnits = [];\n      this.gopCache_.length = 0;\n      gopsToAlignWith.length = 0;\n      this.trigger('reset');\n    };\n\n    this.resetStream_ = function () {\n      trackDecodeInfo.clearDtsInfo(track); // reset config and pps because they may differ across segments\n      // for instance, when we are rendition switching\n\n      config = undefined;\n      pps = undefined;\n    }; // Search for a candidate Gop for gop-fusion from the gop cache and\n    // return it or return null if no good candidate was found\n\n\n    this.getGopForFusion_ = function (nalUnit) {\n      var halfSecond = 45000,\n          // Half-a-second in a 90khz clock\n      allowableOverlap = 10000,\n          // About 3 frames @ 30fps\n      nearestDistance = Infinity,\n          dtsDistance,\n          nearestGopObj,\n          currentGop,\n          currentGopObj,\n          i; // Search for the GOP nearest to the beginning of this nal unit\n\n      for (i = 0; i < this.gopCache_.length; i++) {\n        currentGopObj = this.gopCache_[i];\n        currentGop = currentGopObj.gop; // Reject Gops with different SPS or PPS\n\n        if (!(track.pps && arrayEquals(track.pps[0], currentGopObj.pps[0])) || !(track.sps && arrayEquals(track.sps[0], currentGopObj.sps[0]))) {\n          continue;\n        } // Reject Gops that would require a negative baseMediaDecodeTime\n\n\n        if (currentGop.dts < track.timelineStartInfo.dts) {\n          continue;\n        } // The distance between the end of the gop and the start of the nalUnit\n\n\n        dtsDistance = nalUnit.dts - currentGop.dts - currentGop.duration; // Only consider GOPS that start before the nal unit and end within\n        // a half-second of the nal unit\n\n        if (dtsDistance >= -allowableOverlap && dtsDistance <= halfSecond) {\n          // Always use the closest GOP we found if there is more than\n          // one candidate\n          if (!nearestGopObj || nearestDistance > dtsDistance) {\n            nearestGopObj = currentGopObj;\n            nearestDistance = dtsDistance;\n          }\n        }\n      }\n\n      if (nearestGopObj) {\n        return nearestGopObj.gop;\n      }\n\n      return null;\n    }; // trim gop list to the first gop found that has a matching pts with a gop in the list\n    // of gopsToAlignWith starting from the START of the list\n\n\n    this.alignGopsAtStart_ = function (gops) {\n      var alignIndex, gopIndex, align, gop, byteLength, nalCount, duration, alignedGops;\n      byteLength = gops.byteLength;\n      nalCount = gops.nalCount;\n      duration = gops.duration;\n      alignIndex = gopIndex = 0;\n\n      while (alignIndex < gopsToAlignWith.length && gopIndex < gops.length) {\n        align = gopsToAlignWith[alignIndex];\n        gop = gops[gopIndex];\n\n        if (align.pts === gop.pts) {\n          break;\n        }\n\n        if (gop.pts > align.pts) {\n          // this current gop starts after the current gop we want to align on, so increment\n          // align index\n          alignIndex++;\n          continue;\n        } // current gop starts before the current gop we want to align on. so increment gop\n        // index\n\n\n        gopIndex++;\n        byteLength -= gop.byteLength;\n        nalCount -= gop.nalCount;\n        duration -= gop.duration;\n      }\n\n      if (gopIndex === 0) {\n        // no gops to trim\n        return gops;\n      }\n\n      if (gopIndex === gops.length) {\n        // all gops trimmed, skip appending all gops\n        return null;\n      }\n\n      alignedGops = gops.slice(gopIndex);\n      alignedGops.byteLength = byteLength;\n      alignedGops.duration = duration;\n      alignedGops.nalCount = nalCount;\n      alignedGops.pts = alignedGops[0].pts;\n      alignedGops.dts = alignedGops[0].dts;\n      return alignedGops;\n    }; // trim gop list to the first gop found that has a matching pts with a gop in the list\n    // of gopsToAlignWith starting from the END of the list\n\n\n    this.alignGopsAtEnd_ = function (gops) {\n      var alignIndex, gopIndex, align, gop, alignEndIndex, matchFound;\n      alignIndex = gopsToAlignWith.length - 1;\n      gopIndex = gops.length - 1;\n      alignEndIndex = null;\n      matchFound = false;\n\n      while (alignIndex >= 0 && gopIndex >= 0) {\n        align = gopsToAlignWith[alignIndex];\n        gop = gops[gopIndex];\n\n        if (align.pts === gop.pts) {\n          matchFound = true;\n          break;\n        }\n\n        if (align.pts > gop.pts) {\n          alignIndex--;\n          continue;\n        }\n\n        if (alignIndex === gopsToAlignWith.length - 1) {\n          // gop.pts is greater than the last alignment candidate. If no match is found\n          // by the end of this loop, we still want to append gops that come after this\n          // point\n          alignEndIndex = gopIndex;\n        }\n\n        gopIndex--;\n      }\n\n      if (!matchFound && alignEndIndex === null) {\n        return null;\n      }\n\n      var trimIndex;\n\n      if (matchFound) {\n        trimIndex = gopIndex;\n      } else {\n        trimIndex = alignEndIndex;\n      }\n\n      if (trimIndex === 0) {\n        return gops;\n      }\n\n      var alignedGops = gops.slice(trimIndex);\n      var metadata = alignedGops.reduce(function (total, gop) {\n        total.byteLength += gop.byteLength;\n        total.duration += gop.duration;\n        total.nalCount += gop.nalCount;\n        return total;\n      }, {\n        byteLength: 0,\n        duration: 0,\n        nalCount: 0\n      });\n      alignedGops.byteLength = metadata.byteLength;\n      alignedGops.duration = metadata.duration;\n      alignedGops.nalCount = metadata.nalCount;\n      alignedGops.pts = alignedGops[0].pts;\n      alignedGops.dts = alignedGops[0].dts;\n      return alignedGops;\n    };\n\n    this.alignGopsWith = function (newGopsToAlignWith) {\n      gopsToAlignWith = newGopsToAlignWith;\n    };\n  };\n\n  _VideoSegmentStream$1.prototype = new stream();\n  /**\n   * A Stream that can combine multiple streams (ie. audio & video)\n   * into a single output segment for MSE. Also supports audio-only\n   * and video-only streams.\n   * @param options {object} transmuxer options object\n   * @param options.keepOriginalTimestamps {boolean} If true, keep the timestamps\n   *        in the source; false to adjust the first segment to start at media timeline start.\n   */\n\n  _CoalesceStream = function CoalesceStream(options, metadataStream) {\n    // Number of Tracks per output segment\n    // If greater than 1, we combine multiple\n    // tracks into a single segment\n    this.numberOfTracks = 0;\n    this.metadataStream = metadataStream;\n    options = options || {};\n\n    if (typeof options.remux !== 'undefined') {\n      this.remuxTracks = !!options.remux;\n    } else {\n      this.remuxTracks = true;\n    }\n\n    if (typeof options.keepOriginalTimestamps === 'boolean') {\n      this.keepOriginalTimestamps = options.keepOriginalTimestamps;\n    } else {\n      this.keepOriginalTimestamps = false;\n    }\n\n    this.pendingTracks = [];\n    this.videoTrack = null;\n    this.pendingBoxes = [];\n    this.pendingCaptions = [];\n    this.pendingMetadata = [];\n    this.pendingBytes = 0;\n    this.emittedTracks = 0;\n\n    _CoalesceStream.prototype.init.call(this); // Take output from multiple\n\n\n    this.push = function (output) {\n      // buffer incoming captions until the associated video segment\n      // finishes\n      if (output.text) {\n        return this.pendingCaptions.push(output);\n      } // buffer incoming id3 tags until the final flush\n\n\n      if (output.frames) {\n        return this.pendingMetadata.push(output);\n      } // Add this track to the list of pending tracks and store\n      // important information required for the construction of\n      // the final segment\n\n\n      this.pendingTracks.push(output.track);\n      this.pendingBytes += output.boxes.byteLength; // TODO: is there an issue for this against chrome?\n      // We unshift audio and push video because\n      // as of Chrome 75 when switching from\n      // one init segment to another if the video\n      // mdat does not appear after the audio mdat\n      // only audio will play for the duration of our transmux.\n\n      if (output.track.type === 'video') {\n        this.videoTrack = output.track;\n        this.pendingBoxes.push(output.boxes);\n      }\n\n      if (output.track.type === 'audio') {\n        this.audioTrack = output.track;\n        this.pendingBoxes.unshift(output.boxes);\n      }\n    };\n  };\n\n  _CoalesceStream.prototype = new stream();\n\n  _CoalesceStream.prototype.flush = function (flushSource) {\n    var offset = 0,\n        event = {\n      captions: [],\n      captionStreams: {},\n      metadata: [],\n      info: {}\n    },\n        caption,\n        id3,\n        initSegment,\n        timelineStartPts = 0,\n        i;\n\n    if (this.pendingTracks.length < this.numberOfTracks) {\n      if (flushSource !== 'VideoSegmentStream' && flushSource !== 'AudioSegmentStream') {\n        // Return because we haven't received a flush from a data-generating\n        // portion of the segment (meaning that we have only recieved meta-data\n        // or captions.)\n        return;\n      } else if (this.remuxTracks) {\n        // Return until we have enough tracks from the pipeline to remux (if we\n        // are remuxing audio and video into a single MP4)\n        return;\n      } else if (this.pendingTracks.length === 0) {\n        // In the case where we receive a flush without any data having been\n        // received we consider it an emitted track for the purposes of coalescing\n        // `done` events.\n        // We do this for the case where there is an audio and video track in the\n        // segment but no audio data. (seen in several playlists with alternate\n        // audio tracks and no audio present in the main TS segments.)\n        this.emittedTracks++;\n\n        if (this.emittedTracks >= this.numberOfTracks) {\n          this.trigger('done');\n          this.emittedTracks = 0;\n        }\n\n        return;\n      }\n    }\n\n    if (this.videoTrack) {\n      timelineStartPts = this.videoTrack.timelineStartInfo.pts;\n      videoProperties.forEach(function (prop) {\n        event.info[prop] = this.videoTrack[prop];\n      }, this);\n    } else if (this.audioTrack) {\n      timelineStartPts = this.audioTrack.timelineStartInfo.pts;\n      audioProperties.forEach(function (prop) {\n        event.info[prop] = this.audioTrack[prop];\n      }, this);\n    }\n\n    if (this.videoTrack || this.audioTrack) {\n      if (this.pendingTracks.length === 1) {\n        event.type = this.pendingTracks[0].type;\n      } else {\n        event.type = 'combined';\n      }\n\n      this.emittedTracks += this.pendingTracks.length;\n      initSegment = mp4Generator.initSegment(this.pendingTracks); // Create a new typed array to hold the init segment\n\n      event.initSegment = new Uint8Array(initSegment.byteLength); // Create an init segment containing a moov\n      // and track definitions\n\n      event.initSegment.set(initSegment); // Create a new typed array to hold the moof+mdats\n\n      event.data = new Uint8Array(this.pendingBytes); // Append each moof+mdat (one per track) together\n\n      for (i = 0; i < this.pendingBoxes.length; i++) {\n        event.data.set(this.pendingBoxes[i], offset);\n        offset += this.pendingBoxes[i].byteLength;\n      } // Translate caption PTS times into second offsets to match the\n      // video timeline for the segment, and add track info\n\n\n      for (i = 0; i < this.pendingCaptions.length; i++) {\n        caption = this.pendingCaptions[i];\n        caption.startTime = clock.metadataTsToSeconds(caption.startPts, timelineStartPts, this.keepOriginalTimestamps);\n        caption.endTime = clock.metadataTsToSeconds(caption.endPts, timelineStartPts, this.keepOriginalTimestamps);\n        event.captionStreams[caption.stream] = true;\n        event.captions.push(caption);\n      } // Translate ID3 frame PTS times into second offsets to match the\n      // video timeline for the segment\n\n\n      for (i = 0; i < this.pendingMetadata.length; i++) {\n        id3 = this.pendingMetadata[i];\n        id3.cueTime = clock.metadataTsToSeconds(id3.pts, timelineStartPts, this.keepOriginalTimestamps);\n        event.metadata.push(id3);\n      } // We add this to every single emitted segment even though we only need\n      // it for the first\n\n\n      event.metadata.dispatchType = this.metadataStream.dispatchType; // Reset stream state\n\n      this.pendingTracks.length = 0;\n      this.videoTrack = null;\n      this.pendingBoxes.length = 0;\n      this.pendingCaptions.length = 0;\n      this.pendingBytes = 0;\n      this.pendingMetadata.length = 0; // Emit the built segment\n      // We include captions and ID3 tags for backwards compatibility,\n      // ideally we should send only video and audio in the data event\n\n      this.trigger('data', event); // Emit each caption to the outside world\n      // Ideally, this would happen immediately on parsing captions,\n      // but we need to ensure that video data is sent back first\n      // so that caption timing can be adjusted to match video timing\n\n      for (i = 0; i < event.captions.length; i++) {\n        caption = event.captions[i];\n        this.trigger('caption', caption);\n      } // Emit each id3 tag to the outside world\n      // Ideally, this would happen immediately on parsing the tag,\n      // but we need to ensure that video data is sent back first\n      // so that ID3 frame timing can be adjusted to match video timing\n\n\n      for (i = 0; i < event.metadata.length; i++) {\n        id3 = event.metadata[i];\n        this.trigger('id3Frame', id3);\n      }\n    } // Only emit `done` if all tracks have been flushed and emitted\n\n\n    if (this.emittedTracks >= this.numberOfTracks) {\n      this.trigger('done');\n      this.emittedTracks = 0;\n    }\n  };\n\n  _CoalesceStream.prototype.setRemux = function (val) {\n    this.remuxTracks = val;\n  };\n  /**\n   * A Stream that expects MP2T binary data as input and produces\n   * corresponding media segments, suitable for use with Media Source\n   * Extension (MSE) implementations that support the ISO BMFF byte\n   * stream format, like Chrome.\n   */\n\n\n  _Transmuxer$1 = function Transmuxer(options) {\n    var self = this,\n        hasFlushed = true,\n        videoTrack,\n        audioTrack;\n\n    _Transmuxer$1.prototype.init.call(this);\n\n    options = options || {};\n    this.baseMediaDecodeTime = options.baseMediaDecodeTime || 0;\n    this.transmuxPipeline_ = {};\n\n    this.setupAacPipeline = function () {\n      var pipeline = {};\n      this.transmuxPipeline_ = pipeline;\n      pipeline.type = 'aac';\n      pipeline.metadataStream = new m2ts_1.MetadataStream(); // set up the parsing pipeline\n\n      pipeline.aacStream = new aac();\n      pipeline.audioTimestampRolloverStream = new m2ts_1.TimestampRolloverStream('audio');\n      pipeline.timedMetadataTimestampRolloverStream = new m2ts_1.TimestampRolloverStream('timed-metadata');\n      pipeline.adtsStream = new adts();\n      pipeline.coalesceStream = new _CoalesceStream(options, pipeline.metadataStream);\n      pipeline.headOfPipeline = pipeline.aacStream;\n      pipeline.aacStream.pipe(pipeline.audioTimestampRolloverStream).pipe(pipeline.adtsStream);\n      pipeline.aacStream.pipe(pipeline.timedMetadataTimestampRolloverStream).pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream);\n      pipeline.metadataStream.on('timestamp', function (frame) {\n        pipeline.aacStream.setTimestamp(frame.timeStamp);\n      });\n      pipeline.aacStream.on('data', function (data) {\n        if (data.type !== 'timed-metadata' && data.type !== 'audio' || pipeline.audioSegmentStream) {\n          return;\n        }\n\n        audioTrack = audioTrack || {\n          timelineStartInfo: {\n            baseMediaDecodeTime: self.baseMediaDecodeTime\n          },\n          codec: 'adts',\n          type: 'audio'\n        }; // hook up the audio segment stream to the first track with aac data\n\n        pipeline.coalesceStream.numberOfTracks++;\n        pipeline.audioSegmentStream = new _AudioSegmentStream$1(audioTrack, options);\n        pipeline.audioSegmentStream.on('log', self.getLogTrigger_('audioSegmentStream'));\n        pipeline.audioSegmentStream.on('timingInfo', self.trigger.bind(self, 'audioTimingInfo')); // Set up the final part of the audio pipeline\n\n        pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream); // emit pmt info\n\n        self.trigger('trackinfo', {\n          hasAudio: !!audioTrack,\n          hasVideo: !!videoTrack\n        });\n      }); // Re-emit any data coming from the coalesce stream to the outside world\n\n      pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data')); // Let the consumer know we have finished flushing the entire pipeline\n\n      pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));\n      addPipelineLogRetriggers(this, pipeline);\n    };\n\n    this.setupTsPipeline = function () {\n      var pipeline = {};\n      this.transmuxPipeline_ = pipeline;\n      pipeline.type = 'ts';\n      pipeline.metadataStream = new m2ts_1.MetadataStream(); // set up the parsing pipeline\n\n      pipeline.packetStream = new m2ts_1.TransportPacketStream();\n      pipeline.parseStream = new m2ts_1.TransportParseStream();\n      pipeline.elementaryStream = new m2ts_1.ElementaryStream();\n      pipeline.timestampRolloverStream = new m2ts_1.TimestampRolloverStream();\n      pipeline.adtsStream = new adts();\n      pipeline.h264Stream = new H264Stream$1();\n      pipeline.captionStream = new m2ts_1.CaptionStream(options);\n      pipeline.coalesceStream = new _CoalesceStream(options, pipeline.metadataStream);\n      pipeline.headOfPipeline = pipeline.packetStream; // disassemble MPEG2-TS packets into elementary streams\n\n      pipeline.packetStream.pipe(pipeline.parseStream).pipe(pipeline.elementaryStream).pipe(pipeline.timestampRolloverStream); // !!THIS ORDER IS IMPORTANT!!\n      // demux the streams\n\n      pipeline.timestampRolloverStream.pipe(pipeline.h264Stream);\n      pipeline.timestampRolloverStream.pipe(pipeline.adtsStream);\n      pipeline.timestampRolloverStream.pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream); // Hook up CEA-608/708 caption stream\n\n      pipeline.h264Stream.pipe(pipeline.captionStream).pipe(pipeline.coalesceStream);\n      pipeline.elementaryStream.on('data', function (data) {\n        var i;\n\n        if (data.type === 'metadata') {\n          i = data.tracks.length; // scan the tracks listed in the metadata\n\n          while (i--) {\n            if (!videoTrack && data.tracks[i].type === 'video') {\n              videoTrack = data.tracks[i];\n              videoTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;\n            } else if (!audioTrack && data.tracks[i].type === 'audio') {\n              audioTrack = data.tracks[i];\n              audioTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;\n            }\n          } // hook up the video segment stream to the first track with h264 data\n\n\n          if (videoTrack && !pipeline.videoSegmentStream) {\n            pipeline.coalesceStream.numberOfTracks++;\n            pipeline.videoSegmentStream = new _VideoSegmentStream$1(videoTrack, options);\n            pipeline.videoSegmentStream.on('log', self.getLogTrigger_('videoSegmentStream'));\n            pipeline.videoSegmentStream.on('timelineStartInfo', function (timelineStartInfo) {\n              // When video emits timelineStartInfo data after a flush, we forward that\n              // info to the AudioSegmentStream, if it exists, because video timeline\n              // data takes precedence.  Do not do this if keepOriginalTimestamps is set,\n              // because this is a particularly subtle form of timestamp alteration.\n              if (audioTrack && !options.keepOriginalTimestamps) {\n                audioTrack.timelineStartInfo = timelineStartInfo; // On the first segment we trim AAC frames that exist before the\n                // very earliest DTS we have seen in video because Chrome will\n                // interpret any video track with a baseMediaDecodeTime that is\n                // non-zero as a gap.\n\n                pipeline.audioSegmentStream.setEarliestDts(timelineStartInfo.dts - self.baseMediaDecodeTime);\n              }\n            });\n            pipeline.videoSegmentStream.on('processedGopsInfo', self.trigger.bind(self, 'gopInfo'));\n            pipeline.videoSegmentStream.on('segmentTimingInfo', self.trigger.bind(self, 'videoSegmentTimingInfo'));\n            pipeline.videoSegmentStream.on('baseMediaDecodeTime', function (baseMediaDecodeTime) {\n              if (audioTrack) {\n                pipeline.audioSegmentStream.setVideoBaseMediaDecodeTime(baseMediaDecodeTime);\n              }\n            });\n            pipeline.videoSegmentStream.on('timingInfo', self.trigger.bind(self, 'videoTimingInfo')); // Set up the final part of the video pipeline\n\n            pipeline.h264Stream.pipe(pipeline.videoSegmentStream).pipe(pipeline.coalesceStream);\n          }\n\n          if (audioTrack && !pipeline.audioSegmentStream) {\n            // hook up the audio segment stream to the first track with aac data\n            pipeline.coalesceStream.numberOfTracks++;\n            pipeline.audioSegmentStream = new _AudioSegmentStream$1(audioTrack, options);\n            pipeline.audioSegmentStream.on('log', self.getLogTrigger_('audioSegmentStream'));\n            pipeline.audioSegmentStream.on('timingInfo', self.trigger.bind(self, 'audioTimingInfo'));\n            pipeline.audioSegmentStream.on('segmentTimingInfo', self.trigger.bind(self, 'audioSegmentTimingInfo')); // Set up the final part of the audio pipeline\n\n            pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream);\n          } // emit pmt info\n\n\n          self.trigger('trackinfo', {\n            hasAudio: !!audioTrack,\n            hasVideo: !!videoTrack\n          });\n        }\n      }); // Re-emit any data coming from the coalesce stream to the outside world\n\n      pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data'));\n      pipeline.coalesceStream.on('id3Frame', function (id3Frame) {\n        id3Frame.dispatchType = pipeline.metadataStream.dispatchType;\n        self.trigger('id3Frame', id3Frame);\n      });\n      pipeline.coalesceStream.on('caption', this.trigger.bind(this, 'caption')); // Let the consumer know we have finished flushing the entire pipeline\n\n      pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));\n      addPipelineLogRetriggers(this, pipeline);\n    }; // hook up the segment streams once track metadata is delivered\n\n\n    this.setBaseMediaDecodeTime = function (baseMediaDecodeTime) {\n      var pipeline = this.transmuxPipeline_;\n\n      if (!options.keepOriginalTimestamps) {\n        this.baseMediaDecodeTime = baseMediaDecodeTime;\n      }\n\n      if (audioTrack) {\n        audioTrack.timelineStartInfo.dts = undefined;\n        audioTrack.timelineStartInfo.pts = undefined;\n        trackDecodeInfo.clearDtsInfo(audioTrack);\n\n        if (pipeline.audioTimestampRolloverStream) {\n          pipeline.audioTimestampRolloverStream.discontinuity();\n        }\n      }\n\n      if (videoTrack) {\n        if (pipeline.videoSegmentStream) {\n          pipeline.videoSegmentStream.gopCache_ = [];\n        }\n\n        videoTrack.timelineStartInfo.dts = undefined;\n        videoTrack.timelineStartInfo.pts = undefined;\n        trackDecodeInfo.clearDtsInfo(videoTrack);\n        pipeline.captionStream.reset();\n      }\n\n      if (pipeline.timestampRolloverStream) {\n        pipeline.timestampRolloverStream.discontinuity();\n      }\n    };\n\n    this.setAudioAppendStart = function (timestamp) {\n      if (audioTrack) {\n        this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(timestamp);\n      }\n    };\n\n    this.setRemux = function (val) {\n      var pipeline = this.transmuxPipeline_;\n      options.remux = val;\n\n      if (pipeline && pipeline.coalesceStream) {\n        pipeline.coalesceStream.setRemux(val);\n      }\n    };\n\n    this.alignGopsWith = function (gopsToAlignWith) {\n      if (videoTrack && this.transmuxPipeline_.videoSegmentStream) {\n        this.transmuxPipeline_.videoSegmentStream.alignGopsWith(gopsToAlignWith);\n      }\n    };\n\n    this.getLogTrigger_ = function (key) {\n      var self = this;\n      return function (event) {\n        event.stream = key;\n        self.trigger('log', event);\n      };\n    }; // feed incoming data to the front of the parsing pipeline\n\n\n    this.push = function (data) {\n      if (hasFlushed) {\n        var isAac = isLikelyAacData$1(data);\n\n        if (isAac && this.transmuxPipeline_.type !== 'aac') {\n          this.setupAacPipeline();\n        } else if (!isAac && this.transmuxPipeline_.type !== 'ts') {\n          this.setupTsPipeline();\n        }\n\n        hasFlushed = false;\n      }\n\n      this.transmuxPipeline_.headOfPipeline.push(data);\n    }; // flush any buffered data\n\n\n    this.flush = function () {\n      hasFlushed = true; // Start at the top of the pipeline and flush all pending work\n\n      this.transmuxPipeline_.headOfPipeline.flush();\n    };\n\n    this.endTimeline = function () {\n      this.transmuxPipeline_.headOfPipeline.endTimeline();\n    };\n\n    this.reset = function () {\n      if (this.transmuxPipeline_.headOfPipeline) {\n        this.transmuxPipeline_.headOfPipeline.reset();\n      }\n    }; // Caption data has to be reset when seeking outside buffered range\n\n\n    this.resetCaptions = function () {\n      if (this.transmuxPipeline_.captionStream) {\n        this.transmuxPipeline_.captionStream.reset();\n      }\n    };\n  };\n\n  _Transmuxer$1.prototype = new stream();\n  var transmuxer$2 = {\n    Transmuxer: _Transmuxer$1,\n    VideoSegmentStream: _VideoSegmentStream$1,\n    AudioSegmentStream: _AudioSegmentStream$1,\n    AUDIO_PROPERTIES: audioProperties,\n    VIDEO_PROPERTIES: videoProperties,\n    // exported for testing\n    generateSegmentTimingInfo: generateSegmentTimingInfo\n  };\n  var discardEmulationPreventionBytes = captionPacketParser.discardEmulationPreventionBytes;\n  var CaptionStream = captionStream.CaptionStream;\n  /**\n    * Maps an offset in the mdat to a sample based on the the size of the samples.\n    * Assumes that `parseSamples` has been called first.\n    *\n    * @param {Number} offset - The offset into the mdat\n    * @param {Object[]} samples - An array of samples, parsed using `parseSamples`\n    * @return {?Object} The matching sample, or null if no match was found.\n    *\n    * @see ISO-BMFF-12/2015, Section 8.8.8\n   **/\n\n  var mapToSample = function mapToSample(offset, samples) {\n    var approximateOffset = offset;\n\n    for (var i = 0; i < samples.length; i++) {\n      var sample = samples[i];\n\n      if (approximateOffset < sample.size) {\n        return sample;\n      }\n\n      approximateOffset -= sample.size;\n    }\n\n    return null;\n  };\n  /**\n    * Finds SEI nal units contained in a Media Data Box.\n    * Assumes that `parseSamples` has been called first.\n    *\n    * @param {Uint8Array} avcStream - The bytes of the mdat\n    * @param {Object[]} samples - The samples parsed out by `parseSamples`\n    * @param {Number} trackId - The trackId of this video track\n    * @return {Object[]} seiNals - the parsed SEI NALUs found.\n    *   The contents of the seiNal should match what is expected by\n    *   CaptionStream.push (nalUnitType, size, data, escapedRBSP, pts, dts)\n    *\n    * @see ISO-BMFF-12/2015, Section 8.1.1\n    * @see Rec. ITU-T H.264, 7.3.2.3.1\n   **/\n\n\n  var findSeiNals = function findSeiNals(avcStream, samples, trackId) {\n    var avcView = new DataView(avcStream.buffer, avcStream.byteOffset, avcStream.byteLength),\n        result = {\n      logs: [],\n      seiNals: []\n    },\n        seiNal,\n        i,\n        length,\n        lastMatchedSample;\n\n    for (i = 0; i + 4 < avcStream.length; i += length) {\n      length = avcView.getUint32(i);\n      i += 4; // Bail if this doesn't appear to be an H264 stream\n\n      if (length <= 0) {\n        continue;\n      }\n\n      switch (avcStream[i] & 0x1F) {\n        case 0x06:\n          var data = avcStream.subarray(i + 1, i + 1 + length);\n          var matchingSample = mapToSample(i, samples);\n          seiNal = {\n            nalUnitType: 'sei_rbsp',\n            size: length,\n            data: data,\n            escapedRBSP: discardEmulationPreventionBytes(data),\n            trackId: trackId\n          };\n\n          if (matchingSample) {\n            seiNal.pts = matchingSample.pts;\n            seiNal.dts = matchingSample.dts;\n            lastMatchedSample = matchingSample;\n          } else if (lastMatchedSample) {\n            // If a matching sample cannot be found, use the last\n            // sample's values as they should be as close as possible\n            seiNal.pts = lastMatchedSample.pts;\n            seiNal.dts = lastMatchedSample.dts;\n          } else {\n            result.logs.push({\n              level: 'warn',\n              message: 'We\\'ve encountered a nal unit without data at ' + i + ' for trackId ' + trackId + '. See mux.js#223.'\n            });\n            break;\n          }\n\n          result.seiNals.push(seiNal);\n          break;\n      }\n    }\n\n    return result;\n  };\n  /**\n    * Parses sample information out of Track Run Boxes and calculates\n    * the absolute presentation and decode timestamps of each sample.\n    *\n    * @param {Array<Uint8Array>} truns - The Trun Run boxes to be parsed\n    * @param {Number|BigInt} baseMediaDecodeTime - base media decode time from tfdt\n        @see ISO-BMFF-12/2015, Section 8.8.12\n    * @param {Object} tfhd - The parsed Track Fragment Header\n    *   @see inspect.parseTfhd\n    * @return {Object[]} the parsed samples\n    *\n    * @see ISO-BMFF-12/2015, Section 8.8.8\n   **/\n\n\n  var parseSamples = function parseSamples(truns, baseMediaDecodeTime, tfhd) {\n    var currentDts = baseMediaDecodeTime;\n    var defaultSampleDuration = tfhd.defaultSampleDuration || 0;\n    var defaultSampleSize = tfhd.defaultSampleSize || 0;\n    var trackId = tfhd.trackId;\n    var allSamples = [];\n    truns.forEach(function (trun) {\n      // Note: We currently do not parse the sample table as well\n      // as the trun. It's possible some sources will require this.\n      // moov > trak > mdia > minf > stbl\n      var trackRun = parseTrun(trun);\n      var samples = trackRun.samples;\n      samples.forEach(function (sample) {\n        if (sample.duration === undefined) {\n          sample.duration = defaultSampleDuration;\n        }\n\n        if (sample.size === undefined) {\n          sample.size = defaultSampleSize;\n        }\n\n        sample.trackId = trackId;\n        sample.dts = currentDts;\n\n        if (sample.compositionTimeOffset === undefined) {\n          sample.compositionTimeOffset = 0;\n        }\n\n        if (typeof currentDts === 'bigint') {\n          sample.pts = currentDts + window__default['default'].BigInt(sample.compositionTimeOffset);\n          currentDts += window__default['default'].BigInt(sample.duration);\n        } else {\n          sample.pts = currentDts + sample.compositionTimeOffset;\n          currentDts += sample.duration;\n        }\n      });\n      allSamples = allSamples.concat(samples);\n    });\n    return allSamples;\n  };\n  /**\n    * Parses out caption nals from an FMP4 segment's video tracks.\n    *\n    * @param {Uint8Array} segment - The bytes of a single segment\n    * @param {Number} videoTrackId - The trackId of a video track in the segment\n    * @return {Object.<Number, Object[]>} A mapping of video trackId to\n    *   a list of seiNals found in that track\n   **/\n\n\n  var parseCaptionNals = function parseCaptionNals(segment, videoTrackId) {\n    // To get the samples\n    var trafs = findBox_1(segment, ['moof', 'traf']); // To get SEI NAL units\n\n    var mdats = findBox_1(segment, ['mdat']);\n    var captionNals = {};\n    var mdatTrafPairs = []; // Pair up each traf with a mdat as moofs and mdats are in pairs\n\n    mdats.forEach(function (mdat, index) {\n      var matchingTraf = trafs[index];\n      mdatTrafPairs.push({\n        mdat: mdat,\n        traf: matchingTraf\n      });\n    });\n    mdatTrafPairs.forEach(function (pair) {\n      var mdat = pair.mdat;\n      var traf = pair.traf;\n      var tfhd = findBox_1(traf, ['tfhd']); // Exactly 1 tfhd per traf\n\n      var headerInfo = parseTfhd(tfhd[0]);\n      var trackId = headerInfo.trackId;\n      var tfdt = findBox_1(traf, ['tfdt']); // Either 0 or 1 tfdt per traf\n\n      var baseMediaDecodeTime = tfdt.length > 0 ? parseTfdt(tfdt[0]).baseMediaDecodeTime : 0;\n      var truns = findBox_1(traf, ['trun']);\n      var samples;\n      var result; // Only parse video data for the chosen video track\n\n      if (videoTrackId === trackId && truns.length > 0) {\n        samples = parseSamples(truns, baseMediaDecodeTime, headerInfo);\n        result = findSeiNals(mdat, samples, trackId);\n\n        if (!captionNals[trackId]) {\n          captionNals[trackId] = {\n            seiNals: [],\n            logs: []\n          };\n        }\n\n        captionNals[trackId].seiNals = captionNals[trackId].seiNals.concat(result.seiNals);\n        captionNals[trackId].logs = captionNals[trackId].logs.concat(result.logs);\n      }\n    });\n    return captionNals;\n  };\n  /**\n    * Parses out inband captions from an MP4 container and returns\n    * caption objects that can be used by WebVTT and the TextTrack API.\n    * @see https://developer.mozilla.org/en-US/docs/Web/API/VTTCue\n    * @see https://developer.mozilla.org/en-US/docs/Web/API/TextTrack\n    * Assumes that `probe.getVideoTrackIds` and `probe.timescale` have been called first\n    *\n    * @param {Uint8Array} segment - The fmp4 segment containing embedded captions\n    * @param {Number} trackId - The id of the video track to parse\n    * @param {Number} timescale - The timescale for the video track from the init segment\n    *\n    * @return {?Object[]} parsedCaptions - A list of captions or null if no video tracks\n    * @return {Number} parsedCaptions[].startTime - The time to show the caption in seconds\n    * @return {Number} parsedCaptions[].endTime - The time to stop showing the caption in seconds\n    * @return {String} parsedCaptions[].text - The visible content of the caption\n   **/\n\n\n  var parseEmbeddedCaptions = function parseEmbeddedCaptions(segment, trackId, timescale) {\n    var captionNals; // the ISO-BMFF spec says that trackId can't be zero, but there's some broken content out there\n\n    if (trackId === null) {\n      return null;\n    }\n\n    captionNals = parseCaptionNals(segment, trackId);\n    var trackNals = captionNals[trackId] || {};\n    return {\n      seiNals: trackNals.seiNals,\n      logs: trackNals.logs,\n      timescale: timescale\n    };\n  };\n  /**\n    * Converts SEI NALUs into captions that can be used by video.js\n   **/\n\n\n  var CaptionParser = function CaptionParser() {\n    var isInitialized = false;\n    var captionStream; // Stores segments seen before trackId and timescale are set\n\n    var segmentCache; // Stores video track ID of the track being parsed\n\n    var trackId; // Stores the timescale of the track being parsed\n\n    var timescale; // Stores captions parsed so far\n\n    var parsedCaptions; // Stores whether we are receiving partial data or not\n\n    var parsingPartial;\n    /**\n      * A method to indicate whether a CaptionParser has been initalized\n      * @returns {Boolean}\n     **/\n\n    this.isInitialized = function () {\n      return isInitialized;\n    };\n    /**\n      * Initializes the underlying CaptionStream, SEI NAL parsing\n      * and management, and caption collection\n     **/\n\n\n    this.init = function (options) {\n      captionStream = new CaptionStream();\n      isInitialized = true;\n      parsingPartial = options ? options.isPartial : false; // Collect dispatched captions\n\n      captionStream.on('data', function (event) {\n        // Convert to seconds in the source's timescale\n        event.startTime = event.startPts / timescale;\n        event.endTime = event.endPts / timescale;\n        parsedCaptions.captions.push(event);\n        parsedCaptions.captionStreams[event.stream] = true;\n      });\n      captionStream.on('log', function (log) {\n        parsedCaptions.logs.push(log);\n      });\n    };\n    /**\n      * Determines if a new video track will be selected\n      * or if the timescale changed\n      * @return {Boolean}\n     **/\n\n\n    this.isNewInit = function (videoTrackIds, timescales) {\n      if (videoTrackIds && videoTrackIds.length === 0 || timescales && typeof timescales === 'object' && Object.keys(timescales).length === 0) {\n        return false;\n      }\n\n      return trackId !== videoTrackIds[0] || timescale !== timescales[trackId];\n    };\n    /**\n      * Parses out SEI captions and interacts with underlying\n      * CaptionStream to return dispatched captions\n      *\n      * @param {Uint8Array} segment - The fmp4 segment containing embedded captions\n      * @param {Number[]} videoTrackIds - A list of video tracks found in the init segment\n      * @param {Object.<Number, Number>} timescales - The timescales found in the init segment\n      * @see parseEmbeddedCaptions\n      * @see m2ts/caption-stream.js\n     **/\n\n\n    this.parse = function (segment, videoTrackIds, timescales) {\n      var parsedData;\n\n      if (!this.isInitialized()) {\n        return null; // This is not likely to be a video segment\n      } else if (!videoTrackIds || !timescales) {\n        return null;\n      } else if (this.isNewInit(videoTrackIds, timescales)) {\n        // Use the first video track only as there is no\n        // mechanism to switch to other video tracks\n        trackId = videoTrackIds[0];\n        timescale = timescales[trackId]; // If an init segment has not been seen yet, hold onto segment\n        // data until we have one.\n        // the ISO-BMFF spec says that trackId can't be zero, but there's some broken content out there\n      } else if (trackId === null || !timescale) {\n        segmentCache.push(segment);\n        return null;\n      } // Now that a timescale and trackId is set, parse cached segments\n\n\n      while (segmentCache.length > 0) {\n        var cachedSegment = segmentCache.shift();\n        this.parse(cachedSegment, videoTrackIds, timescales);\n      }\n\n      parsedData = parseEmbeddedCaptions(segment, trackId, timescale);\n\n      if (parsedData && parsedData.logs) {\n        parsedCaptions.logs = parsedCaptions.logs.concat(parsedData.logs);\n      }\n\n      if (parsedData === null || !parsedData.seiNals) {\n        if (parsedCaptions.logs.length) {\n          return {\n            logs: parsedCaptions.logs,\n            captions: [],\n            captionStreams: []\n          };\n        }\n\n        return null;\n      }\n\n      this.pushNals(parsedData.seiNals); // Force the parsed captions to be dispatched\n\n      this.flushStream();\n      return parsedCaptions;\n    };\n    /**\n      * Pushes SEI NALUs onto CaptionStream\n      * @param {Object[]} nals - A list of SEI nals parsed using `parseCaptionNals`\n      * Assumes that `parseCaptionNals` has been called first\n      * @see m2ts/caption-stream.js\n      **/\n\n\n    this.pushNals = function (nals) {\n      if (!this.isInitialized() || !nals || nals.length === 0) {\n        return null;\n      }\n\n      nals.forEach(function (nal) {\n        captionStream.push(nal);\n      });\n    };\n    /**\n      * Flushes underlying CaptionStream to dispatch processed, displayable captions\n      * @see m2ts/caption-stream.js\n     **/\n\n\n    this.flushStream = function () {\n      if (!this.isInitialized()) {\n        return null;\n      }\n\n      if (!parsingPartial) {\n        captionStream.flush();\n      } else {\n        captionStream.partialFlush();\n      }\n    };\n    /**\n      * Reset caption buckets for new data\n     **/\n\n\n    this.clearParsedCaptions = function () {\n      parsedCaptions.captions = [];\n      parsedCaptions.captionStreams = {};\n      parsedCaptions.logs = [];\n    };\n    /**\n      * Resets underlying CaptionStream\n      * @see m2ts/caption-stream.js\n     **/\n\n\n    this.resetCaptionStream = function () {\n      if (!this.isInitialized()) {\n        return null;\n      }\n\n      captionStream.reset();\n    };\n    /**\n      * Convenience method to clear all captions flushed from the\n      * CaptionStream and still being parsed\n      * @see m2ts/caption-stream.js\n     **/\n\n\n    this.clearAllCaptions = function () {\n      this.clearParsedCaptions();\n      this.resetCaptionStream();\n    };\n    /**\n      * Reset caption parser\n     **/\n\n\n    this.reset = function () {\n      segmentCache = [];\n      trackId = null;\n      timescale = null;\n\n      if (!parsedCaptions) {\n        parsedCaptions = {\n          captions: [],\n          // CC1, CC2, CC3, CC4\n          captionStreams: {},\n          logs: []\n        };\n      } else {\n        this.clearParsedCaptions();\n      }\n\n      this.resetCaptionStream();\n    };\n\n    this.reset();\n  };\n\n  var captionParser = CaptionParser;\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n\n  var mp4 = {\n    generator: mp4Generator,\n    probe: probe$2,\n    Transmuxer: transmuxer$2.Transmuxer,\n    AudioSegmentStream: transmuxer$2.AudioSegmentStream,\n    VideoSegmentStream: transmuxer$2.VideoSegmentStream,\n    CaptionParser: captionParser\n  };\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   *\n   * An object that stores the bytes of an FLV tag and methods for\n   * querying and manipulating that data.\n   * @see http://download.macromedia.com/f4v/video_file_format_spec_v10_1.pdf\n   */\n\n  var _FlvTag; // (type:uint, extraData:Boolean = false) extends ByteArray\n\n\n  _FlvTag = function FlvTag(type, extraData) {\n    var // Counter if this is a metadata tag, nal start marker if this is a video\n    // tag. unused if this is an audio tag\n    adHoc = 0,\n        // :uint\n    // The default size is 16kb but this is not enough to hold iframe\n    // data and the resizing algorithm costs a bit so we create a larger\n    // starting buffer for video tags\n    bufferStartSize = 16384,\n        // checks whether the FLV tag has enough capacity to accept the proposed\n    // write and re-allocates the internal buffers if necessary\n    prepareWrite = function prepareWrite(flv, count) {\n      var bytes,\n          minLength = flv.position + count;\n\n      if (minLength < flv.bytes.byteLength) {\n        // there's enough capacity so do nothing\n        return;\n      } // allocate a new buffer and copy over the data that will not be modified\n\n\n      bytes = new Uint8Array(minLength * 2);\n      bytes.set(flv.bytes.subarray(0, flv.position), 0);\n      flv.bytes = bytes;\n      flv.view = new DataView(flv.bytes.buffer);\n    },\n        // commonly used metadata properties\n    widthBytes = _FlvTag.widthBytes || new Uint8Array('width'.length),\n        heightBytes = _FlvTag.heightBytes || new Uint8Array('height'.length),\n        videocodecidBytes = _FlvTag.videocodecidBytes || new Uint8Array('videocodecid'.length),\n        i;\n\n    if (!_FlvTag.widthBytes) {\n      // calculating the bytes of common metadata names ahead of time makes the\n      // corresponding writes faster because we don't have to loop over the\n      // characters\n      // re-test with test/perf.html if you're planning on changing this\n      for (i = 0; i < 'width'.length; i++) {\n        widthBytes[i] = 'width'.charCodeAt(i);\n      }\n\n      for (i = 0; i < 'height'.length; i++) {\n        heightBytes[i] = 'height'.charCodeAt(i);\n      }\n\n      for (i = 0; i < 'videocodecid'.length; i++) {\n        videocodecidBytes[i] = 'videocodecid'.charCodeAt(i);\n      }\n\n      _FlvTag.widthBytes = widthBytes;\n      _FlvTag.heightBytes = heightBytes;\n      _FlvTag.videocodecidBytes = videocodecidBytes;\n    }\n\n    this.keyFrame = false; // :Boolean\n\n    switch (type) {\n      case _FlvTag.VIDEO_TAG:\n        this.length = 16; // Start the buffer at 256k\n\n        bufferStartSize *= 6;\n        break;\n\n      case _FlvTag.AUDIO_TAG:\n        this.length = 13;\n        this.keyFrame = true;\n        break;\n\n      case _FlvTag.METADATA_TAG:\n        this.length = 29;\n        this.keyFrame = true;\n        break;\n\n      default:\n        throw new Error('Unknown FLV tag type');\n    }\n\n    this.bytes = new Uint8Array(bufferStartSize);\n    this.view = new DataView(this.bytes.buffer);\n    this.bytes[0] = type;\n    this.position = this.length;\n    this.keyFrame = extraData; // Defaults to false\n    // presentation timestamp\n\n    this.pts = 0; // decoder timestamp\n\n    this.dts = 0; // ByteArray#writeBytes(bytes:ByteArray, offset:uint = 0, length:uint = 0)\n\n    this.writeBytes = function (bytes, offset, length) {\n      var start = offset || 0,\n          end;\n      length = length || bytes.byteLength;\n      end = start + length;\n      prepareWrite(this, length);\n      this.bytes.set(bytes.subarray(start, end), this.position);\n      this.position += length;\n      this.length = Math.max(this.length, this.position);\n    }; // ByteArray#writeByte(value:int):void\n\n\n    this.writeByte = function (byte) {\n      prepareWrite(this, 1);\n      this.bytes[this.position] = byte;\n      this.position++;\n      this.length = Math.max(this.length, this.position);\n    }; // ByteArray#writeShort(value:int):void\n\n\n    this.writeShort = function (short) {\n      prepareWrite(this, 2);\n      this.view.setUint16(this.position, short);\n      this.position += 2;\n      this.length = Math.max(this.length, this.position);\n    }; // Negative index into array\n    // (pos:uint):int\n\n\n    this.negIndex = function (pos) {\n      return this.bytes[this.length - pos];\n    }; // The functions below ONLY work when this[0] == VIDEO_TAG.\n    // We are not going to check for that because we dont want the overhead\n    // (nal:ByteArray = null):int\n\n\n    this.nalUnitSize = function () {\n      if (adHoc === 0) {\n        return 0;\n      }\n\n      return this.length - (adHoc + 4);\n    };\n\n    this.startNalUnit = function () {\n      // remember position and add 4 bytes\n      if (adHoc > 0) {\n        throw new Error('Attempted to create new NAL wihout closing the old one');\n      } // reserve 4 bytes for nal unit size\n\n\n      adHoc = this.length;\n      this.length += 4;\n      this.position = this.length;\n    }; // (nal:ByteArray = null):void\n\n\n    this.endNalUnit = function (nalContainer) {\n      var nalStart, // :uint\n      nalLength; // :uint\n      // Rewind to the marker and write the size\n\n      if (this.length === adHoc + 4) {\n        // we started a nal unit, but didnt write one, so roll back the 4 byte size value\n        this.length -= 4;\n      } else if (adHoc > 0) {\n        nalStart = adHoc + 4;\n        nalLength = this.length - nalStart;\n        this.position = adHoc;\n        this.view.setUint32(this.position, nalLength);\n        this.position = this.length;\n\n        if (nalContainer) {\n          // Add the tag to the NAL unit\n          nalContainer.push(this.bytes.subarray(nalStart, nalStart + nalLength));\n        }\n      }\n\n      adHoc = 0;\n    };\n    /**\n     * Write out a 64-bit floating point valued metadata property. This method is\n     * called frequently during a typical parse and needs to be fast.\n     */\n    // (key:String, val:Number):void\n\n\n    this.writeMetaDataDouble = function (key, val) {\n      var i;\n      prepareWrite(this, 2 + key.length + 9); // write size of property name\n\n      this.view.setUint16(this.position, key.length);\n      this.position += 2; // this next part looks terrible but it improves parser throughput by\n      // 10kB/s in my testing\n      // write property name\n\n      if (key === 'width') {\n        this.bytes.set(widthBytes, this.position);\n        this.position += 5;\n      } else if (key === 'height') {\n        this.bytes.set(heightBytes, this.position);\n        this.position += 6;\n      } else if (key === 'videocodecid') {\n        this.bytes.set(videocodecidBytes, this.position);\n        this.position += 12;\n      } else {\n        for (i = 0; i < key.length; i++) {\n          this.bytes[this.position] = key.charCodeAt(i);\n          this.position++;\n        }\n      } // skip null byte\n\n\n      this.position++; // write property value\n\n      this.view.setFloat64(this.position, val);\n      this.position += 8; // update flv tag length\n\n      this.length = Math.max(this.length, this.position);\n      ++adHoc;\n    }; // (key:String, val:Boolean):void\n\n\n    this.writeMetaDataBoolean = function (key, val) {\n      var i;\n      prepareWrite(this, 2);\n      this.view.setUint16(this.position, key.length);\n      this.position += 2;\n\n      for (i = 0; i < key.length; i++) {\n        // if key.charCodeAt(i) >= 255, handle error\n        prepareWrite(this, 1);\n        this.bytes[this.position] = key.charCodeAt(i);\n        this.position++;\n      }\n\n      prepareWrite(this, 2);\n      this.view.setUint8(this.position, 0x01);\n      this.position++;\n      this.view.setUint8(this.position, val ? 0x01 : 0x00);\n      this.position++;\n      this.length = Math.max(this.length, this.position);\n      ++adHoc;\n    }; // ():ByteArray\n\n\n    this.finalize = function () {\n      var dtsDelta, // :int\n      len; // :int\n\n      switch (this.bytes[0]) {\n        // Video Data\n        case _FlvTag.VIDEO_TAG:\n          // We only support AVC, 1 = key frame (for AVC, a seekable\n          // frame), 2 = inter frame (for AVC, a non-seekable frame)\n          this.bytes[11] = (this.keyFrame || extraData ? 0x10 : 0x20) | 0x07;\n          this.bytes[12] = extraData ? 0x00 : 0x01;\n          dtsDelta = this.pts - this.dts;\n          this.bytes[13] = (dtsDelta & 0x00FF0000) >>> 16;\n          this.bytes[14] = (dtsDelta & 0x0000FF00) >>> 8;\n          this.bytes[15] = (dtsDelta & 0x000000FF) >>> 0;\n          break;\n\n        case _FlvTag.AUDIO_TAG:\n          this.bytes[11] = 0xAF; // 44 kHz, 16-bit stereo\n\n          this.bytes[12] = extraData ? 0x00 : 0x01;\n          break;\n\n        case _FlvTag.METADATA_TAG:\n          this.position = 11;\n          this.view.setUint8(this.position, 0x02); // String type\n\n          this.position++;\n          this.view.setUint16(this.position, 0x0A); // 10 Bytes\n\n          this.position += 2; // set \"onMetaData\"\n\n          this.bytes.set([0x6f, 0x6e, 0x4d, 0x65, 0x74, 0x61, 0x44, 0x61, 0x74, 0x61], this.position);\n          this.position += 10;\n          this.bytes[this.position] = 0x08; // Array type\n\n          this.position++;\n          this.view.setUint32(this.position, adHoc);\n          this.position = this.length;\n          this.bytes.set([0, 0, 9], this.position);\n          this.position += 3; // End Data Tag\n\n          this.length = this.position;\n          break;\n      }\n\n      len = this.length - 11; // write the DataSize field\n\n      this.bytes[1] = (len & 0x00FF0000) >>> 16;\n      this.bytes[2] = (len & 0x0000FF00) >>> 8;\n      this.bytes[3] = (len & 0x000000FF) >>> 0; // write the Timestamp\n\n      this.bytes[4] = (this.dts & 0x00FF0000) >>> 16;\n      this.bytes[5] = (this.dts & 0x0000FF00) >>> 8;\n      this.bytes[6] = (this.dts & 0x000000FF) >>> 0;\n      this.bytes[7] = (this.dts & 0xFF000000) >>> 24; // write the StreamID\n\n      this.bytes[8] = 0;\n      this.bytes[9] = 0;\n      this.bytes[10] = 0; // Sometimes we're at the end of the view and have one slot to write a\n      // uint32, so, prepareWrite of count 4, since, view is uint8\n\n      prepareWrite(this, 4);\n      this.view.setUint32(this.length, this.length);\n      this.length += 4;\n      this.position += 4; // trim down the byte buffer to what is actually being used\n\n      this.bytes = this.bytes.subarray(0, this.length);\n      this.frameTime = _FlvTag.frameTime(this.bytes); // if bytes.bytelength isn't equal to this.length, handle error\n\n      return this;\n    };\n  };\n\n  _FlvTag.AUDIO_TAG = 0x08; // == 8, :uint\n\n  _FlvTag.VIDEO_TAG = 0x09; // == 9, :uint\n\n  _FlvTag.METADATA_TAG = 0x12; // == 18, :uint\n  // (tag:ByteArray):Boolean {\n\n  _FlvTag.isAudioFrame = function (tag) {\n    return _FlvTag.AUDIO_TAG === tag[0];\n  }; // (tag:ByteArray):Boolean {\n\n\n  _FlvTag.isVideoFrame = function (tag) {\n    return _FlvTag.VIDEO_TAG === tag[0];\n  }; // (tag:ByteArray):Boolean {\n\n\n  _FlvTag.isMetaData = function (tag) {\n    return _FlvTag.METADATA_TAG === tag[0];\n  }; // (tag:ByteArray):Boolean {\n\n\n  _FlvTag.isKeyFrame = function (tag) {\n    if (_FlvTag.isVideoFrame(tag)) {\n      return tag[11] === 0x17;\n    }\n\n    if (_FlvTag.isAudioFrame(tag)) {\n      return true;\n    }\n\n    if (_FlvTag.isMetaData(tag)) {\n      return true;\n    }\n\n    return false;\n  }; // (tag:ByteArray):uint {\n\n\n  _FlvTag.frameTime = function (tag) {\n    var pts = tag[4] << 16; // :uint\n\n    pts |= tag[5] << 8;\n    pts |= tag[6] << 0;\n    pts |= tag[7] << 24;\n    return pts;\n  };\n\n  var flvTag = _FlvTag;\n  /**\n   * The final stage of the transmuxer that emits the flv tags\n   * for audio, video, and metadata. Also tranlates in time and\n   * outputs caption data and id3 cues.\n   */\n\n  var CoalesceStream = function CoalesceStream(options) {\n    // Number of Tracks per output segment\n    // If greater than 1, we combine multiple\n    // tracks into a single segment\n    this.numberOfTracks = 0;\n    this.metadataStream = options.metadataStream;\n    this.videoTags = [];\n    this.audioTags = [];\n    this.videoTrack = null;\n    this.audioTrack = null;\n    this.pendingCaptions = [];\n    this.pendingMetadata = [];\n    this.pendingTracks = 0;\n    this.processedTracks = 0;\n    CoalesceStream.prototype.init.call(this); // Take output from multiple\n\n    this.push = function (output) {\n      // buffer incoming captions until the associated video segment\n      // finishes\n      if (output.text) {\n        return this.pendingCaptions.push(output);\n      } // buffer incoming id3 tags until the final flush\n\n\n      if (output.frames) {\n        return this.pendingMetadata.push(output);\n      }\n\n      if (output.track.type === 'video') {\n        this.videoTrack = output.track;\n        this.videoTags = output.tags;\n        this.pendingTracks++;\n      }\n\n      if (output.track.type === 'audio') {\n        this.audioTrack = output.track;\n        this.audioTags = output.tags;\n        this.pendingTracks++;\n      }\n    };\n  };\n\n  CoalesceStream.prototype = new stream();\n\n  CoalesceStream.prototype.flush = function (flushSource) {\n    var id3,\n        caption,\n        i,\n        timelineStartPts,\n        event = {\n      tags: {},\n      captions: [],\n      captionStreams: {},\n      metadata: []\n    };\n\n    if (this.pendingTracks < this.numberOfTracks) {\n      if (flushSource !== 'VideoSegmentStream' && flushSource !== 'AudioSegmentStream') {\n        // Return because we haven't received a flush from a data-generating\n        // portion of the segment (meaning that we have only recieved meta-data\n        // or captions.)\n        return;\n      } else if (this.pendingTracks === 0) {\n        // In the case where we receive a flush without any data having been\n        // received we consider it an emitted track for the purposes of coalescing\n        // `done` events.\n        // We do this for the case where there is an audio and video track in the\n        // segment but no audio data. (seen in several playlists with alternate\n        // audio tracks and no audio present in the main TS segments.)\n        this.processedTracks++;\n\n        if (this.processedTracks < this.numberOfTracks) {\n          return;\n        }\n      }\n    }\n\n    this.processedTracks += this.pendingTracks;\n    this.pendingTracks = 0;\n\n    if (this.processedTracks < this.numberOfTracks) {\n      return;\n    }\n\n    if (this.videoTrack) {\n      timelineStartPts = this.videoTrack.timelineStartInfo.pts;\n    } else if (this.audioTrack) {\n      timelineStartPts = this.audioTrack.timelineStartInfo.pts;\n    }\n\n    event.tags.videoTags = this.videoTags;\n    event.tags.audioTags = this.audioTags; // Translate caption PTS times into second offsets into the\n    // video timeline for the segment, and add track info\n\n    for (i = 0; i < this.pendingCaptions.length; i++) {\n      caption = this.pendingCaptions[i];\n      caption.startTime = caption.startPts - timelineStartPts;\n      caption.startTime /= 90e3;\n      caption.endTime = caption.endPts - timelineStartPts;\n      caption.endTime /= 90e3;\n      event.captionStreams[caption.stream] = true;\n      event.captions.push(caption);\n    } // Translate ID3 frame PTS times into second offsets into the\n    // video timeline for the segment\n\n\n    for (i = 0; i < this.pendingMetadata.length; i++) {\n      id3 = this.pendingMetadata[i];\n      id3.cueTime = id3.pts - timelineStartPts;\n      id3.cueTime /= 90e3;\n      event.metadata.push(id3);\n    } // We add this to every single emitted segment even though we only need\n    // it for the first\n\n\n    event.metadata.dispatchType = this.metadataStream.dispatchType; // Reset stream state\n\n    this.videoTrack = null;\n    this.audioTrack = null;\n    this.videoTags = [];\n    this.audioTags = [];\n    this.pendingCaptions.length = 0;\n    this.pendingMetadata.length = 0;\n    this.pendingTracks = 0;\n    this.processedTracks = 0; // Emit the final segment\n\n    this.trigger('data', event);\n    this.trigger('done');\n  };\n\n  var coalesceStream = CoalesceStream;\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n\n  var TagList = function TagList() {\n    var self = this;\n    this.list = [];\n\n    this.push = function (tag) {\n      this.list.push({\n        bytes: tag.bytes,\n        dts: tag.dts,\n        pts: tag.pts,\n        keyFrame: tag.keyFrame,\n        metaDataTag: tag.metaDataTag\n      });\n    };\n\n    Object.defineProperty(this, 'length', {\n      get: function get() {\n        return self.list.length;\n      }\n    });\n  };\n\n  var tagList = TagList;\n  var H264Stream = h264.H264Stream;\n\n  var _Transmuxer, _VideoSegmentStream, _AudioSegmentStream, collectTimelineInfo, metaDataTag, extraDataTag;\n  /**\n   * Store information about the start and end of the tracka and the\n   * duration for each frame/sample we process in order to calculate\n   * the baseMediaDecodeTime\n   */\n\n\n  collectTimelineInfo = function collectTimelineInfo(track, data) {\n    if (typeof data.pts === 'number') {\n      if (track.timelineStartInfo.pts === undefined) {\n        track.timelineStartInfo.pts = data.pts;\n      } else {\n        track.timelineStartInfo.pts = Math.min(track.timelineStartInfo.pts, data.pts);\n      }\n    }\n\n    if (typeof data.dts === 'number') {\n      if (track.timelineStartInfo.dts === undefined) {\n        track.timelineStartInfo.dts = data.dts;\n      } else {\n        track.timelineStartInfo.dts = Math.min(track.timelineStartInfo.dts, data.dts);\n      }\n    }\n  };\n\n  metaDataTag = function metaDataTag(track, pts) {\n    var tag = new flvTag(flvTag.METADATA_TAG); // :FlvTag\n\n    tag.dts = pts;\n    tag.pts = pts;\n    tag.writeMetaDataDouble('videocodecid', 7);\n    tag.writeMetaDataDouble('width', track.width);\n    tag.writeMetaDataDouble('height', track.height);\n    return tag;\n  };\n\n  extraDataTag = function extraDataTag(track, pts) {\n    var i,\n        tag = new flvTag(flvTag.VIDEO_TAG, true);\n    tag.dts = pts;\n    tag.pts = pts;\n    tag.writeByte(0x01); // version\n\n    tag.writeByte(track.profileIdc); // profile\n\n    tag.writeByte(track.profileCompatibility); // compatibility\n\n    tag.writeByte(track.levelIdc); // level\n\n    tag.writeByte(0xFC | 0x03); // reserved (6 bits), NULA length size - 1 (2 bits)\n\n    tag.writeByte(0xE0 | 0x01); // reserved (3 bits), num of SPS (5 bits)\n\n    tag.writeShort(track.sps[0].length); // data of SPS\n\n    tag.writeBytes(track.sps[0]); // SPS\n\n    tag.writeByte(track.pps.length); // num of PPS (will there ever be more that 1 PPS?)\n\n    for (i = 0; i < track.pps.length; ++i) {\n      tag.writeShort(track.pps[i].length); // 2 bytes for length of PPS\n\n      tag.writeBytes(track.pps[i]); // data of PPS\n    }\n\n    return tag;\n  };\n  /**\n   * Constructs a single-track, media segment from AAC data\n   * events. The output of this stream can be fed to flash.\n   */\n\n\n  _AudioSegmentStream = function AudioSegmentStream(track) {\n    var adtsFrames = [],\n        videoKeyFrames = [],\n        oldExtraData;\n\n    _AudioSegmentStream.prototype.init.call(this);\n\n    this.push = function (data) {\n      collectTimelineInfo(track, data);\n\n      if (track) {\n        track.audioobjecttype = data.audioobjecttype;\n        track.channelcount = data.channelcount;\n        track.samplerate = data.samplerate;\n        track.samplingfrequencyindex = data.samplingfrequencyindex;\n        track.samplesize = data.samplesize;\n        track.extraData = track.audioobjecttype << 11 | track.samplingfrequencyindex << 7 | track.channelcount << 3;\n      }\n\n      data.pts = Math.round(data.pts / 90);\n      data.dts = Math.round(data.dts / 90); // buffer audio data until end() is called\n\n      adtsFrames.push(data);\n    };\n\n    this.flush = function () {\n      var currentFrame,\n          adtsFrame,\n          lastMetaPts,\n          tags = new tagList(); // return early if no audio data has been observed\n\n      if (adtsFrames.length === 0) {\n        this.trigger('done', 'AudioSegmentStream');\n        return;\n      }\n\n      lastMetaPts = -Infinity;\n\n      while (adtsFrames.length) {\n        currentFrame = adtsFrames.shift(); // write out a metadata frame at every video key frame\n\n        if (videoKeyFrames.length && currentFrame.pts >= videoKeyFrames[0]) {\n          lastMetaPts = videoKeyFrames.shift();\n          this.writeMetaDataTags(tags, lastMetaPts);\n        } // also write out metadata tags every 1 second so that the decoder\n        // is re-initialized quickly after seeking into a different\n        // audio configuration.\n\n\n        if (track.extraData !== oldExtraData || currentFrame.pts - lastMetaPts >= 1000) {\n          this.writeMetaDataTags(tags, currentFrame.pts);\n          oldExtraData = track.extraData;\n          lastMetaPts = currentFrame.pts;\n        }\n\n        adtsFrame = new flvTag(flvTag.AUDIO_TAG);\n        adtsFrame.pts = currentFrame.pts;\n        adtsFrame.dts = currentFrame.dts;\n        adtsFrame.writeBytes(currentFrame.data);\n        tags.push(adtsFrame.finalize());\n      }\n\n      videoKeyFrames.length = 0;\n      oldExtraData = null;\n      this.trigger('data', {\n        track: track,\n        tags: tags.list\n      });\n      this.trigger('done', 'AudioSegmentStream');\n    };\n\n    this.writeMetaDataTags = function (tags, pts) {\n      var adtsFrame;\n      adtsFrame = new flvTag(flvTag.METADATA_TAG); // For audio, DTS is always the same as PTS. We want to set the DTS\n      // however so we can compare with video DTS to determine approximate\n      // packet order\n\n      adtsFrame.pts = pts;\n      adtsFrame.dts = pts; // AAC is always 10\n\n      adtsFrame.writeMetaDataDouble('audiocodecid', 10);\n      adtsFrame.writeMetaDataBoolean('stereo', track.channelcount === 2);\n      adtsFrame.writeMetaDataDouble('audiosamplerate', track.samplerate); // Is AAC always 16 bit?\n\n      adtsFrame.writeMetaDataDouble('audiosamplesize', 16);\n      tags.push(adtsFrame.finalize());\n      adtsFrame = new flvTag(flvTag.AUDIO_TAG, true); // For audio, DTS is always the same as PTS. We want to set the DTS\n      // however so we can compare with video DTS to determine approximate\n      // packet order\n\n      adtsFrame.pts = pts;\n      adtsFrame.dts = pts;\n      adtsFrame.view.setUint16(adtsFrame.position, track.extraData);\n      adtsFrame.position += 2;\n      adtsFrame.length = Math.max(adtsFrame.length, adtsFrame.position);\n      tags.push(adtsFrame.finalize());\n    };\n\n    this.onVideoKeyFrame = function (pts) {\n      videoKeyFrames.push(pts);\n    };\n  };\n\n  _AudioSegmentStream.prototype = new stream();\n  /**\n   * Store FlvTags for the h264 stream\n   * @param track {object} track metadata configuration\n   */\n\n  _VideoSegmentStream = function VideoSegmentStream(track) {\n    var nalUnits = [],\n        config,\n        h264Frame;\n\n    _VideoSegmentStream.prototype.init.call(this);\n\n    this.finishFrame = function (tags, frame) {\n      if (!frame) {\n        return;\n      } // Check if keyframe and the length of tags.\n      // This makes sure we write metadata on the first frame of a segment.\n\n\n      if (config && track && track.newMetadata && (frame.keyFrame || tags.length === 0)) {\n        // Push extra data on every IDR frame in case we did a stream change + seek\n        var metaTag = metaDataTag(config, frame.dts).finalize();\n        var extraTag = extraDataTag(track, frame.dts).finalize();\n        metaTag.metaDataTag = extraTag.metaDataTag = true;\n        tags.push(metaTag);\n        tags.push(extraTag);\n        track.newMetadata = false;\n        this.trigger('keyframe', frame.dts);\n      }\n\n      frame.endNalUnit();\n      tags.push(frame.finalize());\n      h264Frame = null;\n    };\n\n    this.push = function (data) {\n      collectTimelineInfo(track, data);\n      data.pts = Math.round(data.pts / 90);\n      data.dts = Math.round(data.dts / 90); // buffer video until flush() is called\n\n      nalUnits.push(data);\n    };\n\n    this.flush = function () {\n      var currentNal,\n          tags = new tagList(); // Throw away nalUnits at the start of the byte stream until we find\n      // the first AUD\n\n      while (nalUnits.length) {\n        if (nalUnits[0].nalUnitType === 'access_unit_delimiter_rbsp') {\n          break;\n        }\n\n        nalUnits.shift();\n      } // return early if no video data has been observed\n\n\n      if (nalUnits.length === 0) {\n        this.trigger('done', 'VideoSegmentStream');\n        return;\n      }\n\n      while (nalUnits.length) {\n        currentNal = nalUnits.shift(); // record the track config\n\n        if (currentNal.nalUnitType === 'seq_parameter_set_rbsp') {\n          track.newMetadata = true;\n          config = currentNal.config;\n          track.width = config.width;\n          track.height = config.height;\n          track.sps = [currentNal.data];\n          track.profileIdc = config.profileIdc;\n          track.levelIdc = config.levelIdc;\n          track.profileCompatibility = config.profileCompatibility;\n          h264Frame.endNalUnit();\n        } else if (currentNal.nalUnitType === 'pic_parameter_set_rbsp') {\n          track.newMetadata = true;\n          track.pps = [currentNal.data];\n          h264Frame.endNalUnit();\n        } else if (currentNal.nalUnitType === 'access_unit_delimiter_rbsp') {\n          if (h264Frame) {\n            this.finishFrame(tags, h264Frame);\n          }\n\n          h264Frame = new flvTag(flvTag.VIDEO_TAG);\n          h264Frame.pts = currentNal.pts;\n          h264Frame.dts = currentNal.dts;\n        } else {\n          if (currentNal.nalUnitType === 'slice_layer_without_partitioning_rbsp_idr') {\n            // the current sample is a key frame\n            h264Frame.keyFrame = true;\n          }\n\n          h264Frame.endNalUnit();\n        }\n\n        h264Frame.startNalUnit();\n        h264Frame.writeBytes(currentNal.data);\n      }\n\n      if (h264Frame) {\n        this.finishFrame(tags, h264Frame);\n      }\n\n      this.trigger('data', {\n        track: track,\n        tags: tags.list\n      }); // Continue with the flush process now\n\n      this.trigger('done', 'VideoSegmentStream');\n    };\n  };\n\n  _VideoSegmentStream.prototype = new stream();\n  /**\n   * An object that incrementally transmuxes MPEG2 Trasport Stream\n   * chunks into an FLV.\n   */\n\n  _Transmuxer = function Transmuxer(options) {\n    var self = this,\n        packetStream,\n        parseStream,\n        elementaryStream,\n        videoTimestampRolloverStream,\n        audioTimestampRolloverStream,\n        timedMetadataTimestampRolloverStream,\n        adtsStream,\n        h264Stream,\n        videoSegmentStream,\n        audioSegmentStream,\n        captionStream,\n        coalesceStream$1;\n\n    _Transmuxer.prototype.init.call(this);\n\n    options = options || {}; // expose the metadata stream\n\n    this.metadataStream = new m2ts_1.MetadataStream();\n    options.metadataStream = this.metadataStream; // set up the parsing pipeline\n\n    packetStream = new m2ts_1.TransportPacketStream();\n    parseStream = new m2ts_1.TransportParseStream();\n    elementaryStream = new m2ts_1.ElementaryStream();\n    videoTimestampRolloverStream = new m2ts_1.TimestampRolloverStream('video');\n    audioTimestampRolloverStream = new m2ts_1.TimestampRolloverStream('audio');\n    timedMetadataTimestampRolloverStream = new m2ts_1.TimestampRolloverStream('timed-metadata');\n    adtsStream = new adts();\n    h264Stream = new H264Stream();\n    coalesceStream$1 = new coalesceStream(options); // disassemble MPEG2-TS packets into elementary streams\n\n    packetStream.pipe(parseStream).pipe(elementaryStream); // !!THIS ORDER IS IMPORTANT!!\n    // demux the streams\n\n    elementaryStream.pipe(videoTimestampRolloverStream).pipe(h264Stream);\n    elementaryStream.pipe(audioTimestampRolloverStream).pipe(adtsStream);\n    elementaryStream.pipe(timedMetadataTimestampRolloverStream).pipe(this.metadataStream).pipe(coalesceStream$1); // if CEA-708 parsing is available, hook up a caption stream\n\n    captionStream = new m2ts_1.CaptionStream(options);\n    h264Stream.pipe(captionStream).pipe(coalesceStream$1); // hook up the segment streams once track metadata is delivered\n\n    elementaryStream.on('data', function (data) {\n      var i, videoTrack, audioTrack;\n\n      if (data.type === 'metadata') {\n        i = data.tracks.length; // scan the tracks listed in the metadata\n\n        while (i--) {\n          if (data.tracks[i].type === 'video') {\n            videoTrack = data.tracks[i];\n          } else if (data.tracks[i].type === 'audio') {\n            audioTrack = data.tracks[i];\n          }\n        } // hook up the video segment stream to the first track with h264 data\n\n\n        if (videoTrack && !videoSegmentStream) {\n          coalesceStream$1.numberOfTracks++;\n          videoSegmentStream = new _VideoSegmentStream(videoTrack); // Set up the final part of the video pipeline\n\n          h264Stream.pipe(videoSegmentStream).pipe(coalesceStream$1);\n        }\n\n        if (audioTrack && !audioSegmentStream) {\n          // hook up the audio segment stream to the first track with aac data\n          coalesceStream$1.numberOfTracks++;\n          audioSegmentStream = new _AudioSegmentStream(audioTrack); // Set up the final part of the audio pipeline\n\n          adtsStream.pipe(audioSegmentStream).pipe(coalesceStream$1);\n\n          if (videoSegmentStream) {\n            videoSegmentStream.on('keyframe', audioSegmentStream.onVideoKeyFrame);\n          }\n        }\n      }\n    }); // feed incoming data to the front of the parsing pipeline\n\n    this.push = function (data) {\n      packetStream.push(data);\n    }; // flush any buffered data\n\n\n    this.flush = function () {\n      // Start at the top of the pipeline and flush all pending work\n      packetStream.flush();\n    }; // Caption data has to be reset when seeking outside buffered range\n\n\n    this.resetCaptions = function () {\n      captionStream.reset();\n    }; // Re-emit any data coming from the coalesce stream to the outside world\n\n\n    coalesceStream$1.on('data', function (event) {\n      self.trigger('data', event);\n    }); // Let the consumer know we have finished flushing the entire pipeline\n\n    coalesceStream$1.on('done', function () {\n      self.trigger('done');\n    });\n  };\n\n  _Transmuxer.prototype = new stream(); // forward compatibility\n\n  var transmuxer$1 = _Transmuxer; // http://download.macromedia.com/f4v/video_file_format_spec_v10_1.pdf.\n  // Technically, this function returns the header and a metadata FLV tag\n  // if duration is greater than zero\n  // duration in seconds\n  // @return {object} the bytes of the FLV header as a Uint8Array\n\n  var getFlvHeader = function getFlvHeader(duration, audio, video) {\n    // :ByteArray {\n    var headBytes = new Uint8Array(3 + 1 + 1 + 4),\n        head = new DataView(headBytes.buffer),\n        metadata,\n        result,\n        metadataLength; // default arguments\n\n    duration = duration || 0;\n    audio = audio === undefined ? true : audio;\n    video = video === undefined ? true : video; // signature\n\n    head.setUint8(0, 0x46); // 'F'\n\n    head.setUint8(1, 0x4c); // 'L'\n\n    head.setUint8(2, 0x56); // 'V'\n    // version\n\n    head.setUint8(3, 0x01); // flags\n\n    head.setUint8(4, (audio ? 0x04 : 0x00) | (video ? 0x01 : 0x00)); // data offset, should be 9 for FLV v1\n\n    head.setUint32(5, headBytes.byteLength); // init the first FLV tag\n\n    if (duration <= 0) {\n      // no duration available so just write the first field of the first\n      // FLV tag\n      result = new Uint8Array(headBytes.byteLength + 4);\n      result.set(headBytes);\n      result.set([0, 0, 0, 0], headBytes.byteLength);\n      return result;\n    } // write out the duration metadata tag\n\n\n    metadata = new flvTag(flvTag.METADATA_TAG);\n    metadata.pts = metadata.dts = 0;\n    metadata.writeMetaDataDouble('duration', duration);\n    metadataLength = metadata.finalize().length;\n    result = new Uint8Array(headBytes.byteLength + metadataLength);\n    result.set(headBytes);\n    result.set(head.byteLength, metadataLength);\n    return result;\n  };\n\n  var flvHeader = getFlvHeader;\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n\n  var flv = {\n    tag: flvTag,\n    Transmuxer: transmuxer$1,\n    getFlvHeader: flvHeader\n  };\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n\n  var m2ts = m2ts_1;\n  var ONE_SECOND_IN_TS$1 = clock.ONE_SECOND_IN_TS;\n  /**\n   * Constructs a single-track, ISO BMFF media segment from AAC data\n   * events. The output of this stream can be fed to a SourceBuffer\n   * configured with a suitable initialization segment.\n   */\n\n  var AudioSegmentStream = function AudioSegmentStream(track, options) {\n    var adtsFrames = [],\n        sequenceNumber = 0,\n        earliestAllowedDts = 0,\n        audioAppendStartTs = 0,\n        videoBaseMediaDecodeTime = Infinity,\n        segmentStartPts = null,\n        segmentEndPts = null;\n    options = options || {};\n    AudioSegmentStream.prototype.init.call(this);\n\n    this.push = function (data) {\n      trackDecodeInfo.collectDtsInfo(track, data);\n\n      if (track) {\n        audioProperties.forEach(function (prop) {\n          track[prop] = data[prop];\n        });\n      } // buffer audio data until end() is called\n\n\n      adtsFrames.push(data);\n    };\n\n    this.setEarliestDts = function (earliestDts) {\n      earliestAllowedDts = earliestDts;\n    };\n\n    this.setVideoBaseMediaDecodeTime = function (baseMediaDecodeTime) {\n      videoBaseMediaDecodeTime = baseMediaDecodeTime;\n    };\n\n    this.setAudioAppendStart = function (timestamp) {\n      audioAppendStartTs = timestamp;\n    };\n\n    this.processFrames_ = function () {\n      var frames, moof, mdat, boxes, timingInfo; // return early if no audio data has been observed\n\n      if (adtsFrames.length === 0) {\n        return;\n      }\n\n      frames = audioFrameUtils.trimAdtsFramesByEarliestDts(adtsFrames, track, earliestAllowedDts);\n\n      if (frames.length === 0) {\n        // return early if the frames are all after the earliest allowed DTS\n        // TODO should we clear the adtsFrames?\n        return;\n      }\n\n      track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);\n      audioFrameUtils.prefixWithSilence(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime); // we have to build the index from byte locations to\n      // samples (that is, adts frames) in the audio data\n\n      track.samples = audioFrameUtils.generateSampleTable(frames); // concatenate the audio data to constuct the mdat\n\n      mdat = mp4Generator.mdat(audioFrameUtils.concatenateFrameData(frames));\n      adtsFrames = [];\n      moof = mp4Generator.moof(sequenceNumber, [track]); // bump the sequence number for next time\n\n      sequenceNumber++;\n      track.initSegment = mp4Generator.initSegment([track]); // it would be great to allocate this array up front instead of\n      // throwing away hundreds of media segment fragments\n\n      boxes = new Uint8Array(moof.byteLength + mdat.byteLength);\n      boxes.set(moof);\n      boxes.set(mdat, moof.byteLength);\n      trackDecodeInfo.clearDtsInfo(track);\n\n      if (segmentStartPts === null) {\n        segmentEndPts = segmentStartPts = frames[0].pts;\n      }\n\n      segmentEndPts += frames.length * (ONE_SECOND_IN_TS$1 * 1024 / track.samplerate);\n      timingInfo = {\n        start: segmentStartPts\n      };\n      this.trigger('timingInfo', timingInfo);\n      this.trigger('data', {\n        track: track,\n        boxes: boxes\n      });\n    };\n\n    this.flush = function () {\n      this.processFrames_(); // trigger final timing info\n\n      this.trigger('timingInfo', {\n        start: segmentStartPts,\n        end: segmentEndPts\n      });\n      this.resetTiming_();\n      this.trigger('done', 'AudioSegmentStream');\n    };\n\n    this.partialFlush = function () {\n      this.processFrames_();\n      this.trigger('partialdone', 'AudioSegmentStream');\n    };\n\n    this.endTimeline = function () {\n      this.flush();\n      this.trigger('endedtimeline', 'AudioSegmentStream');\n    };\n\n    this.resetTiming_ = function () {\n      trackDecodeInfo.clearDtsInfo(track);\n      segmentStartPts = null;\n      segmentEndPts = null;\n    };\n\n    this.reset = function () {\n      this.resetTiming_();\n      adtsFrames = [];\n      this.trigger('reset');\n    };\n  };\n\n  AudioSegmentStream.prototype = new stream();\n  var audioSegmentStream = AudioSegmentStream;\n\n  var VideoSegmentStream = function VideoSegmentStream(track, options) {\n    var sequenceNumber = 0,\n        nalUnits = [],\n        frameCache = [],\n        // gopsToAlignWith = [],\n    config,\n        pps,\n        segmentStartPts = null,\n        segmentEndPts = null,\n        gops,\n        ensureNextFrameIsKeyFrame = true;\n    options = options || {};\n    VideoSegmentStream.prototype.init.call(this);\n\n    this.push = function (nalUnit) {\n      trackDecodeInfo.collectDtsInfo(track, nalUnit);\n\n      if (typeof track.timelineStartInfo.dts === 'undefined') {\n        track.timelineStartInfo.dts = nalUnit.dts;\n      } // record the track config\n\n\n      if (nalUnit.nalUnitType === 'seq_parameter_set_rbsp' && !config) {\n        config = nalUnit.config;\n        track.sps = [nalUnit.data];\n        videoProperties.forEach(function (prop) {\n          track[prop] = config[prop];\n        }, this);\n      }\n\n      if (nalUnit.nalUnitType === 'pic_parameter_set_rbsp' && !pps) {\n        pps = nalUnit.data;\n        track.pps = [nalUnit.data];\n      } // buffer video until flush() is called\n\n\n      nalUnits.push(nalUnit);\n    };\n\n    this.processNals_ = function (cacheLastFrame) {\n      var i;\n      nalUnits = frameCache.concat(nalUnits); // Throw away nalUnits at the start of the byte stream until\n      // we find the first AUD\n\n      while (nalUnits.length) {\n        if (nalUnits[0].nalUnitType === 'access_unit_delimiter_rbsp') {\n          break;\n        }\n\n        nalUnits.shift();\n      } // Return early if no video data has been observed\n\n\n      if (nalUnits.length === 0) {\n        return;\n      }\n\n      var frames = frameUtils.groupNalsIntoFrames(nalUnits);\n\n      if (!frames.length) {\n        return;\n      } // note that the frame cache may also protect us from cases where we haven't\n      // pushed data for the entire first or last frame yet\n\n\n      frameCache = frames[frames.length - 1];\n\n      if (cacheLastFrame) {\n        frames.pop();\n        frames.duration -= frameCache.duration;\n        frames.nalCount -= frameCache.length;\n        frames.byteLength -= frameCache.byteLength;\n      }\n\n      if (!frames.length) {\n        nalUnits = [];\n        return;\n      }\n\n      this.trigger('timelineStartInfo', track.timelineStartInfo);\n\n      if (ensureNextFrameIsKeyFrame) {\n        gops = frameUtils.groupFramesIntoGops(frames);\n\n        if (!gops[0][0].keyFrame) {\n          gops = frameUtils.extendFirstKeyFrame(gops);\n\n          if (!gops[0][0].keyFrame) {\n            // we haven't yet gotten a key frame, so reset nal units to wait for more nal\n            // units\n            nalUnits = [].concat.apply([], frames).concat(frameCache);\n            frameCache = [];\n            return;\n          }\n\n          frames = [].concat.apply([], gops);\n          frames.duration = gops.duration;\n        }\n\n        ensureNextFrameIsKeyFrame = false;\n      }\n\n      if (segmentStartPts === null) {\n        segmentStartPts = frames[0].pts;\n        segmentEndPts = segmentStartPts;\n      }\n\n      segmentEndPts += frames.duration;\n      this.trigger('timingInfo', {\n        start: segmentStartPts,\n        end: segmentEndPts\n      });\n\n      for (i = 0; i < frames.length; i++) {\n        var frame = frames[i];\n        track.samples = frameUtils.generateSampleTableForFrame(frame);\n        var mdat = mp4Generator.mdat(frameUtils.concatenateNalDataForFrame(frame));\n        trackDecodeInfo.clearDtsInfo(track);\n        trackDecodeInfo.collectDtsInfo(track, frame);\n        track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);\n        var moof = mp4Generator.moof(sequenceNumber, [track]);\n        sequenceNumber++;\n        track.initSegment = mp4Generator.initSegment([track]);\n        var boxes = new Uint8Array(moof.byteLength + mdat.byteLength);\n        boxes.set(moof);\n        boxes.set(mdat, moof.byteLength);\n        this.trigger('data', {\n          track: track,\n          boxes: boxes,\n          sequence: sequenceNumber,\n          videoFrameDts: frame.dts,\n          videoFramePts: frame.pts\n        });\n      }\n\n      nalUnits = [];\n    };\n\n    this.resetTimingAndConfig_ = function () {\n      config = undefined;\n      pps = undefined;\n      segmentStartPts = null;\n      segmentEndPts = null;\n    };\n\n    this.partialFlush = function () {\n      this.processNals_(true);\n      this.trigger('partialdone', 'VideoSegmentStream');\n    };\n\n    this.flush = function () {\n      this.processNals_(false); // reset config and pps because they may differ across segments\n      // for instance, when we are rendition switching\n\n      this.resetTimingAndConfig_();\n      this.trigger('done', 'VideoSegmentStream');\n    };\n\n    this.endTimeline = function () {\n      this.flush();\n      this.trigger('endedtimeline', 'VideoSegmentStream');\n    };\n\n    this.reset = function () {\n      this.resetTimingAndConfig_();\n      frameCache = [];\n      nalUnits = [];\n      ensureNextFrameIsKeyFrame = true;\n      this.trigger('reset');\n    };\n  };\n\n  VideoSegmentStream.prototype = new stream();\n  var videoSegmentStream = VideoSegmentStream;\n  var isLikelyAacData = utils.isLikelyAacData;\n\n  var createPipeline = function createPipeline(object) {\n    object.prototype = new stream();\n    object.prototype.init.call(object);\n    return object;\n  };\n\n  var tsPipeline = function tsPipeline(options) {\n    var pipeline = {\n      type: 'ts',\n      tracks: {\n        audio: null,\n        video: null\n      },\n      packet: new m2ts_1.TransportPacketStream(),\n      parse: new m2ts_1.TransportParseStream(),\n      elementary: new m2ts_1.ElementaryStream(),\n      timestampRollover: new m2ts_1.TimestampRolloverStream(),\n      adts: new codecs.Adts(),\n      h264: new codecs.h264.H264Stream(),\n      captionStream: new m2ts_1.CaptionStream(options),\n      metadataStream: new m2ts_1.MetadataStream()\n    };\n    pipeline.headOfPipeline = pipeline.packet; // Transport Stream\n\n    pipeline.packet.pipe(pipeline.parse).pipe(pipeline.elementary).pipe(pipeline.timestampRollover); // H264\n\n    pipeline.timestampRollover.pipe(pipeline.h264); // Hook up CEA-608/708 caption stream\n\n    pipeline.h264.pipe(pipeline.captionStream);\n    pipeline.timestampRollover.pipe(pipeline.metadataStream); // ADTS\n\n    pipeline.timestampRollover.pipe(pipeline.adts);\n    pipeline.elementary.on('data', function (data) {\n      if (data.type !== 'metadata') {\n        return;\n      }\n\n      for (var i = 0; i < data.tracks.length; i++) {\n        if (!pipeline.tracks[data.tracks[i].type]) {\n          pipeline.tracks[data.tracks[i].type] = data.tracks[i];\n          pipeline.tracks[data.tracks[i].type].timelineStartInfo.baseMediaDecodeTime = options.baseMediaDecodeTime;\n        }\n      }\n\n      if (pipeline.tracks.video && !pipeline.videoSegmentStream) {\n        pipeline.videoSegmentStream = new videoSegmentStream(pipeline.tracks.video, options);\n        pipeline.videoSegmentStream.on('timelineStartInfo', function (timelineStartInfo) {\n          if (pipeline.tracks.audio && !options.keepOriginalTimestamps) {\n            pipeline.audioSegmentStream.setEarliestDts(timelineStartInfo.dts - options.baseMediaDecodeTime);\n          }\n        });\n        pipeline.videoSegmentStream.on('timingInfo', pipeline.trigger.bind(pipeline, 'videoTimingInfo'));\n        pipeline.videoSegmentStream.on('data', function (data) {\n          pipeline.trigger('data', {\n            type: 'video',\n            data: data\n          });\n        });\n        pipeline.videoSegmentStream.on('done', pipeline.trigger.bind(pipeline, 'done'));\n        pipeline.videoSegmentStream.on('partialdone', pipeline.trigger.bind(pipeline, 'partialdone'));\n        pipeline.videoSegmentStream.on('endedtimeline', pipeline.trigger.bind(pipeline, 'endedtimeline'));\n        pipeline.h264.pipe(pipeline.videoSegmentStream);\n      }\n\n      if (pipeline.tracks.audio && !pipeline.audioSegmentStream) {\n        pipeline.audioSegmentStream = new audioSegmentStream(pipeline.tracks.audio, options);\n        pipeline.audioSegmentStream.on('data', function (data) {\n          pipeline.trigger('data', {\n            type: 'audio',\n            data: data\n          });\n        });\n        pipeline.audioSegmentStream.on('done', pipeline.trigger.bind(pipeline, 'done'));\n        pipeline.audioSegmentStream.on('partialdone', pipeline.trigger.bind(pipeline, 'partialdone'));\n        pipeline.audioSegmentStream.on('endedtimeline', pipeline.trigger.bind(pipeline, 'endedtimeline'));\n        pipeline.audioSegmentStream.on('timingInfo', pipeline.trigger.bind(pipeline, 'audioTimingInfo'));\n        pipeline.adts.pipe(pipeline.audioSegmentStream);\n      } // emit pmt info\n\n\n      pipeline.trigger('trackinfo', {\n        hasAudio: !!pipeline.tracks.audio,\n        hasVideo: !!pipeline.tracks.video\n      });\n    });\n    pipeline.captionStream.on('data', function (caption) {\n      var timelineStartPts;\n\n      if (pipeline.tracks.video) {\n        timelineStartPts = pipeline.tracks.video.timelineStartInfo.pts || 0;\n      } else {\n        // This will only happen if we encounter caption packets before\n        // video data in a segment. This is an unusual/unlikely scenario,\n        // so we assume the timeline starts at zero for now.\n        timelineStartPts = 0;\n      } // Translate caption PTS times into second offsets into the\n      // video timeline for the segment\n\n\n      caption.startTime = clock.metadataTsToSeconds(caption.startPts, timelineStartPts, options.keepOriginalTimestamps);\n      caption.endTime = clock.metadataTsToSeconds(caption.endPts, timelineStartPts, options.keepOriginalTimestamps);\n      pipeline.trigger('caption', caption);\n    });\n    pipeline = createPipeline(pipeline);\n    pipeline.metadataStream.on('data', pipeline.trigger.bind(pipeline, 'id3Frame'));\n    return pipeline;\n  };\n\n  var aacPipeline = function aacPipeline(options) {\n    var pipeline = {\n      type: 'aac',\n      tracks: {\n        audio: null\n      },\n      metadataStream: new m2ts_1.MetadataStream(),\n      aacStream: new aac(),\n      audioRollover: new m2ts_1.TimestampRolloverStream('audio'),\n      timedMetadataRollover: new m2ts_1.TimestampRolloverStream('timed-metadata'),\n      adtsStream: new adts(true)\n    }; // set up the parsing pipeline\n\n    pipeline.headOfPipeline = pipeline.aacStream;\n    pipeline.aacStream.pipe(pipeline.audioRollover).pipe(pipeline.adtsStream);\n    pipeline.aacStream.pipe(pipeline.timedMetadataRollover).pipe(pipeline.metadataStream);\n    pipeline.metadataStream.on('timestamp', function (frame) {\n      pipeline.aacStream.setTimestamp(frame.timeStamp);\n    });\n    pipeline.aacStream.on('data', function (data) {\n      if (data.type !== 'timed-metadata' && data.type !== 'audio' || pipeline.audioSegmentStream) {\n        return;\n      }\n\n      pipeline.tracks.audio = pipeline.tracks.audio || {\n        timelineStartInfo: {\n          baseMediaDecodeTime: options.baseMediaDecodeTime\n        },\n        codec: 'adts',\n        type: 'audio'\n      }; // hook up the audio segment stream to the first track with aac data\n\n      pipeline.audioSegmentStream = new audioSegmentStream(pipeline.tracks.audio, options);\n      pipeline.audioSegmentStream.on('data', function (data) {\n        pipeline.trigger('data', {\n          type: 'audio',\n          data: data\n        });\n      });\n      pipeline.audioSegmentStream.on('partialdone', pipeline.trigger.bind(pipeline, 'partialdone'));\n      pipeline.audioSegmentStream.on('done', pipeline.trigger.bind(pipeline, 'done'));\n      pipeline.audioSegmentStream.on('endedtimeline', pipeline.trigger.bind(pipeline, 'endedtimeline'));\n      pipeline.audioSegmentStream.on('timingInfo', pipeline.trigger.bind(pipeline, 'audioTimingInfo')); // Set up the final part of the audio pipeline\n\n      pipeline.adtsStream.pipe(pipeline.audioSegmentStream);\n      pipeline.trigger('trackinfo', {\n        hasAudio: !!pipeline.tracks.audio,\n        hasVideo: !!pipeline.tracks.video\n      });\n    }); // set the pipeline up as a stream before binding to get access to the trigger function\n\n    pipeline = createPipeline(pipeline);\n    pipeline.metadataStream.on('data', pipeline.trigger.bind(pipeline, 'id3Frame'));\n    return pipeline;\n  };\n\n  var setupPipelineListeners = function setupPipelineListeners(pipeline, transmuxer) {\n    pipeline.on('data', transmuxer.trigger.bind(transmuxer, 'data'));\n    pipeline.on('done', transmuxer.trigger.bind(transmuxer, 'done'));\n    pipeline.on('partialdone', transmuxer.trigger.bind(transmuxer, 'partialdone'));\n    pipeline.on('endedtimeline', transmuxer.trigger.bind(transmuxer, 'endedtimeline'));\n    pipeline.on('audioTimingInfo', transmuxer.trigger.bind(transmuxer, 'audioTimingInfo'));\n    pipeline.on('videoTimingInfo', transmuxer.trigger.bind(transmuxer, 'videoTimingInfo'));\n    pipeline.on('trackinfo', transmuxer.trigger.bind(transmuxer, 'trackinfo'));\n    pipeline.on('id3Frame', function (event) {\n      // add this to every single emitted segment even though it's only needed for the first\n      event.dispatchType = pipeline.metadataStream.dispatchType; // keep original time, can be adjusted if needed at a higher level\n\n      event.cueTime = clock.videoTsToSeconds(event.pts);\n      transmuxer.trigger('id3Frame', event);\n    });\n    pipeline.on('caption', function (event) {\n      transmuxer.trigger('caption', event);\n    });\n  };\n\n  var Transmuxer = function Transmuxer(options) {\n    var pipeline = null,\n        hasFlushed = true;\n    options = options || {};\n    Transmuxer.prototype.init.call(this);\n    options.baseMediaDecodeTime = options.baseMediaDecodeTime || 0;\n\n    this.push = function (bytes) {\n      if (hasFlushed) {\n        var isAac = isLikelyAacData(bytes);\n\n        if (isAac && (!pipeline || pipeline.type !== 'aac')) {\n          pipeline = aacPipeline(options);\n          setupPipelineListeners(pipeline, this);\n        } else if (!isAac && (!pipeline || pipeline.type !== 'ts')) {\n          pipeline = tsPipeline(options);\n          setupPipelineListeners(pipeline, this);\n        }\n\n        hasFlushed = false;\n      }\n\n      pipeline.headOfPipeline.push(bytes);\n    };\n\n    this.flush = function () {\n      if (!pipeline) {\n        return;\n      }\n\n      hasFlushed = true;\n      pipeline.headOfPipeline.flush();\n    };\n\n    this.partialFlush = function () {\n      if (!pipeline) {\n        return;\n      }\n\n      pipeline.headOfPipeline.partialFlush();\n    };\n\n    this.endTimeline = function () {\n      if (!pipeline) {\n        return;\n      }\n\n      pipeline.headOfPipeline.endTimeline();\n    };\n\n    this.reset = function () {\n      if (!pipeline) {\n        return;\n      }\n\n      pipeline.headOfPipeline.reset();\n    };\n\n    this.setBaseMediaDecodeTime = function (baseMediaDecodeTime) {\n      if (!options.keepOriginalTimestamps) {\n        options.baseMediaDecodeTime = baseMediaDecodeTime;\n      }\n\n      if (!pipeline) {\n        return;\n      }\n\n      if (pipeline.tracks.audio) {\n        pipeline.tracks.audio.timelineStartInfo.dts = undefined;\n        pipeline.tracks.audio.timelineStartInfo.pts = undefined;\n        trackDecodeInfo.clearDtsInfo(pipeline.tracks.audio);\n\n        if (pipeline.audioRollover) {\n          pipeline.audioRollover.discontinuity();\n        }\n      }\n\n      if (pipeline.tracks.video) {\n        if (pipeline.videoSegmentStream) {\n          pipeline.videoSegmentStream.gopCache_ = [];\n        }\n\n        pipeline.tracks.video.timelineStartInfo.dts = undefined;\n        pipeline.tracks.video.timelineStartInfo.pts = undefined;\n        trackDecodeInfo.clearDtsInfo(pipeline.tracks.video); // pipeline.captionStream.reset();\n      }\n\n      if (pipeline.timestampRollover) {\n        pipeline.timestampRollover.discontinuity();\n      }\n    };\n\n    this.setRemux = function (val) {\n      options.remux = val;\n\n      if (pipeline && pipeline.coalesceStream) {\n        pipeline.coalesceStream.setRemux(val);\n      }\n    };\n\n    this.setAudioAppendStart = function (audioAppendStart) {\n      if (!pipeline || !pipeline.tracks.audio || !pipeline.audioSegmentStream) {\n        return;\n      }\n\n      pipeline.audioSegmentStream.setAudioAppendStart(audioAppendStart);\n    }; // TODO GOP alignment support\n    // Support may be a bit trickier than with full segment appends, as GOPs may be split\n    // and processed in a more granular fashion\n\n\n    this.alignGopsWith = function (gopsToAlignWith) {\n      return;\n    };\n  };\n\n  Transmuxer.prototype = new stream();\n  var transmuxer = Transmuxer;\n  var partial = {\n    Transmuxer: transmuxer\n  };\n  var getUint64$1 = numbers.getUint64;\n\n  var parseSidx = function parseSidx(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4)),\n      references: [],\n      referenceId: view.getUint32(4),\n      timescale: view.getUint32(8)\n    },\n        i = 12;\n\n    if (result.version === 0) {\n      result.earliestPresentationTime = view.getUint32(i);\n      result.firstOffset = view.getUint32(i + 4);\n      i += 8;\n    } else {\n      // read 64 bits\n      result.earliestPresentationTime = getUint64$1(data.subarray(i));\n      result.firstOffset = getUint64$1(data.subarray(i + 8));\n      i += 16;\n    }\n\n    i += 2; // reserved\n\n    var referenceCount = view.getUint16(i);\n    i += 2; // start of references\n\n    for (; referenceCount > 0; i += 12, referenceCount--) {\n      result.references.push({\n        referenceType: (data[i] & 0x80) >>> 7,\n        referencedSize: view.getUint32(i) & 0x7FFFFFFF,\n        subsegmentDuration: view.getUint32(i + 4),\n        startsWithSap: !!(data[i + 8] & 0x80),\n        sapType: (data[i + 8] & 0x70) >>> 4,\n        sapDeltaTime: view.getUint32(i + 8) & 0x0FFFFFFF\n      });\n    }\n\n    return result;\n  };\n\n  var parseSidx_1 = parseSidx;\n  var getUint64 = numbers.getUint64;\n\n  var inspectMp4,\n      _textifyMp,\n      parseMp4Date = function parseMp4Date(seconds) {\n    return new Date(seconds * 1000 - 2082844800000);\n  },\n      nalParse = function nalParse(avcStream) {\n    var avcView = new DataView(avcStream.buffer, avcStream.byteOffset, avcStream.byteLength),\n        result = [],\n        i,\n        length;\n\n    for (i = 0; i + 4 < avcStream.length; i += length) {\n      length = avcView.getUint32(i);\n      i += 4; // bail if this doesn't appear to be an H264 stream\n\n      if (length <= 0) {\n        result.push('<span style=\\'color:red;\\'>MALFORMED DATA</span>');\n        continue;\n      }\n\n      switch (avcStream[i] & 0x1F) {\n        case 0x01:\n          result.push('slice_layer_without_partitioning_rbsp');\n          break;\n\n        case 0x05:\n          result.push('slice_layer_without_partitioning_rbsp_idr');\n          break;\n\n        case 0x06:\n          result.push('sei_rbsp');\n          break;\n\n        case 0x07:\n          result.push('seq_parameter_set_rbsp');\n          break;\n\n        case 0x08:\n          result.push('pic_parameter_set_rbsp');\n          break;\n\n        case 0x09:\n          result.push('access_unit_delimiter_rbsp');\n          break;\n\n        default:\n          result.push('UNKNOWN NAL - ' + avcStream[i] & 0x1F);\n          break;\n      }\n    }\n\n    return result;\n  },\n      // registry of handlers for individual mp4 box types\n  parse = {\n    // codingname, not a first-class box type. stsd entries share the\n    // same format as real boxes so the parsing infrastructure can be\n    // shared\n    avc1: function avc1(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n      return {\n        dataReferenceIndex: view.getUint16(6),\n        width: view.getUint16(24),\n        height: view.getUint16(26),\n        horizresolution: view.getUint16(28) + view.getUint16(30) / 16,\n        vertresolution: view.getUint16(32) + view.getUint16(34) / 16,\n        frameCount: view.getUint16(40),\n        depth: view.getUint16(74),\n        config: inspectMp4(data.subarray(78, data.byteLength))\n      };\n    },\n    avcC: function avcC(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          result = {\n        configurationVersion: data[0],\n        avcProfileIndication: data[1],\n        profileCompatibility: data[2],\n        avcLevelIndication: data[3],\n        lengthSizeMinusOne: data[4] & 0x03,\n        sps: [],\n        pps: []\n      },\n          numOfSequenceParameterSets = data[5] & 0x1f,\n          numOfPictureParameterSets,\n          nalSize,\n          offset,\n          i; // iterate past any SPSs\n\n      offset = 6;\n\n      for (i = 0; i < numOfSequenceParameterSets; i++) {\n        nalSize = view.getUint16(offset);\n        offset += 2;\n        result.sps.push(new Uint8Array(data.subarray(offset, offset + nalSize)));\n        offset += nalSize;\n      } // iterate past any PPSs\n\n\n      numOfPictureParameterSets = data[offset];\n      offset++;\n\n      for (i = 0; i < numOfPictureParameterSets; i++) {\n        nalSize = view.getUint16(offset);\n        offset += 2;\n        result.pps.push(new Uint8Array(data.subarray(offset, offset + nalSize)));\n        offset += nalSize;\n      }\n\n      return result;\n    },\n    btrt: function btrt(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n      return {\n        bufferSizeDB: view.getUint32(0),\n        maxBitrate: view.getUint32(4),\n        avgBitrate: view.getUint32(8)\n      };\n    },\n    edts: function edts(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    elst: function elst(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          result = {\n        version: view.getUint8(0),\n        flags: new Uint8Array(data.subarray(1, 4)),\n        edits: []\n      },\n          entryCount = view.getUint32(4),\n          i;\n\n      for (i = 8; entryCount; entryCount--) {\n        if (result.version === 0) {\n          result.edits.push({\n            segmentDuration: view.getUint32(i),\n            mediaTime: view.getInt32(i + 4),\n            mediaRate: view.getUint16(i + 8) + view.getUint16(i + 10) / (256 * 256)\n          });\n          i += 12;\n        } else {\n          result.edits.push({\n            segmentDuration: getUint64(data.subarray(i)),\n            mediaTime: getUint64(data.subarray(i + 8)),\n            mediaRate: view.getUint16(i + 16) + view.getUint16(i + 18) / (256 * 256)\n          });\n          i += 20;\n        }\n      }\n\n      return result;\n    },\n    esds: function esds(data) {\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        esId: data[6] << 8 | data[7],\n        streamPriority: data[8] & 0x1f,\n        decoderConfig: {\n          objectProfileIndication: data[11],\n          streamType: data[12] >>> 2 & 0x3f,\n          bufferSize: data[13] << 16 | data[14] << 8 | data[15],\n          maxBitrate: data[16] << 24 | data[17] << 16 | data[18] << 8 | data[19],\n          avgBitrate: data[20] << 24 | data[21] << 16 | data[22] << 8 | data[23],\n          decoderConfigDescriptor: {\n            tag: data[24],\n            length: data[25],\n            audioObjectType: data[26] >>> 3 & 0x1f,\n            samplingFrequencyIndex: (data[26] & 0x07) << 1 | data[27] >>> 7 & 0x01,\n            channelConfiguration: data[27] >>> 3 & 0x0f\n          }\n        }\n      };\n    },\n    ftyp: function ftyp(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          result = {\n        majorBrand: parseType_1(data.subarray(0, 4)),\n        minorVersion: view.getUint32(4),\n        compatibleBrands: []\n      },\n          i = 8;\n\n      while (i < data.byteLength) {\n        result.compatibleBrands.push(parseType_1(data.subarray(i, i + 4)));\n        i += 4;\n      }\n\n      return result;\n    },\n    dinf: function dinf(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    dref: function dref(data) {\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        dataReferences: inspectMp4(data.subarray(8))\n      };\n    },\n    hdlr: function hdlr(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          result = {\n        version: view.getUint8(0),\n        flags: new Uint8Array(data.subarray(1, 4)),\n        handlerType: parseType_1(data.subarray(8, 12)),\n        name: ''\n      },\n          i = 8; // parse out the name field\n\n      for (i = 24; i < data.byteLength; i++) {\n        if (data[i] === 0x00) {\n          // the name field is null-terminated\n          i++;\n          break;\n        }\n\n        result.name += String.fromCharCode(data[i]);\n      } // decode UTF-8 to javascript's internal representation\n      // see http://ecmanaut.blogspot.com/2006/07/encoding-decoding-utf8-in-javascript.html\n\n\n      result.name = decodeURIComponent(escape(result.name));\n      return result;\n    },\n    mdat: function mdat(data) {\n      return {\n        byteLength: data.byteLength,\n        nals: nalParse(data)\n      };\n    },\n    mdhd: function mdhd(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          i = 4,\n          language,\n          result = {\n        version: view.getUint8(0),\n        flags: new Uint8Array(data.subarray(1, 4)),\n        language: ''\n      };\n\n      if (result.version === 1) {\n        i += 4;\n        result.creationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n\n        i += 8;\n        result.modificationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n\n        i += 4;\n        result.timescale = view.getUint32(i);\n        i += 8;\n        result.duration = view.getUint32(i); // truncating top 4 bytes\n      } else {\n        result.creationTime = parseMp4Date(view.getUint32(i));\n        i += 4;\n        result.modificationTime = parseMp4Date(view.getUint32(i));\n        i += 4;\n        result.timescale = view.getUint32(i);\n        i += 4;\n        result.duration = view.getUint32(i);\n      }\n\n      i += 4; // language is stored as an ISO-639-2/T code in an array of three 5-bit fields\n      // each field is the packed difference between its ASCII value and 0x60\n\n      language = view.getUint16(i);\n      result.language += String.fromCharCode((language >> 10) + 0x60);\n      result.language += String.fromCharCode(((language & 0x03e0) >> 5) + 0x60);\n      result.language += String.fromCharCode((language & 0x1f) + 0x60);\n      return result;\n    },\n    mdia: function mdia(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    mfhd: function mfhd(data) {\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        sequenceNumber: data[4] << 24 | data[5] << 16 | data[6] << 8 | data[7]\n      };\n    },\n    minf: function minf(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    // codingname, not a first-class box type. stsd entries share the\n    // same format as real boxes so the parsing infrastructure can be\n    // shared\n    mp4a: function mp4a(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          result = {\n        // 6 bytes reserved\n        dataReferenceIndex: view.getUint16(6),\n        // 4 + 4 bytes reserved\n        channelcount: view.getUint16(16),\n        samplesize: view.getUint16(18),\n        // 2 bytes pre_defined\n        // 2 bytes reserved\n        samplerate: view.getUint16(24) + view.getUint16(26) / 65536\n      }; // if there are more bytes to process, assume this is an ISO/IEC\n      // 14496-14 MP4AudioSampleEntry and parse the ESDBox\n\n      if (data.byteLength > 28) {\n        result.streamDescriptor = inspectMp4(data.subarray(28))[0];\n      }\n\n      return result;\n    },\n    moof: function moof(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    moov: function moov(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    mvex: function mvex(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    mvhd: function mvhd(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          i = 4,\n          result = {\n        version: view.getUint8(0),\n        flags: new Uint8Array(data.subarray(1, 4))\n      };\n\n      if (result.version === 1) {\n        i += 4;\n        result.creationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n\n        i += 8;\n        result.modificationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n\n        i += 4;\n        result.timescale = view.getUint32(i);\n        i += 8;\n        result.duration = view.getUint32(i); // truncating top 4 bytes\n      } else {\n        result.creationTime = parseMp4Date(view.getUint32(i));\n        i += 4;\n        result.modificationTime = parseMp4Date(view.getUint32(i));\n        i += 4;\n        result.timescale = view.getUint32(i);\n        i += 4;\n        result.duration = view.getUint32(i);\n      }\n\n      i += 4; // convert fixed-point, base 16 back to a number\n\n      result.rate = view.getUint16(i) + view.getUint16(i + 2) / 16;\n      i += 4;\n      result.volume = view.getUint8(i) + view.getUint8(i + 1) / 8;\n      i += 2;\n      i += 2;\n      i += 2 * 4;\n      result.matrix = new Uint32Array(data.subarray(i, i + 9 * 4));\n      i += 9 * 4;\n      i += 6 * 4;\n      result.nextTrackId = view.getUint32(i);\n      return result;\n    },\n    pdin: function pdin(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n      return {\n        version: view.getUint8(0),\n        flags: new Uint8Array(data.subarray(1, 4)),\n        rate: view.getUint32(4),\n        initialDelay: view.getUint32(8)\n      };\n    },\n    sdtp: function sdtp(data) {\n      var result = {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        samples: []\n      },\n          i;\n\n      for (i = 4; i < data.byteLength; i++) {\n        result.samples.push({\n          dependsOn: (data[i] & 0x30) >> 4,\n          isDependedOn: (data[i] & 0x0c) >> 2,\n          hasRedundancy: data[i] & 0x03\n        });\n      }\n\n      return result;\n    },\n    sidx: parseSidx_1,\n    smhd: function smhd(data) {\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        balance: data[4] + data[5] / 256\n      };\n    },\n    stbl: function stbl(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    ctts: function ctts(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          result = {\n        version: view.getUint8(0),\n        flags: new Uint8Array(data.subarray(1, 4)),\n        compositionOffsets: []\n      },\n          entryCount = view.getUint32(4),\n          i;\n\n      for (i = 8; entryCount; i += 8, entryCount--) {\n        result.compositionOffsets.push({\n          sampleCount: view.getUint32(i),\n          sampleOffset: view[result.version === 0 ? 'getUint32' : 'getInt32'](i + 4)\n        });\n      }\n\n      return result;\n    },\n    stss: function stss(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          result = {\n        version: view.getUint8(0),\n        flags: new Uint8Array(data.subarray(1, 4)),\n        syncSamples: []\n      },\n          entryCount = view.getUint32(4),\n          i;\n\n      for (i = 8; entryCount; i += 4, entryCount--) {\n        result.syncSamples.push(view.getUint32(i));\n      }\n\n      return result;\n    },\n    stco: function stco(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          result = {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        chunkOffsets: []\n      },\n          entryCount = view.getUint32(4),\n          i;\n\n      for (i = 8; entryCount; i += 4, entryCount--) {\n        result.chunkOffsets.push(view.getUint32(i));\n      }\n\n      return result;\n    },\n    stsc: function stsc(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          entryCount = view.getUint32(4),\n          result = {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        sampleToChunks: []\n      },\n          i;\n\n      for (i = 8; entryCount; i += 12, entryCount--) {\n        result.sampleToChunks.push({\n          firstChunk: view.getUint32(i),\n          samplesPerChunk: view.getUint32(i + 4),\n          sampleDescriptionIndex: view.getUint32(i + 8)\n        });\n      }\n\n      return result;\n    },\n    stsd: function stsd(data) {\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        sampleDescriptions: inspectMp4(data.subarray(8))\n      };\n    },\n    stsz: function stsz(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          result = {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        sampleSize: view.getUint32(4),\n        entries: []\n      },\n          i;\n\n      for (i = 12; i < data.byteLength; i += 4) {\n        result.entries.push(view.getUint32(i));\n      }\n\n      return result;\n    },\n    stts: function stts(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          result = {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        timeToSamples: []\n      },\n          entryCount = view.getUint32(4),\n          i;\n\n      for (i = 8; entryCount; i += 8, entryCount--) {\n        result.timeToSamples.push({\n          sampleCount: view.getUint32(i),\n          sampleDelta: view.getUint32(i + 4)\n        });\n      }\n\n      return result;\n    },\n    styp: function styp(data) {\n      return parse.ftyp(data);\n    },\n    tfdt: parseTfdt,\n    tfhd: parseTfhd,\n    tkhd: function tkhd(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          i = 4,\n          result = {\n        version: view.getUint8(0),\n        flags: new Uint8Array(data.subarray(1, 4))\n      };\n\n      if (result.version === 1) {\n        i += 4;\n        result.creationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n\n        i += 8;\n        result.modificationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n\n        i += 4;\n        result.trackId = view.getUint32(i);\n        i += 4;\n        i += 8;\n        result.duration = view.getUint32(i); // truncating top 4 bytes\n      } else {\n        result.creationTime = parseMp4Date(view.getUint32(i));\n        i += 4;\n        result.modificationTime = parseMp4Date(view.getUint32(i));\n        i += 4;\n        result.trackId = view.getUint32(i);\n        i += 4;\n        i += 4;\n        result.duration = view.getUint32(i);\n      }\n\n      i += 4;\n      i += 2 * 4;\n      result.layer = view.getUint16(i);\n      i += 2;\n      result.alternateGroup = view.getUint16(i);\n      i += 2; // convert fixed-point, base 16 back to a number\n\n      result.volume = view.getUint8(i) + view.getUint8(i + 1) / 8;\n      i += 2;\n      i += 2;\n      result.matrix = new Uint32Array(data.subarray(i, i + 9 * 4));\n      i += 9 * 4;\n      result.width = view.getUint16(i) + view.getUint16(i + 2) / 65536;\n      i += 4;\n      result.height = view.getUint16(i) + view.getUint16(i + 2) / 65536;\n      return result;\n    },\n    traf: function traf(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    trak: function trak(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    trex: function trex(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        trackId: view.getUint32(4),\n        defaultSampleDescriptionIndex: view.getUint32(8),\n        defaultSampleDuration: view.getUint32(12),\n        defaultSampleSize: view.getUint32(16),\n        sampleDependsOn: data[20] & 0x03,\n        sampleIsDependedOn: (data[21] & 0xc0) >> 6,\n        sampleHasRedundancy: (data[21] & 0x30) >> 4,\n        samplePaddingValue: (data[21] & 0x0e) >> 1,\n        sampleIsDifferenceSample: !!(data[21] & 0x01),\n        sampleDegradationPriority: view.getUint16(22)\n      };\n    },\n    trun: parseTrun,\n    'url ': function url(data) {\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4))\n      };\n    },\n    vmhd: function vmhd(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        graphicsmode: view.getUint16(4),\n        opcolor: new Uint16Array([view.getUint16(6), view.getUint16(8), view.getUint16(10)])\n      };\n    }\n  };\n  /**\n   * Return a javascript array of box objects parsed from an ISO base\n   * media file.\n   * @param data {Uint8Array} the binary data of the media to be inspected\n   * @return {array} a javascript array of potentially nested box objects\n   */\n\n\n  inspectMp4 = function inspectMp4(data) {\n    var i = 0,\n        result = [],\n        view,\n        size,\n        type,\n        end,\n        box; // Convert data from Uint8Array to ArrayBuffer, to follow Dataview API\n\n    var ab = new ArrayBuffer(data.length);\n    var v = new Uint8Array(ab);\n\n    for (var z = 0; z < data.length; ++z) {\n      v[z] = data[z];\n    }\n\n    view = new DataView(ab);\n\n    while (i < data.byteLength) {\n      // parse box data\n      size = view.getUint32(i);\n      type = parseType_1(data.subarray(i + 4, i + 8));\n      end = size > 1 ? i + size : data.byteLength; // parse type-specific data\n\n      box = (parse[type] || function (data) {\n        return {\n          data: data\n        };\n      })(data.subarray(i + 8, end));\n\n      box.size = size;\n      box.type = type; // store this box and move to the next\n\n      result.push(box);\n      i = end;\n    }\n\n    return result;\n  };\n  /**\n   * Returns a textual representation of the javascript represtentation\n   * of an MP4 file. You can use it as an alternative to\n   * JSON.stringify() to compare inspected MP4s.\n   * @param inspectedMp4 {array} the parsed array of boxes in an MP4\n   * file\n   * @param depth {number} (optional) the number of ancestor boxes of\n   * the elements of inspectedMp4. Assumed to be zero if unspecified.\n   * @return {string} a text representation of the parsed MP4\n   */\n\n\n  _textifyMp = function textifyMp4(inspectedMp4, depth) {\n    var indent;\n    depth = depth || 0;\n    indent = new Array(depth * 2 + 1).join(' '); // iterate over all the boxes\n\n    return inspectedMp4.map(function (box, index) {\n      // list the box type first at the current indentation level\n      return indent + box.type + '\\n' + // the type is already included and handle child boxes separately\n      Object.keys(box).filter(function (key) {\n        return key !== 'type' && key !== 'boxes'; // output all the box properties\n      }).map(function (key) {\n        var prefix = indent + '  ' + key + ': ',\n            value = box[key]; // print out raw bytes as hexademical\n\n        if (value instanceof Uint8Array || value instanceof Uint32Array) {\n          var bytes = Array.prototype.slice.call(new Uint8Array(value.buffer, value.byteOffset, value.byteLength)).map(function (byte) {\n            return ' ' + ('00' + byte.toString(16)).slice(-2);\n          }).join('').match(/.{1,24}/g);\n\n          if (!bytes) {\n            return prefix + '<>';\n          }\n\n          if (bytes.length === 1) {\n            return prefix + '<' + bytes.join('').slice(1) + '>';\n          }\n\n          return prefix + '<\\n' + bytes.map(function (line) {\n            return indent + '  ' + line;\n          }).join('\\n') + '\\n' + indent + '  >';\n        } // stringify generic objects\n\n\n        return prefix + JSON.stringify(value, null, 2).split('\\n').map(function (line, index) {\n          if (index === 0) {\n            return line;\n          }\n\n          return indent + '  ' + line;\n        }).join('\\n');\n      }).join('\\n') + ( // recursively textify the child boxes\n      box.boxes ? '\\n' + _textifyMp(box.boxes, depth + 1) : '');\n    }).join('\\n');\n  };\n\n  var mp4Inspector = {\n    inspect: inspectMp4,\n    textify: _textifyMp,\n    parseType: parseType_1,\n    findBox: findBox_1,\n    parseTraf: parse.traf,\n    parseTfdt: parse.tfdt,\n    parseHdlr: parse.hdlr,\n    parseTfhd: parse.tfhd,\n    parseTrun: parse.trun,\n    parseSidx: parse.sidx\n  };\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n\n  var tagTypes = {\n    0x08: 'audio',\n    0x09: 'video',\n    0x12: 'metadata'\n  },\n      hex = function hex(val) {\n    return '0x' + ('00' + val.toString(16)).slice(-2).toUpperCase();\n  },\n      hexStringList = function hexStringList(data) {\n    var arr = [],\n        i;\n\n    while (data.byteLength > 0) {\n      i = 0;\n      arr.push(hex(data[i++]));\n      data = data.subarray(i);\n    }\n\n    return arr.join(' ');\n  },\n      parseAVCTag = function parseAVCTag(tag, obj) {\n    var avcPacketTypes = ['AVC Sequence Header', 'AVC NALU', 'AVC End-of-Sequence'],\n        compositionTime = tag[1] & parseInt('01111111', 2) << 16 | tag[2] << 8 | tag[3];\n    obj = obj || {};\n    obj.avcPacketType = avcPacketTypes[tag[0]];\n    obj.CompositionTime = tag[1] & parseInt('10000000', 2) ? -compositionTime : compositionTime;\n\n    if (tag[0] === 1) {\n      obj.nalUnitTypeRaw = hexStringList(tag.subarray(4, 100));\n    } else {\n      obj.data = hexStringList(tag.subarray(4));\n    }\n\n    return obj;\n  },\n      parseVideoTag = function parseVideoTag(tag, obj) {\n    var frameTypes = ['Unknown', 'Keyframe (for AVC, a seekable frame)', 'Inter frame (for AVC, a nonseekable frame)', 'Disposable inter frame (H.263 only)', 'Generated keyframe (reserved for server use only)', 'Video info/command frame'],\n        codecID = tag[0] & parseInt('00001111', 2);\n    obj = obj || {};\n    obj.frameType = frameTypes[(tag[0] & parseInt('11110000', 2)) >>> 4];\n    obj.codecID = codecID;\n\n    if (codecID === 7) {\n      return parseAVCTag(tag.subarray(1), obj);\n    }\n\n    return obj;\n  },\n      parseAACTag = function parseAACTag(tag, obj) {\n    var packetTypes = ['AAC Sequence Header', 'AAC Raw'];\n    obj = obj || {};\n    obj.aacPacketType = packetTypes[tag[0]];\n    obj.data = hexStringList(tag.subarray(1));\n    return obj;\n  },\n      parseAudioTag = function parseAudioTag(tag, obj) {\n    var formatTable = ['Linear PCM, platform endian', 'ADPCM', 'MP3', 'Linear PCM, little endian', 'Nellymoser 16-kHz mono', 'Nellymoser 8-kHz mono', 'Nellymoser', 'G.711 A-law logarithmic PCM', 'G.711 mu-law logarithmic PCM', 'reserved', 'AAC', 'Speex', 'MP3 8-Khz', 'Device-specific sound'],\n        samplingRateTable = ['5.5-kHz', '11-kHz', '22-kHz', '44-kHz'],\n        soundFormat = (tag[0] & parseInt('11110000', 2)) >>> 4;\n    obj = obj || {};\n    obj.soundFormat = formatTable[soundFormat];\n    obj.soundRate = samplingRateTable[(tag[0] & parseInt('00001100', 2)) >>> 2];\n    obj.soundSize = (tag[0] & parseInt('00000010', 2)) >>> 1 ? '16-bit' : '8-bit';\n    obj.soundType = tag[0] & parseInt('00000001', 2) ? 'Stereo' : 'Mono';\n\n    if (soundFormat === 10) {\n      return parseAACTag(tag.subarray(1), obj);\n    }\n\n    return obj;\n  },\n      parseGenericTag = function parseGenericTag(tag) {\n    return {\n      tagType: tagTypes[tag[0]],\n      dataSize: tag[1] << 16 | tag[2] << 8 | tag[3],\n      timestamp: tag[7] << 24 | tag[4] << 16 | tag[5] << 8 | tag[6],\n      streamID: tag[8] << 16 | tag[9] << 8 | tag[10]\n    };\n  },\n      inspectFlvTag = function inspectFlvTag(tag) {\n    var header = parseGenericTag(tag);\n\n    switch (tag[0]) {\n      case 0x08:\n        parseAudioTag(tag.subarray(11), header);\n        break;\n\n      case 0x09:\n        parseVideoTag(tag.subarray(11), header);\n        break;\n    }\n\n    return header;\n  },\n      inspectFlv = function inspectFlv(bytes) {\n    var i = 9,\n        // header\n    dataSize,\n        parsedResults = [],\n        tag; // traverse the tags\n\n    i += 4; // skip previous tag size\n\n    while (i < bytes.byteLength) {\n      dataSize = bytes[i + 1] << 16;\n      dataSize |= bytes[i + 2] << 8;\n      dataSize |= bytes[i + 3];\n      dataSize += 11;\n      tag = bytes.subarray(i, i + dataSize);\n      parsedResults.push(inspectFlvTag(tag));\n      i += dataSize + 4;\n    }\n\n    return parsedResults;\n  },\n      textifyFlv = function textifyFlv(flvTagArray) {\n    return JSON.stringify(flvTagArray, null, 2);\n  };\n\n  var flvInspector = {\n    inspectTag: inspectFlvTag,\n    inspect: inspectFlv,\n    textify: textifyFlv\n  };\n\n  var parsePid = function parsePid(packet) {\n    var pid = packet[1] & 0x1f;\n    pid <<= 8;\n    pid |= packet[2];\n    return pid;\n  };\n\n  var parsePayloadUnitStartIndicator = function parsePayloadUnitStartIndicator(packet) {\n    return !!(packet[1] & 0x40);\n  };\n\n  var parseAdaptionField = function parseAdaptionField(packet) {\n    var offset = 0; // if an adaption field is present, its length is specified by the\n    // fifth byte of the TS packet header. The adaptation field is\n    // used to add stuffing to PES packets that don't fill a complete\n    // TS packet, and to specify some forms of timing and control data\n    // that we do not currently use.\n\n    if ((packet[3] & 0x30) >>> 4 > 0x01) {\n      offset += packet[4] + 1;\n    }\n\n    return offset;\n  };\n\n  var parseType = function parseType(packet, pmtPid) {\n    var pid = parsePid(packet);\n\n    if (pid === 0) {\n      return 'pat';\n    } else if (pid === pmtPid) {\n      return 'pmt';\n    } else if (pmtPid) {\n      return 'pes';\n    }\n\n    return null;\n  };\n\n  var parsePat = function parsePat(packet) {\n    var pusi = parsePayloadUnitStartIndicator(packet);\n    var offset = 4 + parseAdaptionField(packet);\n\n    if (pusi) {\n      offset += packet[offset] + 1;\n    }\n\n    return (packet[offset + 10] & 0x1f) << 8 | packet[offset + 11];\n  };\n\n  var parsePmt = function parsePmt(packet) {\n    var programMapTable = {};\n    var pusi = parsePayloadUnitStartIndicator(packet);\n    var payloadOffset = 4 + parseAdaptionField(packet);\n\n    if (pusi) {\n      payloadOffset += packet[payloadOffset] + 1;\n    } // PMTs can be sent ahead of the time when they should actually\n    // take effect. We don't believe this should ever be the case\n    // for HLS but we'll ignore \"forward\" PMT declarations if we see\n    // them. Future PMT declarations have the current_next_indicator\n    // set to zero.\n\n\n    if (!(packet[payloadOffset + 5] & 0x01)) {\n      return;\n    }\n\n    var sectionLength, tableEnd, programInfoLength; // the mapping table ends at the end of the current section\n\n    sectionLength = (packet[payloadOffset + 1] & 0x0f) << 8 | packet[payloadOffset + 2];\n    tableEnd = 3 + sectionLength - 4; // to determine where the table is, we have to figure out how\n    // long the program info descriptors are\n\n    programInfoLength = (packet[payloadOffset + 10] & 0x0f) << 8 | packet[payloadOffset + 11]; // advance the offset to the first entry in the mapping table\n\n    var offset = 12 + programInfoLength;\n\n    while (offset < tableEnd) {\n      var i = payloadOffset + offset; // add an entry that maps the elementary_pid to the stream_type\n\n      programMapTable[(packet[i + 1] & 0x1F) << 8 | packet[i + 2]] = packet[i]; // move to the next table entry\n      // skip past the elementary stream descriptors, if present\n\n      offset += ((packet[i + 3] & 0x0F) << 8 | packet[i + 4]) + 5;\n    }\n\n    return programMapTable;\n  };\n\n  var parsePesType = function parsePesType(packet, programMapTable) {\n    var pid = parsePid(packet);\n    var type = programMapTable[pid];\n\n    switch (type) {\n      case streamTypes.H264_STREAM_TYPE:\n        return 'video';\n\n      case streamTypes.ADTS_STREAM_TYPE:\n        return 'audio';\n\n      case streamTypes.METADATA_STREAM_TYPE:\n        return 'timed-metadata';\n\n      default:\n        return null;\n    }\n  };\n\n  var parsePesTime = function parsePesTime(packet) {\n    var pusi = parsePayloadUnitStartIndicator(packet);\n\n    if (!pusi) {\n      return null;\n    }\n\n    var offset = 4 + parseAdaptionField(packet);\n\n    if (offset >= packet.byteLength) {\n      // From the H 222.0 MPEG-TS spec\n      // \"For transport stream packets carrying PES packets, stuffing is needed when there\n      //  is insufficient PES packet data to completely fill the transport stream packet\n      //  payload bytes. Stuffing is accomplished by defining an adaptation field longer than\n      //  the sum of the lengths of the data elements in it, so that the payload bytes\n      //  remaining after the adaptation field exactly accommodates the available PES packet\n      //  data.\"\n      //\n      // If the offset is >= the length of the packet, then the packet contains no data\n      // and instead is just adaption field stuffing bytes\n      return null;\n    }\n\n    var pes = null;\n    var ptsDtsFlags; // PES packets may be annotated with a PTS value, or a PTS value\n    // and a DTS value. Determine what combination of values is\n    // available to work with.\n\n    ptsDtsFlags = packet[offset + 7]; // PTS and DTS are normally stored as a 33-bit number.  Javascript\n    // performs all bitwise operations on 32-bit integers but javascript\n    // supports a much greater range (52-bits) of integer using standard\n    // mathematical operations.\n    // We construct a 31-bit value using bitwise operators over the 31\n    // most significant bits and then multiply by 4 (equal to a left-shift\n    // of 2) before we add the final 2 least significant bits of the\n    // timestamp (equal to an OR.)\n\n    if (ptsDtsFlags & 0xC0) {\n      pes = {}; // the PTS and DTS are not written out directly. For information\n      // on how they are encoded, see\n      // http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n\n      pes.pts = (packet[offset + 9] & 0x0E) << 27 | (packet[offset + 10] & 0xFF) << 20 | (packet[offset + 11] & 0xFE) << 12 | (packet[offset + 12] & 0xFF) << 5 | (packet[offset + 13] & 0xFE) >>> 3;\n      pes.pts *= 4; // Left shift by 2\n\n      pes.pts += (packet[offset + 13] & 0x06) >>> 1; // OR by the two LSBs\n\n      pes.dts = pes.pts;\n\n      if (ptsDtsFlags & 0x40) {\n        pes.dts = (packet[offset + 14] & 0x0E) << 27 | (packet[offset + 15] & 0xFF) << 20 | (packet[offset + 16] & 0xFE) << 12 | (packet[offset + 17] & 0xFF) << 5 | (packet[offset + 18] & 0xFE) >>> 3;\n        pes.dts *= 4; // Left shift by 2\n\n        pes.dts += (packet[offset + 18] & 0x06) >>> 1; // OR by the two LSBs\n      }\n    }\n\n    return pes;\n  };\n\n  var parseNalUnitType = function parseNalUnitType(type) {\n    switch (type) {\n      case 0x05:\n        return 'slice_layer_without_partitioning_rbsp_idr';\n\n      case 0x06:\n        return 'sei_rbsp';\n\n      case 0x07:\n        return 'seq_parameter_set_rbsp';\n\n      case 0x08:\n        return 'pic_parameter_set_rbsp';\n\n      case 0x09:\n        return 'access_unit_delimiter_rbsp';\n\n      default:\n        return null;\n    }\n  };\n\n  var videoPacketContainsKeyFrame = function videoPacketContainsKeyFrame(packet) {\n    var offset = 4 + parseAdaptionField(packet);\n    var frameBuffer = packet.subarray(offset);\n    var frameI = 0;\n    var frameSyncPoint = 0;\n    var foundKeyFrame = false;\n    var nalType; // advance the sync point to a NAL start, if necessary\n\n    for (; frameSyncPoint < frameBuffer.byteLength - 3; frameSyncPoint++) {\n      if (frameBuffer[frameSyncPoint + 2] === 1) {\n        // the sync point is properly aligned\n        frameI = frameSyncPoint + 5;\n        break;\n      }\n    }\n\n    while (frameI < frameBuffer.byteLength) {\n      // look at the current byte to determine if we've hit the end of\n      // a NAL unit boundary\n      switch (frameBuffer[frameI]) {\n        case 0:\n          // skip past non-sync sequences\n          if (frameBuffer[frameI - 1] !== 0) {\n            frameI += 2;\n            break;\n          } else if (frameBuffer[frameI - 2] !== 0) {\n            frameI++;\n            break;\n          }\n\n          if (frameSyncPoint + 3 !== frameI - 2) {\n            nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);\n\n            if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {\n              foundKeyFrame = true;\n            }\n          } // drop trailing zeroes\n\n\n          do {\n            frameI++;\n          } while (frameBuffer[frameI] !== 1 && frameI < frameBuffer.length);\n\n          frameSyncPoint = frameI - 2;\n          frameI += 3;\n          break;\n\n        case 1:\n          // skip past non-sync sequences\n          if (frameBuffer[frameI - 1] !== 0 || frameBuffer[frameI - 2] !== 0) {\n            frameI += 3;\n            break;\n          }\n\n          nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);\n\n          if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {\n            foundKeyFrame = true;\n          }\n\n          frameSyncPoint = frameI - 2;\n          frameI += 3;\n          break;\n\n        default:\n          // the current byte isn't a one or zero, so it cannot be part\n          // of a sync sequence\n          frameI += 3;\n          break;\n      }\n    }\n\n    frameBuffer = frameBuffer.subarray(frameSyncPoint);\n    frameI -= frameSyncPoint;\n    frameSyncPoint = 0; // parse the final nal\n\n    if (frameBuffer && frameBuffer.byteLength > 3) {\n      nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);\n\n      if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {\n        foundKeyFrame = true;\n      }\n    }\n\n    return foundKeyFrame;\n  };\n\n  var probe$1 = {\n    parseType: parseType,\n    parsePat: parsePat,\n    parsePmt: parsePmt,\n    parsePayloadUnitStartIndicator: parsePayloadUnitStartIndicator,\n    parsePesType: parsePesType,\n    parsePesTime: parsePesTime,\n    videoPacketContainsKeyFrame: videoPacketContainsKeyFrame\n  };\n  var handleRollover = timestampRolloverStream.handleRollover;\n  var probe = {};\n  probe.ts = probe$1;\n  probe.aac = utils;\n  var ONE_SECOND_IN_TS = clock.ONE_SECOND_IN_TS;\n  var MP2T_PACKET_LENGTH = 188,\n      // bytes\n  SYNC_BYTE = 0x47;\n  /**\n   * walks through segment data looking for pat and pmt packets to parse out\n   * program map table information\n   */\n\n  var parsePsi_ = function parsePsi_(bytes, pmt) {\n    var startIndex = 0,\n        endIndex = MP2T_PACKET_LENGTH,\n        packet,\n        type;\n\n    while (endIndex < bytes.byteLength) {\n      // Look for a pair of start and end sync bytes in the data..\n      if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n        // We found a packet\n        packet = bytes.subarray(startIndex, endIndex);\n        type = probe.ts.parseType(packet, pmt.pid);\n\n        switch (type) {\n          case 'pat':\n            pmt.pid = probe.ts.parsePat(packet);\n            break;\n\n          case 'pmt':\n            var table = probe.ts.parsePmt(packet);\n            pmt.table = pmt.table || {};\n            Object.keys(table).forEach(function (key) {\n              pmt.table[key] = table[key];\n            });\n            break;\n        }\n\n        startIndex += MP2T_PACKET_LENGTH;\n        endIndex += MP2T_PACKET_LENGTH;\n        continue;\n      } // If we get here, we have somehow become de-synchronized and we need to step\n      // forward one byte at a time until we find a pair of sync bytes that denote\n      // a packet\n\n\n      startIndex++;\n      endIndex++;\n    }\n  };\n  /**\n   * walks through the segment data from the start and end to get timing information\n   * for the first and last audio pes packets\n   */\n\n\n  var parseAudioPes_ = function parseAudioPes_(bytes, pmt, result) {\n    var startIndex = 0,\n        endIndex = MP2T_PACKET_LENGTH,\n        packet,\n        type,\n        pesType,\n        pusi,\n        parsed;\n    var endLoop = false; // Start walking from start of segment to get first audio packet\n\n    while (endIndex <= bytes.byteLength) {\n      // Look for a pair of start and end sync bytes in the data..\n      if (bytes[startIndex] === SYNC_BYTE && (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {\n        // We found a packet\n        packet = bytes.subarray(startIndex, endIndex);\n        type = probe.ts.parseType(packet, pmt.pid);\n\n        switch (type) {\n          case 'pes':\n            pesType = probe.ts.parsePesType(packet, pmt.table);\n            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n\n            if (pesType === 'audio' && pusi) {\n              parsed = probe.ts.parsePesTime(packet);\n\n              if (parsed) {\n                parsed.type = 'audio';\n                result.audio.push(parsed);\n                endLoop = true;\n              }\n            }\n\n            break;\n        }\n\n        if (endLoop) {\n          break;\n        }\n\n        startIndex += MP2T_PACKET_LENGTH;\n        endIndex += MP2T_PACKET_LENGTH;\n        continue;\n      } // If we get here, we have somehow become de-synchronized and we need to step\n      // forward one byte at a time until we find a pair of sync bytes that denote\n      // a packet\n\n\n      startIndex++;\n      endIndex++;\n    } // Start walking from end of segment to get last audio packet\n\n\n    endIndex = bytes.byteLength;\n    startIndex = endIndex - MP2T_PACKET_LENGTH;\n    endLoop = false;\n\n    while (startIndex >= 0) {\n      // Look for a pair of start and end sync bytes in the data..\n      if (bytes[startIndex] === SYNC_BYTE && (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {\n        // We found a packet\n        packet = bytes.subarray(startIndex, endIndex);\n        type = probe.ts.parseType(packet, pmt.pid);\n\n        switch (type) {\n          case 'pes':\n            pesType = probe.ts.parsePesType(packet, pmt.table);\n            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n\n            if (pesType === 'audio' && pusi) {\n              parsed = probe.ts.parsePesTime(packet);\n\n              if (parsed) {\n                parsed.type = 'audio';\n                result.audio.push(parsed);\n                endLoop = true;\n              }\n            }\n\n            break;\n        }\n\n        if (endLoop) {\n          break;\n        }\n\n        startIndex -= MP2T_PACKET_LENGTH;\n        endIndex -= MP2T_PACKET_LENGTH;\n        continue;\n      } // If we get here, we have somehow become de-synchronized and we need to step\n      // forward one byte at a time until we find a pair of sync bytes that denote\n      // a packet\n\n\n      startIndex--;\n      endIndex--;\n    }\n  };\n  /**\n   * walks through the segment data from the start and end to get timing information\n   * for the first and last video pes packets as well as timing information for the first\n   * key frame.\n   */\n\n\n  var parseVideoPes_ = function parseVideoPes_(bytes, pmt, result) {\n    var startIndex = 0,\n        endIndex = MP2T_PACKET_LENGTH,\n        packet,\n        type,\n        pesType,\n        pusi,\n        parsed,\n        frame,\n        i,\n        pes;\n    var endLoop = false;\n    var currentFrame = {\n      data: [],\n      size: 0\n    }; // Start walking from start of segment to get first video packet\n\n    while (endIndex < bytes.byteLength) {\n      // Look for a pair of start and end sync bytes in the data..\n      if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n        // We found a packet\n        packet = bytes.subarray(startIndex, endIndex);\n        type = probe.ts.parseType(packet, pmt.pid);\n\n        switch (type) {\n          case 'pes':\n            pesType = probe.ts.parsePesType(packet, pmt.table);\n            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n\n            if (pesType === 'video') {\n              if (pusi && !endLoop) {\n                parsed = probe.ts.parsePesTime(packet);\n\n                if (parsed) {\n                  parsed.type = 'video';\n                  result.video.push(parsed);\n                  endLoop = true;\n                }\n              }\n\n              if (!result.firstKeyFrame) {\n                if (pusi) {\n                  if (currentFrame.size !== 0) {\n                    frame = new Uint8Array(currentFrame.size);\n                    i = 0;\n\n                    while (currentFrame.data.length) {\n                      pes = currentFrame.data.shift();\n                      frame.set(pes, i);\n                      i += pes.byteLength;\n                    }\n\n                    if (probe.ts.videoPacketContainsKeyFrame(frame)) {\n                      var firstKeyFrame = probe.ts.parsePesTime(frame); // PTS/DTS may not be available. Simply *not* setting\n                      // the keyframe seems to work fine with HLS playback\n                      // and definitely preferable to a crash with TypeError...\n\n                      if (firstKeyFrame) {\n                        result.firstKeyFrame = firstKeyFrame;\n                        result.firstKeyFrame.type = 'video';\n                      } else {\n                        // eslint-disable-next-line\n                        console.warn('Failed to extract PTS/DTS from PES at first keyframe. ' + 'This could be an unusual TS segment, or else mux.js did not ' + 'parse your TS segment correctly. If you know your TS ' + 'segments do contain PTS/DTS on keyframes please file a bug ' + 'report! You can try ffprobe to double check for yourself.');\n                      }\n                    }\n\n                    currentFrame.size = 0;\n                  }\n                }\n\n                currentFrame.data.push(packet);\n                currentFrame.size += packet.byteLength;\n              }\n            }\n\n            break;\n        }\n\n        if (endLoop && result.firstKeyFrame) {\n          break;\n        }\n\n        startIndex += MP2T_PACKET_LENGTH;\n        endIndex += MP2T_PACKET_LENGTH;\n        continue;\n      } // If we get here, we have somehow become de-synchronized and we need to step\n      // forward one byte at a time until we find a pair of sync bytes that denote\n      // a packet\n\n\n      startIndex++;\n      endIndex++;\n    } // Start walking from end of segment to get last video packet\n\n\n    endIndex = bytes.byteLength;\n    startIndex = endIndex - MP2T_PACKET_LENGTH;\n    endLoop = false;\n\n    while (startIndex >= 0) {\n      // Look for a pair of start and end sync bytes in the data..\n      if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n        // We found a packet\n        packet = bytes.subarray(startIndex, endIndex);\n        type = probe.ts.parseType(packet, pmt.pid);\n\n        switch (type) {\n          case 'pes':\n            pesType = probe.ts.parsePesType(packet, pmt.table);\n            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n\n            if (pesType === 'video' && pusi) {\n              parsed = probe.ts.parsePesTime(packet);\n\n              if (parsed) {\n                parsed.type = 'video';\n                result.video.push(parsed);\n                endLoop = true;\n              }\n            }\n\n            break;\n        }\n\n        if (endLoop) {\n          break;\n        }\n\n        startIndex -= MP2T_PACKET_LENGTH;\n        endIndex -= MP2T_PACKET_LENGTH;\n        continue;\n      } // If we get here, we have somehow become de-synchronized and we need to step\n      // forward one byte at a time until we find a pair of sync bytes that denote\n      // a packet\n\n\n      startIndex--;\n      endIndex--;\n    }\n  };\n  /**\n   * Adjusts the timestamp information for the segment to account for\n   * rollover and convert to seconds based on pes packet timescale (90khz clock)\n   */\n\n\n  var adjustTimestamp_ = function adjustTimestamp_(segmentInfo, baseTimestamp) {\n    if (segmentInfo.audio && segmentInfo.audio.length) {\n      var audioBaseTimestamp = baseTimestamp;\n\n      if (typeof audioBaseTimestamp === 'undefined' || isNaN(audioBaseTimestamp)) {\n        audioBaseTimestamp = segmentInfo.audio[0].dts;\n      }\n\n      segmentInfo.audio.forEach(function (info) {\n        info.dts = handleRollover(info.dts, audioBaseTimestamp);\n        info.pts = handleRollover(info.pts, audioBaseTimestamp); // time in seconds\n\n        info.dtsTime = info.dts / ONE_SECOND_IN_TS;\n        info.ptsTime = info.pts / ONE_SECOND_IN_TS;\n      });\n    }\n\n    if (segmentInfo.video && segmentInfo.video.length) {\n      var videoBaseTimestamp = baseTimestamp;\n\n      if (typeof videoBaseTimestamp === 'undefined' || isNaN(videoBaseTimestamp)) {\n        videoBaseTimestamp = segmentInfo.video[0].dts;\n      }\n\n      segmentInfo.video.forEach(function (info) {\n        info.dts = handleRollover(info.dts, videoBaseTimestamp);\n        info.pts = handleRollover(info.pts, videoBaseTimestamp); // time in seconds\n\n        info.dtsTime = info.dts / ONE_SECOND_IN_TS;\n        info.ptsTime = info.pts / ONE_SECOND_IN_TS;\n      });\n\n      if (segmentInfo.firstKeyFrame) {\n        var frame = segmentInfo.firstKeyFrame;\n        frame.dts = handleRollover(frame.dts, videoBaseTimestamp);\n        frame.pts = handleRollover(frame.pts, videoBaseTimestamp); // time in seconds\n\n        frame.dtsTime = frame.dts / ONE_SECOND_IN_TS;\n        frame.ptsTime = frame.pts / ONE_SECOND_IN_TS;\n      }\n    }\n  };\n  /**\n   * inspects the aac data stream for start and end time information\n   */\n\n\n  var inspectAac_ = function inspectAac_(bytes) {\n    var endLoop = false,\n        audioCount = 0,\n        sampleRate = null,\n        timestamp = null,\n        frameSize = 0,\n        byteIndex = 0,\n        packet;\n\n    while (bytes.length - byteIndex >= 3) {\n      var type = probe.aac.parseType(bytes, byteIndex);\n\n      switch (type) {\n        case 'timed-metadata':\n          // Exit early because we don't have enough to parse\n          // the ID3 tag header\n          if (bytes.length - byteIndex < 10) {\n            endLoop = true;\n            break;\n          }\n\n          frameSize = probe.aac.parseId3TagSize(bytes, byteIndex); // Exit early if we don't have enough in the buffer\n          // to emit a full packet\n\n          if (frameSize > bytes.length) {\n            endLoop = true;\n            break;\n          }\n\n          if (timestamp === null) {\n            packet = bytes.subarray(byteIndex, byteIndex + frameSize);\n            timestamp = probe.aac.parseAacTimestamp(packet);\n          }\n\n          byteIndex += frameSize;\n          break;\n\n        case 'audio':\n          // Exit early because we don't have enough to parse\n          // the ADTS frame header\n          if (bytes.length - byteIndex < 7) {\n            endLoop = true;\n            break;\n          }\n\n          frameSize = probe.aac.parseAdtsSize(bytes, byteIndex); // Exit early if we don't have enough in the buffer\n          // to emit a full packet\n\n          if (frameSize > bytes.length) {\n            endLoop = true;\n            break;\n          }\n\n          if (sampleRate === null) {\n            packet = bytes.subarray(byteIndex, byteIndex + frameSize);\n            sampleRate = probe.aac.parseSampleRate(packet);\n          }\n\n          audioCount++;\n          byteIndex += frameSize;\n          break;\n\n        default:\n          byteIndex++;\n          break;\n      }\n\n      if (endLoop) {\n        return null;\n      }\n    }\n\n    if (sampleRate === null || timestamp === null) {\n      return null;\n    }\n\n    var audioTimescale = ONE_SECOND_IN_TS / sampleRate;\n    var result = {\n      audio: [{\n        type: 'audio',\n        dts: timestamp,\n        pts: timestamp\n      }, {\n        type: 'audio',\n        dts: timestamp + audioCount * 1024 * audioTimescale,\n        pts: timestamp + audioCount * 1024 * audioTimescale\n      }]\n    };\n    return result;\n  };\n  /**\n   * inspects the transport stream segment data for start and end time information\n   * of the audio and video tracks (when present) as well as the first key frame's\n   * start time.\n   */\n\n\n  var inspectTs_ = function inspectTs_(bytes) {\n    var pmt = {\n      pid: null,\n      table: null\n    };\n    var result = {};\n    parsePsi_(bytes, pmt);\n\n    for (var pid in pmt.table) {\n      if (pmt.table.hasOwnProperty(pid)) {\n        var type = pmt.table[pid];\n\n        switch (type) {\n          case streamTypes.H264_STREAM_TYPE:\n            result.video = [];\n            parseVideoPes_(bytes, pmt, result);\n\n            if (result.video.length === 0) {\n              delete result.video;\n            }\n\n            break;\n\n          case streamTypes.ADTS_STREAM_TYPE:\n            result.audio = [];\n            parseAudioPes_(bytes, pmt, result);\n\n            if (result.audio.length === 0) {\n              delete result.audio;\n            }\n\n            break;\n        }\n      }\n    }\n\n    return result;\n  };\n  /**\n   * Inspects segment byte data and returns an object with start and end timing information\n   *\n   * @param {Uint8Array} bytes The segment byte data\n   * @param {Number} baseTimestamp Relative reference timestamp used when adjusting frame\n   *  timestamps for rollover. This value must be in 90khz clock.\n   * @return {Object} Object containing start and end frame timing info of segment.\n   */\n\n\n  var inspect = function inspect(bytes, baseTimestamp) {\n    var isAacData = probe.aac.isLikelyAacData(bytes);\n    var result;\n\n    if (isAacData) {\n      result = inspectAac_(bytes);\n    } else {\n      result = inspectTs_(bytes);\n    }\n\n    if (!result || !result.audio && !result.video) {\n      return null;\n    }\n\n    adjustTimestamp_(result, baseTimestamp);\n    return result;\n  };\n\n  var tsInspector = {\n    inspect: inspect,\n    parseAudioPes_: parseAudioPes_\n  };\n  var muxjs = {\n    codecs: codecs,\n    mp4: mp4,\n    flv: flv,\n    mp2t: m2ts,\n    partial: partial\n  }; // include all the tools when the full library is required\n\n  muxjs.mp4.tools = mp4Inspector;\n  muxjs.flv.tools = flvInspector;\n  muxjs.mp2t.tools = tsInspector;\n  var lib = muxjs;\n  return lib;\n});","map":{"version":3,"sources":["S:/REACT/Ract-Js/Frlnce/node_modules/mux.js/dist/mux.js"],"names":["global","factory","exports","module","require","define","amd","globalThis","self","muxjs","window","_interopDefaultLegacy","e","window__default","Stream","init","listeners","on","type","listener","concat","off","index","indexOf","slice","splice","trigger","callbacks","i","length","args","arguments","call","push","apply","dispose","prototype","pipe","destination","data","flushSource","flush","partialFlush","endTimeline","reset","stream","ONE_SECOND_IN_TS$5","secondsToVideoTs","secondsToAudioTs","videoTsToSeconds","audioTsToSeconds","audioTsToVideoTs","videoTsToAudioTs","metadataTsToSeconds","seconds","sampleRate","timestamp","timelineStartPts","keepOriginalTimestamps","clock","ONE_SECOND_IN_TS","ONE_SECOND_IN_TS$4","_AdtsStream","ADTS_SAMPLING_FREQUENCIES$1","AdtsStream","handlePartialSegments","buffer","frameNum","skipWarn_","start","end","level","message","packet","frameLength","protectionSkipBytes","oldBuffer","sampleCount","adtsFrameDuration","Uint8Array","byteLength","set","skip","pts","dts","audioobjecttype","channelcount","samplerate","samplingfrequencyindex","samplesize","subarray","adts","ExpGolomb","workingData","workingBytesAvailable","workingWord","workingBitsAvailable","bitsAvailable","loadWord","position","workingBytes","availableBytes","Math","min","Error","DataView","getUint32","skipBits","count","skipBytes","floor","readBits","size","bits","valu","skipLeadingZeros","leadingZeroCount","skipUnsignedExpGolomb","skipExpGolomb","readUnsignedExpGolomb","clz","readExpGolomb","readBoolean","readUnsignedByte","expGolomb","_H264Stream","_NalByteStream","PROFILES_WITH_OPTIONAL_SPS_DATA","NalByteStream","syncPoint","swapBuffer","len","H264Stream","nalByteStream","trackId","currentPts","currentDts","discardEmulationPreventionBytes","readSequenceParameterSet","skipScalingList","event","nalUnitTypeCode","nalUnitType","escapedRBSP","config","expGolombDecoder","lastScale","nextScale","j","deltaScale","emulationPreventionBytesPositions","newLength","newData","sourceIndex","shift","frameCropLeftOffset","frameCropRightOffset","frameCropTopOffset","frameCropBottomOffset","profileIdc","levelIdc","profileCompatibility","chromaFormatIdc","picOrderCntType","numRefFramesInPicOrderCntCycle","picWidthInMbsMinus1","picHeightInMapUnitsMinus1","frameMbsOnlyFlag","scalingListCount","sarRatio","aspectRatioIdc","width","height","h264","codecs","Adts","MAX_UINT32$1","pow","getUint64$4","getUint64","uint8","dv","byteOffset","value","getBigUint64","Number","MAX_SAFE_INTEGER","numbers","MAX_UINT32","box","dinf","esds","ftyp","mdat","mfhd","minf","moof","moov","mvex","mvhd","trak","tkhd","mdia","mdhd","hdlr","sdtp","stbl","stsd","traf","trex","trun$1","types","MAJOR_BRAND","MINOR_VERSION","AVC1_BRAND","VIDEO_HDLR","AUDIO_HDLR","HDLR_TYPES","VMHD","SMHD","DREF","STCO","STSC","STSZ","STTS","avc1","avcC","btrt","dref","mp4a","pasp","smhd","stco","stsc","stsz","stts","styp","tfdt","tfhd","trun","vmhd","hasOwnProperty","charCodeAt","video","audio","payload","result","view","setUint32","track","duration","sequenceNumber","tracks","trackFragments","boxes","bytes","samples","flags","dependsOn","isDependedOn","hasRedundancy","videoSample","audioSample","sps","pps","sequenceParameterSets","pictureParameterSets","avc1Box","Array","hSpacing","vSpacing","id","trackFragmentHeader","trackFragmentDecodeTime","trackFragmentRun","sampleDependencyTable","dataOffset","upperWordBaseMediaDecodeTime","lowerWordBaseMediaDecodeTime","baseMediaDecodeTime","audioTrun","videoTrun","trunHeader","offset","durationPresent","sizePresent","flagsPresent","compositionTimeOffset","undefined","bytesOffest","header","sample","isLeading","paddingValue","isNonSyncSample","degradationPriority","mp4Generator","initSegment","fileType","movie","toUnsigned$3","toUnsigned","toHexString$1","toHexString","toString","bin","parseType$2","parseType","String","fromCharCode","parseType_1","toUnsigned$2","findBox","path","results","subresults","findBox_1","version","baseDataOffsetPresent","sampleDescriptionIndexPresent","defaultSampleDurationPresent","defaultSampleSizePresent","defaultSampleFlagsPresent","durationIsEmpty","defaultBaseIsMoof","baseDataOffset","sampleDescriptionIndex","defaultSampleDuration","defaultSampleSize","defaultSampleFlags","baseDataOffsetIsMoof","parseTfhd","parseSampleFlags","parseSampleFlags_1","dataOffsetPresent","firstSampleFlagsPresent","sampleDurationPresent","sampleSizePresent","sampleFlagsPresent","sampleCompositionTimeOffsetPresent","getInt32","parseTrun","toUnsigned$1","getUint64$3","parseTfdt","getUint64$2","timescale","startTime","compositionStartTime","getVideoTrackIds","getTracks","getTimescaleFromMediaHeader","traks","reduce","fragment","trafs","lowestTime","acc","scale","baseTime","BigInt","isNaN","Infinity","isFinite","timescales","trafBoxes","parsedTfhd","parsedTfdt","parsedTrun","videoTrackIds","forEach","hdlrs","tkhds","handlerType","getUint8","tkhdVersion","sampleDescriptions","codec","codecBox","codecConfig","codecConfigType","test","replace","toLowerCase","probe$2","groupNalsIntoFrames","nalUnits","currentNal","currentFrame","frames","nalCount","keyFrame","groupFramesIntoGops","currentGop","gops","extendFirstKeyFrame","createDefaultSample","sampleForFrame","frame","generateSampleTable$1","generateSampleTable","h","concatenateNalData","nalsByteLength","numberOfNals","totalByteLength","generateSampleTableForFrame","concatenateNalDataForFrame","frameUtils","highPrefix","lowPrefix","zeroFill","a","makeTable","metaTable","Object","keys","obj","key","arr","part","silence","silence_1","coneOfSilence","sumFrameByteLengths","array","currentObj","sum","prefixWithSilence","audioAppendStartTs","videoBaseMediaDecodeTime","baseMediaDecodeTimeTs","frameDuration","audioGapDuration","audioFillFrameCount","audioFillDuration","silentFrame","firstFrame","ceil","max","trimAdtsFramesByEarliestDts","adtsFrames","earliestAllowedDts","minSegmentDts","filter","minSegmentPts","concatenateFrameData","audioFrameUtils","ONE_SECOND_IN_TS$3","collectDtsInfo","timelineStartInfo","maxSegmentPts","maxSegmentDts","clearDtsInfo","calculateTrackBaseMediaDecodeTime","trackDecodeInfo","USER_DATA_REGISTERED_ITU_T_T35","RBSP_TRAILING_BITS","parseSei","payloadType","payloadSize","userIdentifier","parseUserData","sei","parseCaptionPackets","userData","ccData","discardEmulationPreventionBytes$1","captionPacketParser","CaptionStream$1","CaptionStream","options","parse708captions_","parse708captions","captionPackets_","ccStreams_","Cea608Stream","cc708Stream_","Cea708Stream","captionServices","cc","bind","newCaptionPackets","latestDts_","ignoreNextEqualDts_","numSameDts_","flushCCStreams","flushType","flushStream","elem","idx","presortIndex","sort","b","dispatchCea608Packet","dispatchCea708Packet","activeCea608Channel_","ccStream","setsTextOrXDSActive","setsChannel1Active","setsChannel2Active","CHARACTER_TRANSLATION_708","get708CharFromCode","code","newCode","within708TextBlock","Cea708Window","windowNum","clearText","pendingNewLine","winAttr","penAttr","penLoc","penColor","visible","rowLock","columnLock","priority","relativePositioning","anchorVertical","anchorHorizontal","anchorPoint","rowCount","virtualRowCount","columnCount","windowStyle","penStyle","getText","rows","join","rowIdx","newLine","beforeRowOverflow","isEmpty","addText","text","backspace","row","substr","Cea708Service","serviceNum","encoding","currentWindow","windows","createTextDecoder","startPts","win","setCurrentWindow","TextDecoder","textDecoder_","error","captionServiceEncodings","serviceProps","serviceName","serviceEncodings","current708Packet","services","new708Packet","add708Bytes","push708Packet","ptsVals","byte0","byte1","packet708","packetData","blockSize","seq","sizeCode","pushServiceBlock","service","initService","handleText","multiByteCharacter","extendedCommands","defineWindow","clearWindows","deleteWindows","displayWindows","hideWindows","toggleWindows","setWindowAttributes","setPenAttributes","setPenColor","setPenLocation","isExtended","getPts","byteIndex","flushDisplayed","isMultiByte","extended","currentByte","nextByte","char","charCodeArray","decode","firstByte","secondByte","fillOpacity","fillRed","fillGreen","fillBlue","borderType","borderRed","borderGreen","borderBlue","wordWrap","printDirection","scrollDirection","justify","effectSpeed","effectDirection","displayEffect","displayedText","winId","endPts","pushCaption","textTag","penSize","italics","underline","edgeType","fontStyle","fgOpacity","fgRed","fgGreen","fgBlue","bgOpacity","bgRed","bgGreen","bgBlue","edgeRed","edgeGreen","edgeBlue","column","CHARACTER_TRANSLATION","getCharFromCode","BOTTOM_ROW","ROWS","createDisplayBuffer","field","dataChannel","field_","dataChannel_","name_","setConstants","swap","char0","char1","lastControlCode_","PADDING_","RESUME_CAPTION_LOADING_","mode_","END_OF_CAPTION_","clearFormatting","displayed_","nonDisplayed_","startPts_","ROLL_UP_2_ROWS_","rollUpRows_","setRollUp","ROLL_UP_3_ROWS_","ROLL_UP_4_ROWS_","CARRIAGE_RETURN_","shiftRowsUp_","BACKSPACE_","row_","ERASE_DISPLAYED_MEMORY_","ERASE_NON_DISPLAYED_MEMORY_","RESUME_DIRECT_CAPTIONING_","isSpecialCharacter","column_","isExtCharacter","isMidRowCode","addFormatting","isOffsetControlCode","isPAC","formatting_","isColorPAC","isNormalChar","content","map","trim","topRow_","BASE_","EXT_","CONTROL_","OFFSET_","newBaseRow","format","reverse","popOn","baseRow","rollUp","paintOn","captionStream","streamTypes","H264_STREAM_TYPE","ADTS_STREAM_TYPE","METADATA_STREAM_TYPE","MAX_TS","RO_THRESH","TYPE_SHARED","handleRollover$1","handleRollover","reference","direction","abs","TimestampRolloverStream$1","TimestampRolloverStream","lastDTS","referenceDTS","type_","discontinuity","timestampRolloverStream","percentEncode$1","percentEncode","parseUtf8","decodeURIComponent","parseIso88591$1","parseIso88591","unescape","parseSyncSafeInteger$1","parseSyncSafeInteger","tagParsers","TXXX","tag","description","WXXX","url","PRIV","owner","privateData","_MetadataStream","MetadataStream","settings","descriptor","tagSize","bufferSize","dispatchType","chunk","frameStart","frameSize","frameHeader","dataAlignmentIndicator","d","timeStamp","metadataStream","_TransportPacketStream","_TransportParseStream","_ElementaryStream","MP2T_PACKET_LENGTH$1","SYNC_BYTE$1","TransportPacketStream","bytesInBuffer","startIndex","endIndex","everything","TransportParseStream","parsePsi","parsePat","parsePmt","packetsWaitingForPmt","programMapTable","psi","payloadUnitStartIndicator","pat","section_number","last_section_number","pmtPid","pmt","sectionLength","tableEnd","programInfoLength","streamType","pid","processPes_","STREAM_TYPES","ElementaryStream","segmentHadPmt","timedMetadata","parsePes","pes","ptsDtsFlags","startPrefix","packetLength","forceFlush","packetFlushable","flushStreams_","m2ts$1","PAT_PID","MP2T_PACKET_LENGTH","m2ts_1","ADTS_SAMPLING_FREQUENCIES","parseId3TagSize","returnSize","footerPresent","getId3Offset","isLikelyAacData$2","isLikelyAacData","parseAdtsSize","lowThree","middle","highTwo","parseType$1","parseSampleRate","parseAacTimestamp","utils","_AacStream","AacStream","setTimestamp","bytesLeft","tempLength","aac","AUDIO_PROPERTIES","audioProperties","VIDEO_PROPERTIES","videoProperties","H264Stream$1","isLikelyAacData$1","ONE_SECOND_IN_TS$2","_VideoSegmentStream$1","_AudioSegmentStream$1","_Transmuxer$1","_CoalesceStream","retriggerForStream","addPipelineLogRetriggers","transmuxer","pipeline","arrayEquals","generateSegmentTimingInfo","startDts","endDts","prependedContentDuration","ptsOffsetFromDts","decodeDuration","presentationDuration","AudioSegmentStream","firstSequenceNumber","prop","setEarliestDts","earliestDts","setVideoBaseMediaDecodeTime","setAudioAppendStart","segmentDuration","videoClockCyclesOfSilencePrefixed","VideoSegmentStream","gopsToAlignWith","minPTS","gopCache_","nalUnit","gopForFusion","firstGop","lastGop","resetStream_","getGopForFusion_","unshift","alignedGops","alignGopsAtEnd","alignGopsAtEnd_","alignGopsAtStart_","gop","pop","halfSecond","allowableOverlap","nearestDistance","dtsDistance","nearestGopObj","currentGopObj","alignIndex","gopIndex","align","alignEndIndex","matchFound","trimIndex","metadata","total","alignGopsWith","newGopsToAlignWith","CoalesceStream","numberOfTracks","remux","remuxTracks","pendingTracks","videoTrack","pendingBoxes","pendingCaptions","pendingMetadata","pendingBytes","emittedTracks","output","audioTrack","captions","captionStreams","info","caption","id3","endTime","cueTime","setRemux","val","Transmuxer","hasFlushed","transmuxPipeline_","setupAacPipeline","aacStream","audioTimestampRolloverStream","timedMetadataTimestampRolloverStream","adtsStream","coalesceStream","headOfPipeline","audioSegmentStream","getLogTrigger_","hasAudio","hasVideo","setupTsPipeline","packetStream","parseStream","elementaryStream","h264Stream","videoSegmentStream","id3Frame","setBaseMediaDecodeTime","isAac","resetCaptions","transmuxer$2","mapToSample","approximateOffset","findSeiNals","avcStream","avcView","logs","seiNals","seiNal","lastMatchedSample","matchingSample","parseSamples","truns","allSamples","trackRun","parseCaptionNals","segment","videoTrackId","mdats","captionNals","mdatTrafPairs","matchingTraf","pair","headerInfo","parseEmbeddedCaptions","trackNals","CaptionParser","isInitialized","segmentCache","parsedCaptions","parsingPartial","isPartial","log","isNewInit","parse","parsedData","cachedSegment","pushNals","nals","nal","clearParsedCaptions","resetCaptionStream","clearAllCaptions","captionParser","mp4","generator","probe","_FlvTag","FlvTag","extraData","adHoc","bufferStartSize","prepareWrite","flv","minLength","widthBytes","heightBytes","videocodecidBytes","VIDEO_TAG","AUDIO_TAG","METADATA_TAG","writeBytes","writeByte","byte","writeShort","short","setUint16","negIndex","pos","nalUnitSize","startNalUnit","endNalUnit","nalContainer","nalStart","nalLength","writeMetaDataDouble","setFloat64","writeMetaDataBoolean","setUint8","finalize","dtsDelta","frameTime","isAudioFrame","isVideoFrame","isMetaData","isKeyFrame","flvTag","videoTags","audioTags","processedTracks","tags","TagList","list","metaDataTag","defineProperty","get","tagList","_Transmuxer","_VideoSegmentStream","_AudioSegmentStream","collectTimelineInfo","extraDataTag","videoKeyFrames","oldExtraData","round","adtsFrame","lastMetaPts","writeMetaDataTags","onVideoKeyFrame","h264Frame","finishFrame","newMetadata","metaTag","extraTag","videoTimestampRolloverStream","coalesceStream$1","transmuxer$1","getFlvHeader","headBytes","head","metadataLength","flvHeader","m2ts","ONE_SECOND_IN_TS$1","segmentStartPts","segmentEndPts","processFrames_","timingInfo","resetTiming_","frameCache","ensureNextFrameIsKeyFrame","processNals_","cacheLastFrame","sequence","videoFrameDts","videoFramePts","resetTimingAndConfig_","createPipeline","object","tsPipeline","elementary","timestampRollover","aacPipeline","audioRollover","timedMetadataRollover","setupPipelineListeners","audioAppendStart","partial","getUint64$1","parseSidx","references","referenceId","earliestPresentationTime","firstOffset","referenceCount","getUint16","referenceType","referencedSize","subsegmentDuration","startsWithSap","sapType","sapDeltaTime","parseSidx_1","inspectMp4","_textifyMp","parseMp4Date","Date","nalParse","dataReferenceIndex","horizresolution","vertresolution","frameCount","depth","configurationVersion","avcProfileIndication","avcLevelIndication","lengthSizeMinusOne","numOfSequenceParameterSets","numOfPictureParameterSets","nalSize","bufferSizeDB","maxBitrate","avgBitrate","edts","elst","edits","entryCount","mediaTime","mediaRate","esId","streamPriority","decoderConfig","objectProfileIndication","decoderConfigDescriptor","audioObjectType","samplingFrequencyIndex","channelConfiguration","majorBrand","minorVersion","compatibleBrands","dataReferences","name","escape","language","creationTime","modificationTime","streamDescriptor","rate","volume","matrix","Uint32Array","nextTrackId","pdin","initialDelay","sidx","balance","ctts","compositionOffsets","sampleOffset","stss","syncSamples","chunkOffsets","sampleToChunks","firstChunk","samplesPerChunk","sampleSize","entries","timeToSamples","sampleDelta","layer","alternateGroup","defaultSampleDescriptionIndex","sampleDependsOn","sampleIsDependedOn","sampleHasRedundancy","samplePaddingValue","sampleIsDifferenceSample","sampleDegradationPriority","graphicsmode","opcolor","Uint16Array","ab","ArrayBuffer","v","z","textifyMp4","inspectedMp4","indent","prefix","match","line","JSON","stringify","split","mp4Inspector","inspect","textify","parseTraf","parseHdlr","tagTypes","hex","toUpperCase","hexStringList","parseAVCTag","avcPacketTypes","compositionTime","parseInt","avcPacketType","CompositionTime","nalUnitTypeRaw","parseVideoTag","frameTypes","codecID","frameType","parseAACTag","packetTypes","aacPacketType","parseAudioTag","formatTable","samplingRateTable","soundFormat","soundRate","soundSize","soundType","parseGenericTag","tagType","dataSize","streamID","inspectFlvTag","inspectFlv","parsedResults","textifyFlv","flvTagArray","flvInspector","inspectTag","parsePid","parsePayloadUnitStartIndicator","parseAdaptionField","pusi","payloadOffset","parsePesType","parsePesTime","parseNalUnitType","videoPacketContainsKeyFrame","frameBuffer","frameI","frameSyncPoint","foundKeyFrame","nalType","probe$1","ts","SYNC_BYTE","parsePsi_","table","parseAudioPes_","pesType","parsed","endLoop","parseVideoPes_","firstKeyFrame","console","warn","adjustTimestamp_","segmentInfo","baseTimestamp","audioBaseTimestamp","dtsTime","ptsTime","videoBaseTimestamp","inspectAac_","audioCount","audioTimescale","inspectTs_","isAacData","tsInspector","mp2t","tools","lib"],"mappings":"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","sourcesContent":["/*! @name mux.js @version 6.0.1 @license Apache-2.0 */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('global/window')) :\n  typeof define === 'function' && define.amd ? define(['global/window'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.muxjs = factory(global.window));\n}(this, (function (window) { 'use strict';\n\n  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\n  var window__default = /*#__PURE__*/_interopDefaultLegacy(window);\n\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   *\n   * A lightweight readable stream implemention that handles event dispatching.\n   * Objects that inherit from streams should call init in their constructors.\n   */\n\n  var Stream = function Stream() {\n    this.init = function () {\n      var listeners = {};\n      /**\n       * Add a listener for a specified event type.\n       * @param type {string} the event name\n       * @param listener {function} the callback to be invoked when an event of\n       * the specified type occurs\n       */\n\n      this.on = function (type, listener) {\n        if (!listeners[type]) {\n          listeners[type] = [];\n        }\n\n        listeners[type] = listeners[type].concat(listener);\n      };\n      /**\n       * Remove a listener for a specified event type.\n       * @param type {string} the event name\n       * @param listener {function} a function previously registered for this\n       * type of event through `on`\n       */\n\n\n      this.off = function (type, listener) {\n        var index;\n\n        if (!listeners[type]) {\n          return false;\n        }\n\n        index = listeners[type].indexOf(listener);\n        listeners[type] = listeners[type].slice();\n        listeners[type].splice(index, 1);\n        return index > -1;\n      };\n      /**\n       * Trigger an event of the specified type on this stream. Any additional\n       * arguments to this function are passed as parameters to event listeners.\n       * @param type {string} the event name\n       */\n\n\n      this.trigger = function (type) {\n        var callbacks, i, length, args;\n        callbacks = listeners[type];\n\n        if (!callbacks) {\n          return;\n        } // Slicing the arguments on every invocation of this method\n        // can add a significant amount of overhead. Avoid the\n        // intermediate object creation for the common case of a\n        // single callback argument\n\n\n        if (arguments.length === 2) {\n          length = callbacks.length;\n\n          for (i = 0; i < length; ++i) {\n            callbacks[i].call(this, arguments[1]);\n          }\n        } else {\n          args = [];\n          i = arguments.length;\n\n          for (i = 1; i < arguments.length; ++i) {\n            args.push(arguments[i]);\n          }\n\n          length = callbacks.length;\n\n          for (i = 0; i < length; ++i) {\n            callbacks[i].apply(this, args);\n          }\n        }\n      };\n      /**\n       * Destroys the stream and cleans up.\n       */\n\n\n      this.dispose = function () {\n        listeners = {};\n      };\n    };\n  };\n  /**\n   * Forwards all `data` events on this stream to the destination stream. The\n   * destination stream should provide a method `push` to receive the data\n   * events as they arrive.\n   * @param destination {stream} the stream that will receive all `data` events\n   * @param autoFlush {boolean} if false, we will not call `flush` on the destination\n   *                            when the current stream emits a 'done' event\n   * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n   */\n\n\n  Stream.prototype.pipe = function (destination) {\n    this.on('data', function (data) {\n      destination.push(data);\n    });\n    this.on('done', function (flushSource) {\n      destination.flush(flushSource);\n    });\n    this.on('partialdone', function (flushSource) {\n      destination.partialFlush(flushSource);\n    });\n    this.on('endedtimeline', function (flushSource) {\n      destination.endTimeline(flushSource);\n    });\n    this.on('reset', function (flushSource) {\n      destination.reset(flushSource);\n    });\n    return destination;\n  }; // Default stream functions that are expected to be overridden to perform\n  // actual work. These are provided by the prototype as a sort of no-op\n  // implementation so that we don't have to check for their existence in the\n  // `pipe` function above.\n\n\n  Stream.prototype.push = function (data) {\n    this.trigger('data', data);\n  };\n\n  Stream.prototype.flush = function (flushSource) {\n    this.trigger('done', flushSource);\n  };\n\n  Stream.prototype.partialFlush = function (flushSource) {\n    this.trigger('partialdone', flushSource);\n  };\n\n  Stream.prototype.endTimeline = function (flushSource) {\n    this.trigger('endedtimeline', flushSource);\n  };\n\n  Stream.prototype.reset = function (flushSource) {\n    this.trigger('reset', flushSource);\n  };\n\n  var stream = Stream;\n\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n  var ONE_SECOND_IN_TS$5 = 90000,\n      // 90kHz clock\n  secondsToVideoTs,\n      secondsToAudioTs,\n      videoTsToSeconds,\n      audioTsToSeconds,\n      audioTsToVideoTs,\n      videoTsToAudioTs,\n      metadataTsToSeconds;\n\n  secondsToVideoTs = function secondsToVideoTs(seconds) {\n    return seconds * ONE_SECOND_IN_TS$5;\n  };\n\n  secondsToAudioTs = function secondsToAudioTs(seconds, sampleRate) {\n    return seconds * sampleRate;\n  };\n\n  videoTsToSeconds = function videoTsToSeconds(timestamp) {\n    return timestamp / ONE_SECOND_IN_TS$5;\n  };\n\n  audioTsToSeconds = function audioTsToSeconds(timestamp, sampleRate) {\n    return timestamp / sampleRate;\n  };\n\n  audioTsToVideoTs = function audioTsToVideoTs(timestamp, sampleRate) {\n    return secondsToVideoTs(audioTsToSeconds(timestamp, sampleRate));\n  };\n\n  videoTsToAudioTs = function videoTsToAudioTs(timestamp, sampleRate) {\n    return secondsToAudioTs(videoTsToSeconds(timestamp), sampleRate);\n  };\n  /**\n   * Adjust ID3 tag or caption timing information by the timeline pts values\n   * (if keepOriginalTimestamps is false) and convert to seconds\n   */\n\n\n  metadataTsToSeconds = function metadataTsToSeconds(timestamp, timelineStartPts, keepOriginalTimestamps) {\n    return videoTsToSeconds(keepOriginalTimestamps ? timestamp : timestamp - timelineStartPts);\n  };\n\n  var clock = {\n    ONE_SECOND_IN_TS: ONE_SECOND_IN_TS$5,\n    secondsToVideoTs: secondsToVideoTs,\n    secondsToAudioTs: secondsToAudioTs,\n    videoTsToSeconds: videoTsToSeconds,\n    audioTsToSeconds: audioTsToSeconds,\n    audioTsToVideoTs: audioTsToVideoTs,\n    videoTsToAudioTs: videoTsToAudioTs,\n    metadataTsToSeconds: metadataTsToSeconds\n  };\n\n  var ONE_SECOND_IN_TS$4 = clock.ONE_SECOND_IN_TS;\n\n  var _AdtsStream;\n\n  var ADTS_SAMPLING_FREQUENCIES$1 = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n  /*\n   * Accepts a ElementaryStream and emits data events with parsed\n   * AAC Audio Frames of the individual packets. Input audio in ADTS\n   * format is unpacked and re-emitted as AAC frames.\n   *\n   * @see http://wiki.multimedia.cx/index.php?title=ADTS\n   * @see http://wiki.multimedia.cx/?title=Understanding_AAC\n   */\n\n  _AdtsStream = function AdtsStream(handlePartialSegments) {\n    var buffer,\n        frameNum = 0;\n\n    _AdtsStream.prototype.init.call(this);\n\n    this.skipWarn_ = function (start, end) {\n      this.trigger('log', {\n        level: 'warn',\n        message: \"adts skiping bytes \" + start + \" to \" + end + \" in frame \" + frameNum + \" outside syncword\"\n      });\n    };\n\n    this.push = function (packet) {\n      var i = 0,\n          frameLength,\n          protectionSkipBytes,\n          oldBuffer,\n          sampleCount,\n          adtsFrameDuration;\n\n      if (!handlePartialSegments) {\n        frameNum = 0;\n      }\n\n      if (packet.type !== 'audio') {\n        // ignore non-audio data\n        return;\n      } // Prepend any data in the buffer to the input data so that we can parse\n      // aac frames the cross a PES packet boundary\n\n\n      if (buffer && buffer.length) {\n        oldBuffer = buffer;\n        buffer = new Uint8Array(oldBuffer.byteLength + packet.data.byteLength);\n        buffer.set(oldBuffer);\n        buffer.set(packet.data, oldBuffer.byteLength);\n      } else {\n        buffer = packet.data;\n      } // unpack any ADTS frames which have been fully received\n      // for details on the ADTS header, see http://wiki.multimedia.cx/index.php?title=ADTS\n\n\n      var skip; // We use i + 7 here because we want to be able to parse the entire header.\n      // If we don't have enough bytes to do that, then we definitely won't have a full frame.\n\n      while (i + 7 < buffer.length) {\n        // Look for the start of an ADTS header..\n        if (buffer[i] !== 0xFF || (buffer[i + 1] & 0xF6) !== 0xF0) {\n          if (typeof skip !== 'number') {\n            skip = i;\n          } // If a valid header was not found,  jump one forward and attempt to\n          // find a valid ADTS header starting at the next byte\n\n\n          i++;\n          continue;\n        }\n\n        if (typeof skip === 'number') {\n          this.skipWarn_(skip, i);\n          skip = null;\n        } // The protection skip bit tells us if we have 2 bytes of CRC data at the\n        // end of the ADTS header\n\n\n        protectionSkipBytes = (~buffer[i + 1] & 0x01) * 2; // Frame length is a 13 bit integer starting 16 bits from the\n        // end of the sync sequence\n        // NOTE: frame length includes the size of the header\n\n        frameLength = (buffer[i + 3] & 0x03) << 11 | buffer[i + 4] << 3 | (buffer[i + 5] & 0xe0) >> 5;\n        sampleCount = ((buffer[i + 6] & 0x03) + 1) * 1024;\n        adtsFrameDuration = sampleCount * ONE_SECOND_IN_TS$4 / ADTS_SAMPLING_FREQUENCIES$1[(buffer[i + 2] & 0x3c) >>> 2]; // If we don't have enough data to actually finish this ADTS frame,\n        // then we have to wait for more data\n\n        if (buffer.byteLength - i < frameLength) {\n          break;\n        } // Otherwise, deliver the complete AAC frame\n\n\n        this.trigger('data', {\n          pts: packet.pts + frameNum * adtsFrameDuration,\n          dts: packet.dts + frameNum * adtsFrameDuration,\n          sampleCount: sampleCount,\n          audioobjecttype: (buffer[i + 2] >>> 6 & 0x03) + 1,\n          channelcount: (buffer[i + 2] & 1) << 2 | (buffer[i + 3] & 0xc0) >>> 6,\n          samplerate: ADTS_SAMPLING_FREQUENCIES$1[(buffer[i + 2] & 0x3c) >>> 2],\n          samplingfrequencyindex: (buffer[i + 2] & 0x3c) >>> 2,\n          // assume ISO/IEC 14496-12 AudioSampleEntry default of 16\n          samplesize: 16,\n          // data is the frame without it's header\n          data: buffer.subarray(i + 7 + protectionSkipBytes, i + frameLength)\n        });\n        frameNum++;\n        i += frameLength;\n      }\n\n      if (typeof skip === 'number') {\n        this.skipWarn_(skip, i);\n        skip = null;\n      } // remove processed bytes from the buffer.\n\n\n      buffer = buffer.subarray(i);\n    };\n\n    this.flush = function () {\n      frameNum = 0;\n      this.trigger('done');\n    };\n\n    this.reset = function () {\n      buffer = void 0;\n      this.trigger('reset');\n    };\n\n    this.endTimeline = function () {\n      buffer = void 0;\n      this.trigger('endedtimeline');\n    };\n  };\n\n  _AdtsStream.prototype = new stream();\n  var adts = _AdtsStream;\n\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n\n  var ExpGolomb;\n  /**\n   * Parser for exponential Golomb codes, a variable-bitwidth number encoding\n   * scheme used by h264.\n   */\n\n  ExpGolomb = function ExpGolomb(workingData) {\n    var // the number of bytes left to examine in workingData\n    workingBytesAvailable = workingData.byteLength,\n        // the current word being examined\n    workingWord = 0,\n        // :uint\n    // the number of bits left to examine in the current word\n    workingBitsAvailable = 0; // :uint;\n    // ():uint\n\n    this.length = function () {\n      return 8 * workingBytesAvailable;\n    }; // ():uint\n\n\n    this.bitsAvailable = function () {\n      return 8 * workingBytesAvailable + workingBitsAvailable;\n    }; // ():void\n\n\n    this.loadWord = function () {\n      var position = workingData.byteLength - workingBytesAvailable,\n          workingBytes = new Uint8Array(4),\n          availableBytes = Math.min(4, workingBytesAvailable);\n\n      if (availableBytes === 0) {\n        throw new Error('no bytes available');\n      }\n\n      workingBytes.set(workingData.subarray(position, position + availableBytes));\n      workingWord = new DataView(workingBytes.buffer).getUint32(0); // track the amount of workingData that has been processed\n\n      workingBitsAvailable = availableBytes * 8;\n      workingBytesAvailable -= availableBytes;\n    }; // (count:int):void\n\n\n    this.skipBits = function (count) {\n      var skipBytes; // :int\n\n      if (workingBitsAvailable > count) {\n        workingWord <<= count;\n        workingBitsAvailable -= count;\n      } else {\n        count -= workingBitsAvailable;\n        skipBytes = Math.floor(count / 8);\n        count -= skipBytes * 8;\n        workingBytesAvailable -= skipBytes;\n        this.loadWord();\n        workingWord <<= count;\n        workingBitsAvailable -= count;\n      }\n    }; // (size:int):uint\n\n\n    this.readBits = function (size) {\n      var bits = Math.min(workingBitsAvailable, size),\n          // :uint\n      valu = workingWord >>> 32 - bits; // :uint\n      // if size > 31, handle error\n\n      workingBitsAvailable -= bits;\n\n      if (workingBitsAvailable > 0) {\n        workingWord <<= bits;\n      } else if (workingBytesAvailable > 0) {\n        this.loadWord();\n      }\n\n      bits = size - bits;\n\n      if (bits > 0) {\n        return valu << bits | this.readBits(bits);\n      }\n\n      return valu;\n    }; // ():uint\n\n\n    this.skipLeadingZeros = function () {\n      var leadingZeroCount; // :uint\n\n      for (leadingZeroCount = 0; leadingZeroCount < workingBitsAvailable; ++leadingZeroCount) {\n        if ((workingWord & 0x80000000 >>> leadingZeroCount) !== 0) {\n          // the first bit of working word is 1\n          workingWord <<= leadingZeroCount;\n          workingBitsAvailable -= leadingZeroCount;\n          return leadingZeroCount;\n        }\n      } // we exhausted workingWord and still have not found a 1\n\n\n      this.loadWord();\n      return leadingZeroCount + this.skipLeadingZeros();\n    }; // ():void\n\n\n    this.skipUnsignedExpGolomb = function () {\n      this.skipBits(1 + this.skipLeadingZeros());\n    }; // ():void\n\n\n    this.skipExpGolomb = function () {\n      this.skipBits(1 + this.skipLeadingZeros());\n    }; // ():uint\n\n\n    this.readUnsignedExpGolomb = function () {\n      var clz = this.skipLeadingZeros(); // :uint\n\n      return this.readBits(clz + 1) - 1;\n    }; // ():int\n\n\n    this.readExpGolomb = function () {\n      var valu = this.readUnsignedExpGolomb(); // :int\n\n      if (0x01 & valu) {\n        // the number is odd if the low order bit is set\n        return 1 + valu >>> 1; // add 1 to make it even, and divide by 2\n      }\n\n      return -1 * (valu >>> 1); // divide by two then make it negative\n    }; // Some convenience functions\n    // :Boolean\n\n\n    this.readBoolean = function () {\n      return this.readBits(1) === 1;\n    }; // ():int\n\n\n    this.readUnsignedByte = function () {\n      return this.readBits(8);\n    };\n\n    this.loadWord();\n  };\n\n  var expGolomb = ExpGolomb;\n\n  var _H264Stream, _NalByteStream;\n\n  var PROFILES_WITH_OPTIONAL_SPS_DATA;\n  /**\n   * Accepts a NAL unit byte stream and unpacks the embedded NAL units.\n   */\n\n  _NalByteStream = function NalByteStream() {\n    var syncPoint = 0,\n        i,\n        buffer;\n\n    _NalByteStream.prototype.init.call(this);\n    /*\n     * Scans a byte stream and triggers a data event with the NAL units found.\n     * @param {Object} data Event received from H264Stream\n     * @param {Uint8Array} data.data The h264 byte stream to be scanned\n     *\n     * @see H264Stream.push\n     */\n\n\n    this.push = function (data) {\n      var swapBuffer;\n\n      if (!buffer) {\n        buffer = data.data;\n      } else {\n        swapBuffer = new Uint8Array(buffer.byteLength + data.data.byteLength);\n        swapBuffer.set(buffer);\n        swapBuffer.set(data.data, buffer.byteLength);\n        buffer = swapBuffer;\n      }\n\n      var len = buffer.byteLength; // Rec. ITU-T H.264, Annex B\n      // scan for NAL unit boundaries\n      // a match looks like this:\n      // 0 0 1 .. NAL .. 0 0 1\n      // ^ sync point        ^ i\n      // or this:\n      // 0 0 1 .. NAL .. 0 0 0\n      // ^ sync point        ^ i\n      // advance the sync point to a NAL start, if necessary\n\n      for (; syncPoint < len - 3; syncPoint++) {\n        if (buffer[syncPoint + 2] === 1) {\n          // the sync point is properly aligned\n          i = syncPoint + 5;\n          break;\n        }\n      }\n\n      while (i < len) {\n        // look at the current byte to determine if we've hit the end of\n        // a NAL unit boundary\n        switch (buffer[i]) {\n          case 0:\n            // skip past non-sync sequences\n            if (buffer[i - 1] !== 0) {\n              i += 2;\n              break;\n            } else if (buffer[i - 2] !== 0) {\n              i++;\n              break;\n            } // deliver the NAL unit if it isn't empty\n\n\n            if (syncPoint + 3 !== i - 2) {\n              this.trigger('data', buffer.subarray(syncPoint + 3, i - 2));\n            } // drop trailing zeroes\n\n\n            do {\n              i++;\n            } while (buffer[i] !== 1 && i < len);\n\n            syncPoint = i - 2;\n            i += 3;\n            break;\n\n          case 1:\n            // skip past non-sync sequences\n            if (buffer[i - 1] !== 0 || buffer[i - 2] !== 0) {\n              i += 3;\n              break;\n            } // deliver the NAL unit\n\n\n            this.trigger('data', buffer.subarray(syncPoint + 3, i - 2));\n            syncPoint = i - 2;\n            i += 3;\n            break;\n\n          default:\n            // the current byte isn't a one or zero, so it cannot be part\n            // of a sync sequence\n            i += 3;\n            break;\n        }\n      } // filter out the NAL units that were delivered\n\n\n      buffer = buffer.subarray(syncPoint);\n      i -= syncPoint;\n      syncPoint = 0;\n    };\n\n    this.reset = function () {\n      buffer = null;\n      syncPoint = 0;\n      this.trigger('reset');\n    };\n\n    this.flush = function () {\n      // deliver the last buffered NAL unit\n      if (buffer && buffer.byteLength > 3) {\n        this.trigger('data', buffer.subarray(syncPoint + 3));\n      } // reset the stream state\n\n\n      buffer = null;\n      syncPoint = 0;\n      this.trigger('done');\n    };\n\n    this.endTimeline = function () {\n      this.flush();\n      this.trigger('endedtimeline');\n    };\n  };\n\n  _NalByteStream.prototype = new stream(); // values of profile_idc that indicate additional fields are included in the SPS\n  // see Recommendation ITU-T H.264 (4/2013),\n  // 7.3.2.1.1 Sequence parameter set data syntax\n\n  PROFILES_WITH_OPTIONAL_SPS_DATA = {\n    100: true,\n    110: true,\n    122: true,\n    244: true,\n    44: true,\n    83: true,\n    86: true,\n    118: true,\n    128: true,\n    // TODO: the three profiles below don't\n    // appear to have sps data in the specificiation anymore?\n    138: true,\n    139: true,\n    134: true\n  };\n  /**\n   * Accepts input from a ElementaryStream and produces H.264 NAL unit data\n   * events.\n   */\n\n  _H264Stream = function H264Stream() {\n    var nalByteStream = new _NalByteStream(),\n        self,\n        trackId,\n        currentPts,\n        currentDts,\n        discardEmulationPreventionBytes,\n        readSequenceParameterSet,\n        skipScalingList;\n\n    _H264Stream.prototype.init.call(this);\n\n    self = this;\n    /*\n     * Pushes a packet from a stream onto the NalByteStream\n     *\n     * @param {Object} packet - A packet received from a stream\n     * @param {Uint8Array} packet.data - The raw bytes of the packet\n     * @param {Number} packet.dts - Decode timestamp of the packet\n     * @param {Number} packet.pts - Presentation timestamp of the packet\n     * @param {Number} packet.trackId - The id of the h264 track this packet came from\n     * @param {('video'|'audio')} packet.type - The type of packet\n     *\n     */\n\n    this.push = function (packet) {\n      if (packet.type !== 'video') {\n        return;\n      }\n\n      trackId = packet.trackId;\n      currentPts = packet.pts;\n      currentDts = packet.dts;\n      nalByteStream.push(packet);\n    };\n    /*\n     * Identify NAL unit types and pass on the NALU, trackId, presentation and decode timestamps\n     * for the NALUs to the next stream component.\n     * Also, preprocess caption and sequence parameter NALUs.\n     *\n     * @param {Uint8Array} data - A NAL unit identified by `NalByteStream.push`\n     * @see NalByteStream.push\n     */\n\n\n    nalByteStream.on('data', function (data) {\n      var event = {\n        trackId: trackId,\n        pts: currentPts,\n        dts: currentDts,\n        data: data,\n        nalUnitTypeCode: data[0] & 0x1f\n      };\n\n      switch (event.nalUnitTypeCode) {\n        case 0x05:\n          event.nalUnitType = 'slice_layer_without_partitioning_rbsp_idr';\n          break;\n\n        case 0x06:\n          event.nalUnitType = 'sei_rbsp';\n          event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));\n          break;\n\n        case 0x07:\n          event.nalUnitType = 'seq_parameter_set_rbsp';\n          event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));\n          event.config = readSequenceParameterSet(event.escapedRBSP);\n          break;\n\n        case 0x08:\n          event.nalUnitType = 'pic_parameter_set_rbsp';\n          break;\n\n        case 0x09:\n          event.nalUnitType = 'access_unit_delimiter_rbsp';\n          break;\n      } // This triggers data on the H264Stream\n\n\n      self.trigger('data', event);\n    });\n    nalByteStream.on('done', function () {\n      self.trigger('done');\n    });\n    nalByteStream.on('partialdone', function () {\n      self.trigger('partialdone');\n    });\n    nalByteStream.on('reset', function () {\n      self.trigger('reset');\n    });\n    nalByteStream.on('endedtimeline', function () {\n      self.trigger('endedtimeline');\n    });\n\n    this.flush = function () {\n      nalByteStream.flush();\n    };\n\n    this.partialFlush = function () {\n      nalByteStream.partialFlush();\n    };\n\n    this.reset = function () {\n      nalByteStream.reset();\n    };\n\n    this.endTimeline = function () {\n      nalByteStream.endTimeline();\n    };\n    /**\n     * Advance the ExpGolomb decoder past a scaling list. The scaling\n     * list is optionally transmitted as part of a sequence parameter\n     * set and is not relevant to transmuxing.\n     * @param count {number} the number of entries in this scaling list\n     * @param expGolombDecoder {object} an ExpGolomb pointed to the\n     * start of a scaling list\n     * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1\n     */\n\n\n    skipScalingList = function skipScalingList(count, expGolombDecoder) {\n      var lastScale = 8,\n          nextScale = 8,\n          j,\n          deltaScale;\n\n      for (j = 0; j < count; j++) {\n        if (nextScale !== 0) {\n          deltaScale = expGolombDecoder.readExpGolomb();\n          nextScale = (lastScale + deltaScale + 256) % 256;\n        }\n\n        lastScale = nextScale === 0 ? lastScale : nextScale;\n      }\n    };\n    /**\n     * Expunge any \"Emulation Prevention\" bytes from a \"Raw Byte\n     * Sequence Payload\"\n     * @param data {Uint8Array} the bytes of a RBSP from a NAL\n     * unit\n     * @return {Uint8Array} the RBSP without any Emulation\n     * Prevention Bytes\n     */\n\n\n    discardEmulationPreventionBytes = function discardEmulationPreventionBytes(data) {\n      var length = data.byteLength,\n          emulationPreventionBytesPositions = [],\n          i = 1,\n          newLength,\n          newData; // Find all `Emulation Prevention Bytes`\n\n      while (i < length - 2) {\n        if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n          emulationPreventionBytesPositions.push(i + 2);\n          i += 2;\n        } else {\n          i++;\n        }\n      } // If no Emulation Prevention Bytes were found just return the original\n      // array\n\n\n      if (emulationPreventionBytesPositions.length === 0) {\n        return data;\n      } // Create a new array to hold the NAL unit data\n\n\n      newLength = length - emulationPreventionBytesPositions.length;\n      newData = new Uint8Array(newLength);\n      var sourceIndex = 0;\n\n      for (i = 0; i < newLength; sourceIndex++, i++) {\n        if (sourceIndex === emulationPreventionBytesPositions[0]) {\n          // Skip this byte\n          sourceIndex++; // Remove this position index\n\n          emulationPreventionBytesPositions.shift();\n        }\n\n        newData[i] = data[sourceIndex];\n      }\n\n      return newData;\n    };\n    /**\n     * Read a sequence parameter set and return some interesting video\n     * properties. A sequence parameter set is the H264 metadata that\n     * describes the properties of upcoming video frames.\n     * @param data {Uint8Array} the bytes of a sequence parameter set\n     * @return {object} an object with configuration parsed from the\n     * sequence parameter set, including the dimensions of the\n     * associated video frames.\n     */\n\n\n    readSequenceParameterSet = function readSequenceParameterSet(data) {\n      var frameCropLeftOffset = 0,\n          frameCropRightOffset = 0,\n          frameCropTopOffset = 0,\n          frameCropBottomOffset = 0,\n          expGolombDecoder,\n          profileIdc,\n          levelIdc,\n          profileCompatibility,\n          chromaFormatIdc,\n          picOrderCntType,\n          numRefFramesInPicOrderCntCycle,\n          picWidthInMbsMinus1,\n          picHeightInMapUnitsMinus1,\n          frameMbsOnlyFlag,\n          scalingListCount,\n          sarRatio = [1, 1],\n          aspectRatioIdc,\n          i;\n      expGolombDecoder = new expGolomb(data);\n      profileIdc = expGolombDecoder.readUnsignedByte(); // profile_idc\n\n      profileCompatibility = expGolombDecoder.readUnsignedByte(); // constraint_set[0-5]_flag\n\n      levelIdc = expGolombDecoder.readUnsignedByte(); // level_idc u(8)\n\n      expGolombDecoder.skipUnsignedExpGolomb(); // seq_parameter_set_id\n      // some profiles have more optional data we don't need\n\n      if (PROFILES_WITH_OPTIONAL_SPS_DATA[profileIdc]) {\n        chromaFormatIdc = expGolombDecoder.readUnsignedExpGolomb();\n\n        if (chromaFormatIdc === 3) {\n          expGolombDecoder.skipBits(1); // separate_colour_plane_flag\n        }\n\n        expGolombDecoder.skipUnsignedExpGolomb(); // bit_depth_luma_minus8\n\n        expGolombDecoder.skipUnsignedExpGolomb(); // bit_depth_chroma_minus8\n\n        expGolombDecoder.skipBits(1); // qpprime_y_zero_transform_bypass_flag\n\n        if (expGolombDecoder.readBoolean()) {\n          // seq_scaling_matrix_present_flag\n          scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;\n\n          for (i = 0; i < scalingListCount; i++) {\n            if (expGolombDecoder.readBoolean()) {\n              // seq_scaling_list_present_flag[ i ]\n              if (i < 6) {\n                skipScalingList(16, expGolombDecoder);\n              } else {\n                skipScalingList(64, expGolombDecoder);\n              }\n            }\n          }\n        }\n      }\n\n      expGolombDecoder.skipUnsignedExpGolomb(); // log2_max_frame_num_minus4\n\n      picOrderCntType = expGolombDecoder.readUnsignedExpGolomb();\n\n      if (picOrderCntType === 0) {\n        expGolombDecoder.readUnsignedExpGolomb(); // log2_max_pic_order_cnt_lsb_minus4\n      } else if (picOrderCntType === 1) {\n        expGolombDecoder.skipBits(1); // delta_pic_order_always_zero_flag\n\n        expGolombDecoder.skipExpGolomb(); // offset_for_non_ref_pic\n\n        expGolombDecoder.skipExpGolomb(); // offset_for_top_to_bottom_field\n\n        numRefFramesInPicOrderCntCycle = expGolombDecoder.readUnsignedExpGolomb();\n\n        for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n          expGolombDecoder.skipExpGolomb(); // offset_for_ref_frame[ i ]\n        }\n      }\n\n      expGolombDecoder.skipUnsignedExpGolomb(); // max_num_ref_frames\n\n      expGolombDecoder.skipBits(1); // gaps_in_frame_num_value_allowed_flag\n\n      picWidthInMbsMinus1 = expGolombDecoder.readUnsignedExpGolomb();\n      picHeightInMapUnitsMinus1 = expGolombDecoder.readUnsignedExpGolomb();\n      frameMbsOnlyFlag = expGolombDecoder.readBits(1);\n\n      if (frameMbsOnlyFlag === 0) {\n        expGolombDecoder.skipBits(1); // mb_adaptive_frame_field_flag\n      }\n\n      expGolombDecoder.skipBits(1); // direct_8x8_inference_flag\n\n      if (expGolombDecoder.readBoolean()) {\n        // frame_cropping_flag\n        frameCropLeftOffset = expGolombDecoder.readUnsignedExpGolomb();\n        frameCropRightOffset = expGolombDecoder.readUnsignedExpGolomb();\n        frameCropTopOffset = expGolombDecoder.readUnsignedExpGolomb();\n        frameCropBottomOffset = expGolombDecoder.readUnsignedExpGolomb();\n      }\n\n      if (expGolombDecoder.readBoolean()) {\n        // vui_parameters_present_flag\n        if (expGolombDecoder.readBoolean()) {\n          // aspect_ratio_info_present_flag\n          aspectRatioIdc = expGolombDecoder.readUnsignedByte();\n\n          switch (aspectRatioIdc) {\n            case 1:\n              sarRatio = [1, 1];\n              break;\n\n            case 2:\n              sarRatio = [12, 11];\n              break;\n\n            case 3:\n              sarRatio = [10, 11];\n              break;\n\n            case 4:\n              sarRatio = [16, 11];\n              break;\n\n            case 5:\n              sarRatio = [40, 33];\n              break;\n\n            case 6:\n              sarRatio = [24, 11];\n              break;\n\n            case 7:\n              sarRatio = [20, 11];\n              break;\n\n            case 8:\n              sarRatio = [32, 11];\n              break;\n\n            case 9:\n              sarRatio = [80, 33];\n              break;\n\n            case 10:\n              sarRatio = [18, 11];\n              break;\n\n            case 11:\n              sarRatio = [15, 11];\n              break;\n\n            case 12:\n              sarRatio = [64, 33];\n              break;\n\n            case 13:\n              sarRatio = [160, 99];\n              break;\n\n            case 14:\n              sarRatio = [4, 3];\n              break;\n\n            case 15:\n              sarRatio = [3, 2];\n              break;\n\n            case 16:\n              sarRatio = [2, 1];\n              break;\n\n            case 255:\n              {\n                sarRatio = [expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte(), expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte()];\n                break;\n              }\n          }\n\n          if (sarRatio) {\n            sarRatio[0] / sarRatio[1];\n          }\n        }\n      }\n\n      return {\n        profileIdc: profileIdc,\n        levelIdc: levelIdc,\n        profileCompatibility: profileCompatibility,\n        width: (picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2,\n        height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - frameCropTopOffset * 2 - frameCropBottomOffset * 2,\n        // sar is sample aspect ratio\n        sarRatio: sarRatio\n      };\n    };\n  };\n\n  _H264Stream.prototype = new stream();\n  var h264 = {\n    H264Stream: _H264Stream,\n    NalByteStream: _NalByteStream\n  };\n\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n\n  var codecs = {\n    Adts: adts,\n    h264: h264\n  };\n\n  var MAX_UINT32$1 = Math.pow(2, 32);\n\n  var getUint64$4 = function getUint64(uint8) {\n    var dv = new DataView(uint8.buffer, uint8.byteOffset, uint8.byteLength);\n    var value;\n\n    if (dv.getBigUint64) {\n      value = dv.getBigUint64(0);\n\n      if (value < Number.MAX_SAFE_INTEGER) {\n        return Number(value);\n      }\n\n      return value;\n    }\n\n    return dv.getUint32(0) * MAX_UINT32$1 + dv.getUint32(4);\n  };\n\n  var numbers = {\n    getUint64: getUint64$4,\n    MAX_UINT32: MAX_UINT32$1\n  };\n\n  var MAX_UINT32 = numbers.MAX_UINT32;\n  var box, dinf, esds, ftyp, mdat, mfhd, minf, moof, moov, mvex, mvhd, trak, tkhd, mdia, mdhd, hdlr, sdtp, stbl, stsd, traf, trex, trun$1, types, MAJOR_BRAND, MINOR_VERSION, AVC1_BRAND, VIDEO_HDLR, AUDIO_HDLR, HDLR_TYPES, VMHD, SMHD, DREF, STCO, STSC, STSZ, STTS; // pre-calculate constants\n\n  (function () {\n    var i;\n    types = {\n      avc1: [],\n      // codingname\n      avcC: [],\n      btrt: [],\n      dinf: [],\n      dref: [],\n      esds: [],\n      ftyp: [],\n      hdlr: [],\n      mdat: [],\n      mdhd: [],\n      mdia: [],\n      mfhd: [],\n      minf: [],\n      moof: [],\n      moov: [],\n      mp4a: [],\n      // codingname\n      mvex: [],\n      mvhd: [],\n      pasp: [],\n      sdtp: [],\n      smhd: [],\n      stbl: [],\n      stco: [],\n      stsc: [],\n      stsd: [],\n      stsz: [],\n      stts: [],\n      styp: [],\n      tfdt: [],\n      tfhd: [],\n      traf: [],\n      trak: [],\n      trun: [],\n      trex: [],\n      tkhd: [],\n      vmhd: []\n    }; // In environments where Uint8Array is undefined (e.g., IE8), skip set up so that we\n    // don't throw an error\n\n    if (typeof Uint8Array === 'undefined') {\n      return;\n    }\n\n    for (i in types) {\n      if (types.hasOwnProperty(i)) {\n        types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];\n      }\n    }\n\n    MAJOR_BRAND = new Uint8Array(['i'.charCodeAt(0), 's'.charCodeAt(0), 'o'.charCodeAt(0), 'm'.charCodeAt(0)]);\n    AVC1_BRAND = new Uint8Array(['a'.charCodeAt(0), 'v'.charCodeAt(0), 'c'.charCodeAt(0), '1'.charCodeAt(0)]);\n    MINOR_VERSION = new Uint8Array([0, 0, 0, 1]);\n    VIDEO_HDLR = new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // pre_defined\n    0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n    ]);\n    AUDIO_HDLR = new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // pre_defined\n    0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\n    ]);\n    HDLR_TYPES = {\n      video: VIDEO_HDLR,\n      audio: AUDIO_HDLR\n    };\n    DREF = new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x01, // entry_count\n    0x00, 0x00, 0x00, 0x0c, // entry_size\n    0x75, 0x72, 0x6c, 0x20, // 'url' type\n    0x00, // version 0\n    0x00, 0x00, 0x01 // entry_flags\n    ]);\n    SMHD = new Uint8Array([0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, // balance, 0 means centered\n    0x00, 0x00 // reserved\n    ]);\n    STCO = new Uint8Array([0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00 // entry_count\n    ]);\n    STSC = STCO;\n    STSZ = new Uint8Array([0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // sample_size\n    0x00, 0x00, 0x00, 0x00 // sample_count\n    ]);\n    STTS = STCO;\n    VMHD = new Uint8Array([0x00, // version\n    0x00, 0x00, 0x01, // flags\n    0x00, 0x00, // graphicsmode\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor\n    ]);\n  })();\n\n  box = function box(type) {\n    var payload = [],\n        size = 0,\n        i,\n        result,\n        view;\n\n    for (i = 1; i < arguments.length; i++) {\n      payload.push(arguments[i]);\n    }\n\n    i = payload.length; // calculate the total size we need to allocate\n\n    while (i--) {\n      size += payload[i].byteLength;\n    }\n\n    result = new Uint8Array(size + 8);\n    view = new DataView(result.buffer, result.byteOffset, result.byteLength);\n    view.setUint32(0, result.byteLength);\n    result.set(type, 4); // copy the payload into the result\n\n    for (i = 0, size = 8; i < payload.length; i++) {\n      result.set(payload[i], size);\n      size += payload[i].byteLength;\n    }\n\n    return result;\n  };\n\n  dinf = function dinf() {\n    return box(types.dinf, box(types.dref, DREF));\n  };\n\n  esds = function esds(track) {\n    return box(types.esds, new Uint8Array([0x00, // version\n    0x00, 0x00, 0x00, // flags\n    // ES_Descriptor\n    0x03, // tag, ES_DescrTag\n    0x19, // length\n    0x00, 0x00, // ES_ID\n    0x00, // streamDependenceFlag, URL_flag, reserved, streamPriority\n    // DecoderConfigDescriptor\n    0x04, // tag, DecoderConfigDescrTag\n    0x11, // length\n    0x40, // object type\n    0x15, // streamType\n    0x00, 0x06, 0x00, // bufferSizeDB\n    0x00, 0x00, 0xda, 0xc0, // maxBitrate\n    0x00, 0x00, 0xda, 0xc0, // avgBitrate\n    // DecoderSpecificInfo\n    0x05, // tag, DecoderSpecificInfoTag\n    0x02, // length\n    // ISO/IEC 14496-3, AudioSpecificConfig\n    // for samplingFrequencyIndex see ISO/IEC 13818-7:2006, 8.1.3.2.2, Table 35\n    track.audioobjecttype << 3 | track.samplingfrequencyindex >>> 1, track.samplingfrequencyindex << 7 | track.channelcount << 3, 0x06, 0x01, 0x02 // GASpecificConfig\n    ]));\n  };\n\n  ftyp = function ftyp() {\n    return box(types.ftyp, MAJOR_BRAND, MINOR_VERSION, MAJOR_BRAND, AVC1_BRAND);\n  };\n\n  hdlr = function hdlr(type) {\n    return box(types.hdlr, HDLR_TYPES[type]);\n  };\n\n  mdat = function mdat(data) {\n    return box(types.mdat, data);\n  };\n\n  mdhd = function mdhd(track) {\n    var result = new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x02, // creation_time\n    0x00, 0x00, 0x00, 0x03, // modification_time\n    0x00, 0x01, 0x5f, 0x90, // timescale, 90,000 \"ticks\" per second\n    track.duration >>> 24 & 0xFF, track.duration >>> 16 & 0xFF, track.duration >>> 8 & 0xFF, track.duration & 0xFF, // duration\n    0x55, 0xc4, // 'und' language (undetermined)\n    0x00, 0x00]); // Use the sample rate from the track metadata, when it is\n    // defined. The sample rate can be parsed out of an ADTS header, for\n    // instance.\n\n    if (track.samplerate) {\n      result[12] = track.samplerate >>> 24 & 0xFF;\n      result[13] = track.samplerate >>> 16 & 0xFF;\n      result[14] = track.samplerate >>> 8 & 0xFF;\n      result[15] = track.samplerate & 0xFF;\n    }\n\n    return box(types.mdhd, result);\n  };\n\n  mdia = function mdia(track) {\n    return box(types.mdia, mdhd(track), hdlr(track.type), minf(track));\n  };\n\n  mfhd = function mfhd(sequenceNumber) {\n    return box(types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00, // flags\n    (sequenceNumber & 0xFF000000) >> 24, (sequenceNumber & 0xFF0000) >> 16, (sequenceNumber & 0xFF00) >> 8, sequenceNumber & 0xFF // sequence_number\n    ]));\n  };\n\n  minf = function minf(track) {\n    return box(types.minf, track.type === 'video' ? box(types.vmhd, VMHD) : box(types.smhd, SMHD), dinf(), stbl(track));\n  };\n\n  moof = function moof(sequenceNumber, tracks) {\n    var trackFragments = [],\n        i = tracks.length; // build traf boxes for each track fragment\n\n    while (i--) {\n      trackFragments[i] = traf(tracks[i]);\n    }\n\n    return box.apply(null, [types.moof, mfhd(sequenceNumber)].concat(trackFragments));\n  };\n  /**\n   * Returns a movie box.\n   * @param tracks {array} the tracks associated with this movie\n   * @see ISO/IEC 14496-12:2012(E), section 8.2.1\n   */\n\n\n  moov = function moov(tracks) {\n    var i = tracks.length,\n        boxes = [];\n\n    while (i--) {\n      boxes[i] = trak(tracks[i]);\n    }\n\n    return box.apply(null, [types.moov, mvhd(0xffffffff)].concat(boxes).concat(mvex(tracks)));\n  };\n\n  mvex = function mvex(tracks) {\n    var i = tracks.length,\n        boxes = [];\n\n    while (i--) {\n      boxes[i] = trex(tracks[i]);\n    }\n\n    return box.apply(null, [types.mvex].concat(boxes));\n  };\n\n  mvhd = function mvhd(duration) {\n    var bytes = new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x01, // creation_time\n    0x00, 0x00, 0x00, 0x02, // modification_time\n    0x00, 0x01, 0x5f, 0x90, // timescale, 90,000 \"ticks\" per second\n    (duration & 0xFF000000) >> 24, (duration & 0xFF0000) >> 16, (duration & 0xFF00) >> 8, duration & 0xFF, // duration\n    0x00, 0x01, 0x00, 0x00, // 1.0 rate\n    0x01, 0x00, // 1.0 volume\n    0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined\n    0xff, 0xff, 0xff, 0xff // next_track_ID\n    ]);\n    return box(types.mvhd, bytes);\n  };\n\n  sdtp = function sdtp(track) {\n    var samples = track.samples || [],\n        bytes = new Uint8Array(4 + samples.length),\n        flags,\n        i; // leave the full box header (4 bytes) all zero\n    // write the sample table\n\n    for (i = 0; i < samples.length; i++) {\n      flags = samples[i].flags;\n      bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;\n    }\n\n    return box(types.sdtp, bytes);\n  };\n\n  stbl = function stbl(track) {\n    return box(types.stbl, stsd(track), box(types.stts, STTS), box(types.stsc, STSC), box(types.stsz, STSZ), box(types.stco, STCO));\n  };\n\n  (function () {\n    var videoSample, audioSample;\n\n    stsd = function stsd(track) {\n      return box(types.stsd, new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x01]), track.type === 'video' ? videoSample(track) : audioSample(track));\n    };\n\n    videoSample = function videoSample(track) {\n      var sps = track.sps || [],\n          pps = track.pps || [],\n          sequenceParameterSets = [],\n          pictureParameterSets = [],\n          i,\n          avc1Box; // assemble the SPSs\n\n      for (i = 0; i < sps.length; i++) {\n        sequenceParameterSets.push((sps[i].byteLength & 0xFF00) >>> 8);\n        sequenceParameterSets.push(sps[i].byteLength & 0xFF); // sequenceParameterSetLength\n\n        sequenceParameterSets = sequenceParameterSets.concat(Array.prototype.slice.call(sps[i])); // SPS\n      } // assemble the PPSs\n\n\n      for (i = 0; i < pps.length; i++) {\n        pictureParameterSets.push((pps[i].byteLength & 0xFF00) >>> 8);\n        pictureParameterSets.push(pps[i].byteLength & 0xFF);\n        pictureParameterSets = pictureParameterSets.concat(Array.prototype.slice.call(pps[i]));\n      }\n\n      avc1Box = [types.avc1, new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n      0x00, 0x00, // pre_defined\n      0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined\n      (track.width & 0xff00) >> 8, track.width & 0xff, // width\n      (track.height & 0xff00) >> 8, track.height & 0xff, // height\n      0x00, 0x48, 0x00, 0x00, // horizresolution\n      0x00, 0x48, 0x00, 0x00, // vertresolution\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // frame_count\n      0x13, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x6a, 0x73, 0x2d, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x69, 0x62, 0x2d, 0x68, 0x6c, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // compressorname\n      0x00, 0x18, // depth = 24\n      0x11, 0x11 // pre_defined = -1\n      ]), box(types.avcC, new Uint8Array([0x01, // configurationVersion\n      track.profileIdc, // AVCProfileIndication\n      track.profileCompatibility, // profile_compatibility\n      track.levelIdc, // AVCLevelIndication\n      0xff // lengthSizeMinusOne, hard-coded to 4 bytes\n      ].concat([sps.length], // numOfSequenceParameterSets\n      sequenceParameterSets, // \"SPS\"\n      [pps.length], // numOfPictureParameterSets\n      pictureParameterSets // \"PPS\"\n      ))), box(types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB\n      0x00, 0x2d, 0xc6, 0xc0, // maxBitrate\n      0x00, 0x2d, 0xc6, 0xc0 // avgBitrate\n      ]))];\n\n      if (track.sarRatio) {\n        var hSpacing = track.sarRatio[0],\n            vSpacing = track.sarRatio[1];\n        avc1Box.push(box(types.pasp, new Uint8Array([(hSpacing & 0xFF000000) >> 24, (hSpacing & 0xFF0000) >> 16, (hSpacing & 0xFF00) >> 8, hSpacing & 0xFF, (vSpacing & 0xFF000000) >> 24, (vSpacing & 0xFF0000) >> 16, (vSpacing & 0xFF00) >> 8, vSpacing & 0xFF])));\n      }\n\n      return box.apply(null, avc1Box);\n    };\n\n    audioSample = function audioSample(track) {\n      return box(types.mp4a, new Uint8Array([// SampleEntry, ISO/IEC 14496-12\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n      // AudioSampleEntry, ISO/IEC 14496-12\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      (track.channelcount & 0xff00) >> 8, track.channelcount & 0xff, // channelcount\n      (track.samplesize & 0xff00) >> 8, track.samplesize & 0xff, // samplesize\n      0x00, 0x00, // pre_defined\n      0x00, 0x00, // reserved\n      (track.samplerate & 0xff00) >> 8, track.samplerate & 0xff, 0x00, 0x00 // samplerate, 16.16\n      // MP4AudioSampleEntry, ISO/IEC 14496-14\n      ]), esds(track));\n    };\n  })();\n\n  tkhd = function tkhd(track) {\n    var result = new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x07, // flags\n    0x00, 0x00, 0x00, 0x00, // creation_time\n    0x00, 0x00, 0x00, 0x00, // modification_time\n    (track.id & 0xFF000000) >> 24, (track.id & 0xFF0000) >> 16, (track.id & 0xFF00) >> 8, track.id & 0xFF, // track_ID\n    0x00, 0x00, 0x00, 0x00, // reserved\n    (track.duration & 0xFF000000) >> 24, (track.duration & 0xFF0000) >> 16, (track.duration & 0xFF00) >> 8, track.duration & 0xFF, // duration\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, // layer\n    0x00, 0x00, // alternate_group\n    0x01, 0x00, // non-audio track volume\n    0x00, 0x00, // reserved\n    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\n    (track.width & 0xFF00) >> 8, track.width & 0xFF, 0x00, 0x00, // width\n    (track.height & 0xFF00) >> 8, track.height & 0xFF, 0x00, 0x00 // height\n    ]);\n    return box(types.tkhd, result);\n  };\n  /**\n   * Generate a track fragment (traf) box. A traf box collects metadata\n   * about tracks in a movie fragment (moof) box.\n   */\n\n\n  traf = function traf(track) {\n    var trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable, dataOffset, upperWordBaseMediaDecodeTime, lowerWordBaseMediaDecodeTime;\n    trackFragmentHeader = box(types.tfhd, new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x3a, // flags\n    (track.id & 0xFF000000) >> 24, (track.id & 0xFF0000) >> 16, (track.id & 0xFF00) >> 8, track.id & 0xFF, // track_ID\n    0x00, 0x00, 0x00, 0x01, // sample_description_index\n    0x00, 0x00, 0x00, 0x00, // default_sample_duration\n    0x00, 0x00, 0x00, 0x00, // default_sample_size\n    0x00, 0x00, 0x00, 0x00 // default_sample_flags\n    ]));\n    upperWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime / MAX_UINT32);\n    lowerWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime % MAX_UINT32);\n    trackFragmentDecodeTime = box(types.tfdt, new Uint8Array([0x01, // version 1\n    0x00, 0x00, 0x00, // flags\n    // baseMediaDecodeTime\n    upperWordBaseMediaDecodeTime >>> 24 & 0xFF, upperWordBaseMediaDecodeTime >>> 16 & 0xFF, upperWordBaseMediaDecodeTime >>> 8 & 0xFF, upperWordBaseMediaDecodeTime & 0xFF, lowerWordBaseMediaDecodeTime >>> 24 & 0xFF, lowerWordBaseMediaDecodeTime >>> 16 & 0xFF, lowerWordBaseMediaDecodeTime >>> 8 & 0xFF, lowerWordBaseMediaDecodeTime & 0xFF])); // the data offset specifies the number of bytes from the start of\n    // the containing moof to the first payload byte of the associated\n    // mdat\n\n    dataOffset = 32 + // tfhd\n    20 + // tfdt\n    8 + // traf header\n    16 + // mfhd\n    8 + // moof header\n    8; // mdat header\n    // audio tracks require less metadata\n\n    if (track.type === 'audio') {\n      trackFragmentRun = trun$1(track, dataOffset);\n      return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun);\n    } // video tracks should contain an independent and disposable samples\n    // box (sdtp)\n    // generate one and adjust offsets to match\n\n\n    sampleDependencyTable = sdtp(track);\n    trackFragmentRun = trun$1(track, sampleDependencyTable.length + dataOffset);\n    return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable);\n  };\n  /**\n   * Generate a track box.\n   * @param track {object} a track definition\n   * @return {Uint8Array} the track box\n   */\n\n\n  trak = function trak(track) {\n    track.duration = track.duration || 0xffffffff;\n    return box(types.trak, tkhd(track), mdia(track));\n  };\n\n  trex = function trex(track) {\n    var result = new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    (track.id & 0xFF000000) >> 24, (track.id & 0xFF0000) >> 16, (track.id & 0xFF00) >> 8, track.id & 0xFF, // track_ID\n    0x00, 0x00, 0x00, 0x01, // default_sample_description_index\n    0x00, 0x00, 0x00, 0x00, // default_sample_duration\n    0x00, 0x00, 0x00, 0x00, // default_sample_size\n    0x00, 0x01, 0x00, 0x01 // default_sample_flags\n    ]); // the last two bytes of default_sample_flags is the sample\n    // degradation priority, a hint about the importance of this sample\n    // relative to others. Lower the degradation priority for all sample\n    // types other than video.\n\n    if (track.type !== 'video') {\n      result[result.length - 1] = 0x00;\n    }\n\n    return box(types.trex, result);\n  };\n\n  (function () {\n    var audioTrun, videoTrun, trunHeader; // This method assumes all samples are uniform. That is, if a\n    // duration is present for the first sample, it will be present for\n    // all subsequent samples.\n    // see ISO/IEC 14496-12:2012, Section 8.8.8.1\n\n    trunHeader = function trunHeader(samples, offset) {\n      var durationPresent = 0,\n          sizePresent = 0,\n          flagsPresent = 0,\n          compositionTimeOffset = 0; // trun flag constants\n\n      if (samples.length) {\n        if (samples[0].duration !== undefined) {\n          durationPresent = 0x1;\n        }\n\n        if (samples[0].size !== undefined) {\n          sizePresent = 0x2;\n        }\n\n        if (samples[0].flags !== undefined) {\n          flagsPresent = 0x4;\n        }\n\n        if (samples[0].compositionTimeOffset !== undefined) {\n          compositionTimeOffset = 0x8;\n        }\n      }\n\n      return [0x00, // version 0\n      0x00, durationPresent | sizePresent | flagsPresent | compositionTimeOffset, 0x01, // flags\n      (samples.length & 0xFF000000) >>> 24, (samples.length & 0xFF0000) >>> 16, (samples.length & 0xFF00) >>> 8, samples.length & 0xFF, // sample_count\n      (offset & 0xFF000000) >>> 24, (offset & 0xFF0000) >>> 16, (offset & 0xFF00) >>> 8, offset & 0xFF // data_offset\n      ];\n    };\n\n    videoTrun = function videoTrun(track, offset) {\n      var bytesOffest, bytes, header, samples, sample, i;\n      samples = track.samples || [];\n      offset += 8 + 12 + 16 * samples.length;\n      header = trunHeader(samples, offset);\n      bytes = new Uint8Array(header.length + samples.length * 16);\n      bytes.set(header);\n      bytesOffest = header.length;\n\n      for (i = 0; i < samples.length; i++) {\n        sample = samples[i];\n        bytes[bytesOffest++] = (sample.duration & 0xFF000000) >>> 24;\n        bytes[bytesOffest++] = (sample.duration & 0xFF0000) >>> 16;\n        bytes[bytesOffest++] = (sample.duration & 0xFF00) >>> 8;\n        bytes[bytesOffest++] = sample.duration & 0xFF; // sample_duration\n\n        bytes[bytesOffest++] = (sample.size & 0xFF000000) >>> 24;\n        bytes[bytesOffest++] = (sample.size & 0xFF0000) >>> 16;\n        bytes[bytesOffest++] = (sample.size & 0xFF00) >>> 8;\n        bytes[bytesOffest++] = sample.size & 0xFF; // sample_size\n\n        bytes[bytesOffest++] = sample.flags.isLeading << 2 | sample.flags.dependsOn;\n        bytes[bytesOffest++] = sample.flags.isDependedOn << 6 | sample.flags.hasRedundancy << 4 | sample.flags.paddingValue << 1 | sample.flags.isNonSyncSample;\n        bytes[bytesOffest++] = sample.flags.degradationPriority & 0xF0 << 8;\n        bytes[bytesOffest++] = sample.flags.degradationPriority & 0x0F; // sample_flags\n\n        bytes[bytesOffest++] = (sample.compositionTimeOffset & 0xFF000000) >>> 24;\n        bytes[bytesOffest++] = (sample.compositionTimeOffset & 0xFF0000) >>> 16;\n        bytes[bytesOffest++] = (sample.compositionTimeOffset & 0xFF00) >>> 8;\n        bytes[bytesOffest++] = sample.compositionTimeOffset & 0xFF; // sample_composition_time_offset\n      }\n\n      return box(types.trun, bytes);\n    };\n\n    audioTrun = function audioTrun(track, offset) {\n      var bytes, bytesOffest, header, samples, sample, i;\n      samples = track.samples || [];\n      offset += 8 + 12 + 8 * samples.length;\n      header = trunHeader(samples, offset);\n      bytes = new Uint8Array(header.length + samples.length * 8);\n      bytes.set(header);\n      bytesOffest = header.length;\n\n      for (i = 0; i < samples.length; i++) {\n        sample = samples[i];\n        bytes[bytesOffest++] = (sample.duration & 0xFF000000) >>> 24;\n        bytes[bytesOffest++] = (sample.duration & 0xFF0000) >>> 16;\n        bytes[bytesOffest++] = (sample.duration & 0xFF00) >>> 8;\n        bytes[bytesOffest++] = sample.duration & 0xFF; // sample_duration\n\n        bytes[bytesOffest++] = (sample.size & 0xFF000000) >>> 24;\n        bytes[bytesOffest++] = (sample.size & 0xFF0000) >>> 16;\n        bytes[bytesOffest++] = (sample.size & 0xFF00) >>> 8;\n        bytes[bytesOffest++] = sample.size & 0xFF; // sample_size\n      }\n\n      return box(types.trun, bytes);\n    };\n\n    trun$1 = function trun(track, offset) {\n      if (track.type === 'audio') {\n        return audioTrun(track, offset);\n      }\n\n      return videoTrun(track, offset);\n    };\n  })();\n\n  var mp4Generator = {\n    ftyp: ftyp,\n    mdat: mdat,\n    moof: moof,\n    moov: moov,\n    initSegment: function initSegment(tracks) {\n      var fileType = ftyp(),\n          movie = moov(tracks),\n          result;\n      result = new Uint8Array(fileType.byteLength + movie.byteLength);\n      result.set(fileType);\n      result.set(movie, fileType.byteLength);\n      return result;\n    }\n  };\n\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n  var toUnsigned$3 = function toUnsigned(value) {\n    return value >>> 0;\n  };\n\n  var toHexString$1 = function toHexString(value) {\n    return ('00' + value.toString(16)).slice(-2);\n  };\n\n  var bin = {\n    toUnsigned: toUnsigned$3,\n    toHexString: toHexString$1\n  };\n\n  var parseType$2 = function parseType(buffer) {\n    var result = '';\n    result += String.fromCharCode(buffer[0]);\n    result += String.fromCharCode(buffer[1]);\n    result += String.fromCharCode(buffer[2]);\n    result += String.fromCharCode(buffer[3]);\n    return result;\n  };\n\n  var parseType_1 = parseType$2;\n\n  var toUnsigned$2 = bin.toUnsigned;\n\n  var findBox = function findBox(data, path) {\n    var results = [],\n        i,\n        size,\n        type,\n        end,\n        subresults;\n\n    if (!path.length) {\n      // short-circuit the search for empty paths\n      return null;\n    }\n\n    for (i = 0; i < data.byteLength;) {\n      size = toUnsigned$2(data[i] << 24 | data[i + 1] << 16 | data[i + 2] << 8 | data[i + 3]);\n      type = parseType_1(data.subarray(i + 4, i + 8));\n      end = size > 1 ? i + size : data.byteLength;\n\n      if (type === path[0]) {\n        if (path.length === 1) {\n          // this is the end of the path and we've found the box we were\n          // looking for\n          results.push(data.subarray(i + 8, end));\n        } else {\n          // recursively search for the next box along the path\n          subresults = findBox(data.subarray(i + 8, end), path.slice(1));\n\n          if (subresults.length) {\n            results = results.concat(subresults);\n          }\n        }\n      }\n\n      i = end;\n    } // we've finished searching all of data\n\n\n    return results;\n  };\n\n  var findBox_1 = findBox;\n\n  var tfhd = function tfhd(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4)),\n      trackId: view.getUint32(4)\n    },\n        baseDataOffsetPresent = result.flags[2] & 0x01,\n        sampleDescriptionIndexPresent = result.flags[2] & 0x02,\n        defaultSampleDurationPresent = result.flags[2] & 0x08,\n        defaultSampleSizePresent = result.flags[2] & 0x10,\n        defaultSampleFlagsPresent = result.flags[2] & 0x20,\n        durationIsEmpty = result.flags[0] & 0x010000,\n        defaultBaseIsMoof = result.flags[0] & 0x020000,\n        i;\n    i = 8;\n\n    if (baseDataOffsetPresent) {\n      i += 4; // truncate top 4 bytes\n      // FIXME: should we read the full 64 bits?\n\n      result.baseDataOffset = view.getUint32(12);\n      i += 4;\n    }\n\n    if (sampleDescriptionIndexPresent) {\n      result.sampleDescriptionIndex = view.getUint32(i);\n      i += 4;\n    }\n\n    if (defaultSampleDurationPresent) {\n      result.defaultSampleDuration = view.getUint32(i);\n      i += 4;\n    }\n\n    if (defaultSampleSizePresent) {\n      result.defaultSampleSize = view.getUint32(i);\n      i += 4;\n    }\n\n    if (defaultSampleFlagsPresent) {\n      result.defaultSampleFlags = view.getUint32(i);\n    }\n\n    if (durationIsEmpty) {\n      result.durationIsEmpty = true;\n    }\n\n    if (!baseDataOffsetPresent && defaultBaseIsMoof) {\n      result.baseDataOffsetIsMoof = true;\n    }\n\n    return result;\n  };\n\n  var parseTfhd = tfhd;\n\n  var parseSampleFlags = function parseSampleFlags(flags) {\n    return {\n      isLeading: (flags[0] & 0x0c) >>> 2,\n      dependsOn: flags[0] & 0x03,\n      isDependedOn: (flags[1] & 0xc0) >>> 6,\n      hasRedundancy: (flags[1] & 0x30) >>> 4,\n      paddingValue: (flags[1] & 0x0e) >>> 1,\n      isNonSyncSample: flags[1] & 0x01,\n      degradationPriority: flags[2] << 8 | flags[3]\n    };\n  };\n\n  var parseSampleFlags_1 = parseSampleFlags;\n\n  var trun = function trun(data) {\n    var result = {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4)),\n      samples: []\n    },\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        // Flag interpretation\n    dataOffsetPresent = result.flags[2] & 0x01,\n        // compare with 2nd byte of 0x1\n    firstSampleFlagsPresent = result.flags[2] & 0x04,\n        // compare with 2nd byte of 0x4\n    sampleDurationPresent = result.flags[1] & 0x01,\n        // compare with 2nd byte of 0x100\n    sampleSizePresent = result.flags[1] & 0x02,\n        // compare with 2nd byte of 0x200\n    sampleFlagsPresent = result.flags[1] & 0x04,\n        // compare with 2nd byte of 0x400\n    sampleCompositionTimeOffsetPresent = result.flags[1] & 0x08,\n        // compare with 2nd byte of 0x800\n    sampleCount = view.getUint32(4),\n        offset = 8,\n        sample;\n\n    if (dataOffsetPresent) {\n      // 32 bit signed integer\n      result.dataOffset = view.getInt32(offset);\n      offset += 4;\n    } // Overrides the flags for the first sample only. The order of\n    // optional values will be: duration, size, compositionTimeOffset\n\n\n    if (firstSampleFlagsPresent && sampleCount) {\n      sample = {\n        flags: parseSampleFlags_1(data.subarray(offset, offset + 4))\n      };\n      offset += 4;\n\n      if (sampleDurationPresent) {\n        sample.duration = view.getUint32(offset);\n        offset += 4;\n      }\n\n      if (sampleSizePresent) {\n        sample.size = view.getUint32(offset);\n        offset += 4;\n      }\n\n      if (sampleCompositionTimeOffsetPresent) {\n        if (result.version === 1) {\n          sample.compositionTimeOffset = view.getInt32(offset);\n        } else {\n          sample.compositionTimeOffset = view.getUint32(offset);\n        }\n\n        offset += 4;\n      }\n\n      result.samples.push(sample);\n      sampleCount--;\n    }\n\n    while (sampleCount--) {\n      sample = {};\n\n      if (sampleDurationPresent) {\n        sample.duration = view.getUint32(offset);\n        offset += 4;\n      }\n\n      if (sampleSizePresent) {\n        sample.size = view.getUint32(offset);\n        offset += 4;\n      }\n\n      if (sampleFlagsPresent) {\n        sample.flags = parseSampleFlags_1(data.subarray(offset, offset + 4));\n        offset += 4;\n      }\n\n      if (sampleCompositionTimeOffsetPresent) {\n        if (result.version === 1) {\n          sample.compositionTimeOffset = view.getInt32(offset);\n        } else {\n          sample.compositionTimeOffset = view.getUint32(offset);\n        }\n\n        offset += 4;\n      }\n\n      result.samples.push(sample);\n    }\n\n    return result;\n  };\n\n  var parseTrun = trun;\n\n  var toUnsigned$1 = bin.toUnsigned;\n  var getUint64$3 = numbers.getUint64;\n\n  var tfdt = function tfdt(data) {\n    var result = {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4))\n    };\n\n    if (result.version === 1) {\n      result.baseMediaDecodeTime = getUint64$3(data.subarray(4));\n    } else {\n      result.baseMediaDecodeTime = toUnsigned$1(data[4] << 24 | data[5] << 16 | data[6] << 8 | data[7]);\n    }\n\n    return result;\n  };\n\n  var parseTfdt = tfdt;\n\n  var toUnsigned = bin.toUnsigned;\n  var toHexString = bin.toHexString;\n  var getUint64$2 = numbers.getUint64;\n  var timescale, startTime, compositionStartTime, getVideoTrackIds, getTracks, getTimescaleFromMediaHeader;\n  /**\n   * Parses an MP4 initialization segment and extracts the timescale\n   * values for any declared tracks. Timescale values indicate the\n   * number of clock ticks per second to assume for time-based values\n   * elsewhere in the MP4.\n   *\n   * To determine the start time of an MP4, you need two pieces of\n   * information: the timescale unit and the earliest base media decode\n   * time. Multiple timescales can be specified within an MP4 but the\n   * base media decode time is always expressed in the timescale from\n   * the media header box for the track:\n   * ```\n   * moov > trak > mdia > mdhd.timescale\n   * ```\n   * @param init {Uint8Array} the bytes of the init segment\n   * @return {object} a hash of track ids to timescale values or null if\n   * the init segment is malformed.\n   */\n\n  timescale = function timescale(init) {\n    var result = {},\n        traks = findBox_1(init, ['moov', 'trak']); // mdhd timescale\n\n    return traks.reduce(function (result, trak) {\n      var tkhd, version, index, id, mdhd;\n      tkhd = findBox_1(trak, ['tkhd'])[0];\n\n      if (!tkhd) {\n        return null;\n      }\n\n      version = tkhd[0];\n      index = version === 0 ? 12 : 20;\n      id = toUnsigned(tkhd[index] << 24 | tkhd[index + 1] << 16 | tkhd[index + 2] << 8 | tkhd[index + 3]);\n      mdhd = findBox_1(trak, ['mdia', 'mdhd'])[0];\n\n      if (!mdhd) {\n        return null;\n      }\n\n      version = mdhd[0];\n      index = version === 0 ? 12 : 20;\n      result[id] = toUnsigned(mdhd[index] << 24 | mdhd[index + 1] << 16 | mdhd[index + 2] << 8 | mdhd[index + 3]);\n      return result;\n    }, result);\n  };\n  /**\n   * Determine the base media decode start time, in seconds, for an MP4\n   * fragment. If multiple fragments are specified, the earliest time is\n   * returned.\n   *\n   * The base media decode time can be parsed from track fragment\n   * metadata:\n   * ```\n   * moof > traf > tfdt.baseMediaDecodeTime\n   * ```\n   * It requires the timescale value from the mdhd to interpret.\n   *\n   * @param timescale {object} a hash of track ids to timescale values.\n   * @return {number} the earliest base media decode start time for the\n   * fragment, in seconds\n   */\n\n\n  startTime = function startTime(timescale, fragment) {\n    var trafs; // we need info from two childrend of each track fragment box\n\n    trafs = findBox_1(fragment, ['moof', 'traf']); // determine the start times for each track\n\n    var lowestTime = trafs.reduce(function (acc, traf) {\n      var tfhd = findBox_1(traf, ['tfhd'])[0]; // get the track id from the tfhd\n\n      var id = toUnsigned(tfhd[4] << 24 | tfhd[5] << 16 | tfhd[6] << 8 | tfhd[7]); // assume a 90kHz clock if no timescale was specified\n\n      var scale = timescale[id] || 90e3; // get the base media decode time from the tfdt\n\n      var tfdt = findBox_1(traf, ['tfdt'])[0];\n      var dv = new DataView(tfdt.buffer, tfdt.byteOffset, tfdt.byteLength);\n      var baseTime; // version 1 is 64 bit\n\n      if (tfdt[0] === 1) {\n        baseTime = getUint64$2(tfdt.subarray(4, 12));\n      } else {\n        baseTime = dv.getUint32(4);\n      } // convert base time to seconds if it is a valid number.\n\n\n      var seconds;\n\n      if (typeof baseTime === 'bigint') {\n        seconds = baseTime / window__default['default'].BigInt(scale);\n      } else if (typeof baseTime === 'number' && !isNaN(baseTime)) {\n        seconds = baseTime / scale;\n      }\n\n      if (seconds < Number.MAX_SAFE_INTEGER) {\n        seconds = Number(seconds);\n      }\n\n      if (seconds < acc) {\n        acc = seconds;\n      }\n\n      return acc;\n    }, Infinity);\n    return typeof lowestTime === 'bigint' || isFinite(lowestTime) ? lowestTime : 0;\n  };\n  /**\n   * Determine the composition start, in seconds, for an MP4\n   * fragment.\n   *\n   * The composition start time of a fragment can be calculated using the base\n   * media decode time, composition time offset, and timescale, as follows:\n   *\n   * compositionStartTime = (baseMediaDecodeTime + compositionTimeOffset) / timescale\n   *\n   * All of the aforementioned information is contained within a media fragment's\n   * `traf` box, except for timescale info, which comes from the initialization\n   * segment, so a track id (also contained within a `traf`) is also necessary to\n   * associate it with a timescale\n   *\n   *\n   * @param timescales {object} - a hash of track ids to timescale values.\n   * @param fragment {Unit8Array} - the bytes of a media segment\n   * @return {number} the composition start time for the fragment, in seconds\n   **/\n\n\n  compositionStartTime = function compositionStartTime(timescales, fragment) {\n    var trafBoxes = findBox_1(fragment, ['moof', 'traf']);\n    var baseMediaDecodeTime = 0;\n    var compositionTimeOffset = 0;\n    var trackId;\n\n    if (trafBoxes && trafBoxes.length) {\n      // The spec states that track run samples contained within a `traf` box are contiguous, but\n      // it does not explicitly state whether the `traf` boxes themselves are contiguous.\n      // We will assume that they are, so we only need the first to calculate start time.\n      var tfhd = findBox_1(trafBoxes[0], ['tfhd'])[0];\n      var trun = findBox_1(trafBoxes[0], ['trun'])[0];\n      var tfdt = findBox_1(trafBoxes[0], ['tfdt'])[0];\n\n      if (tfhd) {\n        var parsedTfhd = parseTfhd(tfhd);\n        trackId = parsedTfhd.trackId;\n      }\n\n      if (tfdt) {\n        var parsedTfdt = parseTfdt(tfdt);\n        baseMediaDecodeTime = parsedTfdt.baseMediaDecodeTime;\n      }\n\n      if (trun) {\n        var parsedTrun = parseTrun(trun);\n\n        if (parsedTrun.samples && parsedTrun.samples.length) {\n          compositionTimeOffset = parsedTrun.samples[0].compositionTimeOffset || 0;\n        }\n      }\n    } // Get timescale for this specific track. Assume a 90kHz clock if no timescale was\n    // specified.\n\n\n    var timescale = timescales[trackId] || 90e3; // return the composition start time, in seconds\n\n    if (typeof baseMediaDecodeTime === 'bigint') {\n      compositionTimeOffset = window__default['default'].BigInt(compositionTimeOffset);\n      timescale = window__default['default'].BigInt(timescale);\n    }\n\n    var result = (baseMediaDecodeTime + compositionTimeOffset) / timescale;\n\n    if (typeof result === 'bigint' && result < Number.MAX_SAFE_INTEGER) {\n      result = Number(result);\n    }\n\n    return result;\n  };\n  /**\n    * Find the trackIds of the video tracks in this source.\n    * Found by parsing the Handler Reference and Track Header Boxes:\n    *   moov > trak > mdia > hdlr\n    *   moov > trak > tkhd\n    *\n    * @param {Uint8Array} init - The bytes of the init segment for this source\n    * @return {Number[]} A list of trackIds\n    *\n    * @see ISO-BMFF-12/2015, Section 8.4.3\n   **/\n\n\n  getVideoTrackIds = function getVideoTrackIds(init) {\n    var traks = findBox_1(init, ['moov', 'trak']);\n    var videoTrackIds = [];\n    traks.forEach(function (trak) {\n      var hdlrs = findBox_1(trak, ['mdia', 'hdlr']);\n      var tkhds = findBox_1(trak, ['tkhd']);\n      hdlrs.forEach(function (hdlr, index) {\n        var handlerType = parseType_1(hdlr.subarray(8, 12));\n        var tkhd = tkhds[index];\n        var view;\n        var version;\n        var trackId;\n\n        if (handlerType === 'vide') {\n          view = new DataView(tkhd.buffer, tkhd.byteOffset, tkhd.byteLength);\n          version = view.getUint8(0);\n          trackId = version === 0 ? view.getUint32(12) : view.getUint32(20);\n          videoTrackIds.push(trackId);\n        }\n      });\n    });\n    return videoTrackIds;\n  };\n\n  getTimescaleFromMediaHeader = function getTimescaleFromMediaHeader(mdhd) {\n    // mdhd is a FullBox, meaning it will have its own version as the first byte\n    var version = mdhd[0];\n    var index = version === 0 ? 12 : 20;\n    return toUnsigned(mdhd[index] << 24 | mdhd[index + 1] << 16 | mdhd[index + 2] << 8 | mdhd[index + 3]);\n  };\n  /**\n   * Get all the video, audio, and hint tracks from a non fragmented\n   * mp4 segment\n   */\n\n\n  getTracks = function getTracks(init) {\n    var traks = findBox_1(init, ['moov', 'trak']);\n    var tracks = [];\n    traks.forEach(function (trak) {\n      var track = {};\n      var tkhd = findBox_1(trak, ['tkhd'])[0];\n      var view, tkhdVersion; // id\n\n      if (tkhd) {\n        view = new DataView(tkhd.buffer, tkhd.byteOffset, tkhd.byteLength);\n        tkhdVersion = view.getUint8(0);\n        track.id = tkhdVersion === 0 ? view.getUint32(12) : view.getUint32(20);\n      }\n\n      var hdlr = findBox_1(trak, ['mdia', 'hdlr'])[0]; // type\n\n      if (hdlr) {\n        var type = parseType_1(hdlr.subarray(8, 12));\n\n        if (type === 'vide') {\n          track.type = 'video';\n        } else if (type === 'soun') {\n          track.type = 'audio';\n        } else {\n          track.type = type;\n        }\n      } // codec\n\n\n      var stsd = findBox_1(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];\n\n      if (stsd) {\n        var sampleDescriptions = stsd.subarray(8); // gives the codec type string\n\n        track.codec = parseType_1(sampleDescriptions.subarray(4, 8));\n        var codecBox = findBox_1(sampleDescriptions, [track.codec])[0];\n        var codecConfig, codecConfigType;\n\n        if (codecBox) {\n          // https://tools.ietf.org/html/rfc6381#section-3.3\n          if (/^[asm]vc[1-9]$/i.test(track.codec)) {\n            // we don't need anything but the \"config\" parameter of the\n            // avc1 codecBox\n            codecConfig = codecBox.subarray(78);\n            codecConfigType = parseType_1(codecConfig.subarray(4, 8));\n\n            if (codecConfigType === 'avcC' && codecConfig.length > 11) {\n              track.codec += '.'; // left padded with zeroes for single digit hex\n              // profile idc\n\n              track.codec += toHexString(codecConfig[9]); // the byte containing the constraint_set flags\n\n              track.codec += toHexString(codecConfig[10]); // level idc\n\n              track.codec += toHexString(codecConfig[11]);\n            } else {\n              // TODO: show a warning that we couldn't parse the codec\n              // and are using the default\n              track.codec = 'avc1.4d400d';\n            }\n          } else if (/^mp4[a,v]$/i.test(track.codec)) {\n            // we do not need anything but the streamDescriptor of the mp4a codecBox\n            codecConfig = codecBox.subarray(28);\n            codecConfigType = parseType_1(codecConfig.subarray(4, 8));\n\n            if (codecConfigType === 'esds' && codecConfig.length > 20 && codecConfig[19] !== 0) {\n              track.codec += '.' + toHexString(codecConfig[19]); // this value is only a single digit\n\n              track.codec += '.' + toHexString(codecConfig[20] >>> 2 & 0x3f).replace(/^0/, '');\n            } else {\n              // TODO: show a warning that we couldn't parse the codec\n              // and are using the default\n              track.codec = 'mp4a.40.2';\n            }\n          } else {\n            // flac, opus, etc\n            track.codec = track.codec.toLowerCase();\n          }\n        }\n      }\n\n      var mdhd = findBox_1(trak, ['mdia', 'mdhd'])[0];\n\n      if (mdhd) {\n        track.timescale = getTimescaleFromMediaHeader(mdhd);\n      }\n\n      tracks.push(track);\n    });\n    return tracks;\n  };\n\n  var probe$2 = {\n    // export mp4 inspector's findBox and parseType for backwards compatibility\n    findBox: findBox_1,\n    parseType: parseType_1,\n    timescale: timescale,\n    startTime: startTime,\n    compositionStartTime: compositionStartTime,\n    videoTrackIds: getVideoTrackIds,\n    tracks: getTracks,\n    getTimescaleFromMediaHeader: getTimescaleFromMediaHeader\n  };\n\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n  // Convert an array of nal units into an array of frames with each frame being\n  // composed of the nal units that make up that frame\n  // Also keep track of cummulative data about the frame from the nal units such\n  // as the frame duration, starting pts, etc.\n  var groupNalsIntoFrames = function groupNalsIntoFrames(nalUnits) {\n    var i,\n        currentNal,\n        currentFrame = [],\n        frames = []; // TODO added for LHLS, make sure this is OK\n\n    frames.byteLength = 0;\n    frames.nalCount = 0;\n    frames.duration = 0;\n    currentFrame.byteLength = 0;\n\n    for (i = 0; i < nalUnits.length; i++) {\n      currentNal = nalUnits[i]; // Split on 'aud'-type nal units\n\n      if (currentNal.nalUnitType === 'access_unit_delimiter_rbsp') {\n        // Since the very first nal unit is expected to be an AUD\n        // only push to the frames array when currentFrame is not empty\n        if (currentFrame.length) {\n          currentFrame.duration = currentNal.dts - currentFrame.dts; // TODO added for LHLS, make sure this is OK\n\n          frames.byteLength += currentFrame.byteLength;\n          frames.nalCount += currentFrame.length;\n          frames.duration += currentFrame.duration;\n          frames.push(currentFrame);\n        }\n\n        currentFrame = [currentNal];\n        currentFrame.byteLength = currentNal.data.byteLength;\n        currentFrame.pts = currentNal.pts;\n        currentFrame.dts = currentNal.dts;\n      } else {\n        // Specifically flag key frames for ease of use later\n        if (currentNal.nalUnitType === 'slice_layer_without_partitioning_rbsp_idr') {\n          currentFrame.keyFrame = true;\n        }\n\n        currentFrame.duration = currentNal.dts - currentFrame.dts;\n        currentFrame.byteLength += currentNal.data.byteLength;\n        currentFrame.push(currentNal);\n      }\n    } // For the last frame, use the duration of the previous frame if we\n    // have nothing better to go on\n\n\n    if (frames.length && (!currentFrame.duration || currentFrame.duration <= 0)) {\n      currentFrame.duration = frames[frames.length - 1].duration;\n    } // Push the final frame\n    // TODO added for LHLS, make sure this is OK\n\n\n    frames.byteLength += currentFrame.byteLength;\n    frames.nalCount += currentFrame.length;\n    frames.duration += currentFrame.duration;\n    frames.push(currentFrame);\n    return frames;\n  }; // Convert an array of frames into an array of Gop with each Gop being composed\n  // of the frames that make up that Gop\n  // Also keep track of cummulative data about the Gop from the frames such as the\n  // Gop duration, starting pts, etc.\n\n\n  var groupFramesIntoGops = function groupFramesIntoGops(frames) {\n    var i,\n        currentFrame,\n        currentGop = [],\n        gops = []; // We must pre-set some of the values on the Gop since we\n    // keep running totals of these values\n\n    currentGop.byteLength = 0;\n    currentGop.nalCount = 0;\n    currentGop.duration = 0;\n    currentGop.pts = frames[0].pts;\n    currentGop.dts = frames[0].dts; // store some metadata about all the Gops\n\n    gops.byteLength = 0;\n    gops.nalCount = 0;\n    gops.duration = 0;\n    gops.pts = frames[0].pts;\n    gops.dts = frames[0].dts;\n\n    for (i = 0; i < frames.length; i++) {\n      currentFrame = frames[i];\n\n      if (currentFrame.keyFrame) {\n        // Since the very first frame is expected to be an keyframe\n        // only push to the gops array when currentGop is not empty\n        if (currentGop.length) {\n          gops.push(currentGop);\n          gops.byteLength += currentGop.byteLength;\n          gops.nalCount += currentGop.nalCount;\n          gops.duration += currentGop.duration;\n        }\n\n        currentGop = [currentFrame];\n        currentGop.nalCount = currentFrame.length;\n        currentGop.byteLength = currentFrame.byteLength;\n        currentGop.pts = currentFrame.pts;\n        currentGop.dts = currentFrame.dts;\n        currentGop.duration = currentFrame.duration;\n      } else {\n        currentGop.duration += currentFrame.duration;\n        currentGop.nalCount += currentFrame.length;\n        currentGop.byteLength += currentFrame.byteLength;\n        currentGop.push(currentFrame);\n      }\n    }\n\n    if (gops.length && currentGop.duration <= 0) {\n      currentGop.duration = gops[gops.length - 1].duration;\n    }\n\n    gops.byteLength += currentGop.byteLength;\n    gops.nalCount += currentGop.nalCount;\n    gops.duration += currentGop.duration; // push the final Gop\n\n    gops.push(currentGop);\n    return gops;\n  };\n  /*\n   * Search for the first keyframe in the GOPs and throw away all frames\n   * until that keyframe. Then extend the duration of the pulled keyframe\n   * and pull the PTS and DTS of the keyframe so that it covers the time\n   * range of the frames that were disposed.\n   *\n   * @param {Array} gops video GOPs\n   * @returns {Array} modified video GOPs\n   */\n\n\n  var extendFirstKeyFrame = function extendFirstKeyFrame(gops) {\n    var currentGop;\n\n    if (!gops[0][0].keyFrame && gops.length > 1) {\n      // Remove the first GOP\n      currentGop = gops.shift();\n      gops.byteLength -= currentGop.byteLength;\n      gops.nalCount -= currentGop.nalCount; // Extend the first frame of what is now the\n      // first gop to cover the time period of the\n      // frames we just removed\n\n      gops[0][0].dts = currentGop.dts;\n      gops[0][0].pts = currentGop.pts;\n      gops[0][0].duration += currentGop.duration;\n    }\n\n    return gops;\n  };\n  /**\n   * Default sample object\n   * see ISO/IEC 14496-12:2012, section 8.6.4.3\n   */\n\n\n  var createDefaultSample = function createDefaultSample() {\n    return {\n      size: 0,\n      flags: {\n        isLeading: 0,\n        dependsOn: 1,\n        isDependedOn: 0,\n        hasRedundancy: 0,\n        degradationPriority: 0,\n        isNonSyncSample: 1\n      }\n    };\n  };\n  /*\n   * Collates information from a video frame into an object for eventual\n   * entry into an MP4 sample table.\n   *\n   * @param {Object} frame the video frame\n   * @param {Number} dataOffset the byte offset to position the sample\n   * @return {Object} object containing sample table info for a frame\n   */\n\n\n  var sampleForFrame = function sampleForFrame(frame, dataOffset) {\n    var sample = createDefaultSample();\n    sample.dataOffset = dataOffset;\n    sample.compositionTimeOffset = frame.pts - frame.dts;\n    sample.duration = frame.duration;\n    sample.size = 4 * frame.length; // Space for nal unit size\n\n    sample.size += frame.byteLength;\n\n    if (frame.keyFrame) {\n      sample.flags.dependsOn = 2;\n      sample.flags.isNonSyncSample = 0;\n    }\n\n    return sample;\n  }; // generate the track's sample table from an array of gops\n\n\n  var generateSampleTable$1 = function generateSampleTable(gops, baseDataOffset) {\n    var h,\n        i,\n        sample,\n        currentGop,\n        currentFrame,\n        dataOffset = baseDataOffset || 0,\n        samples = [];\n\n    for (h = 0; h < gops.length; h++) {\n      currentGop = gops[h];\n\n      for (i = 0; i < currentGop.length; i++) {\n        currentFrame = currentGop[i];\n        sample = sampleForFrame(currentFrame, dataOffset);\n        dataOffset += sample.size;\n        samples.push(sample);\n      }\n    }\n\n    return samples;\n  }; // generate the track's raw mdat data from an array of gops\n\n\n  var concatenateNalData = function concatenateNalData(gops) {\n    var h,\n        i,\n        j,\n        currentGop,\n        currentFrame,\n        currentNal,\n        dataOffset = 0,\n        nalsByteLength = gops.byteLength,\n        numberOfNals = gops.nalCount,\n        totalByteLength = nalsByteLength + 4 * numberOfNals,\n        data = new Uint8Array(totalByteLength),\n        view = new DataView(data.buffer); // For each Gop..\n\n    for (h = 0; h < gops.length; h++) {\n      currentGop = gops[h]; // For each Frame..\n\n      for (i = 0; i < currentGop.length; i++) {\n        currentFrame = currentGop[i]; // For each NAL..\n\n        for (j = 0; j < currentFrame.length; j++) {\n          currentNal = currentFrame[j];\n          view.setUint32(dataOffset, currentNal.data.byteLength);\n          dataOffset += 4;\n          data.set(currentNal.data, dataOffset);\n          dataOffset += currentNal.data.byteLength;\n        }\n      }\n    }\n\n    return data;\n  }; // generate the track's sample table from a frame\n\n\n  var generateSampleTableForFrame = function generateSampleTableForFrame(frame, baseDataOffset) {\n    var sample,\n        dataOffset = baseDataOffset || 0,\n        samples = [];\n    sample = sampleForFrame(frame, dataOffset);\n    samples.push(sample);\n    return samples;\n  }; // generate the track's raw mdat data from a frame\n\n\n  var concatenateNalDataForFrame = function concatenateNalDataForFrame(frame) {\n    var i,\n        currentNal,\n        dataOffset = 0,\n        nalsByteLength = frame.byteLength,\n        numberOfNals = frame.length,\n        totalByteLength = nalsByteLength + 4 * numberOfNals,\n        data = new Uint8Array(totalByteLength),\n        view = new DataView(data.buffer); // For each NAL..\n\n    for (i = 0; i < frame.length; i++) {\n      currentNal = frame[i];\n      view.setUint32(dataOffset, currentNal.data.byteLength);\n      dataOffset += 4;\n      data.set(currentNal.data, dataOffset);\n      dataOffset += currentNal.data.byteLength;\n    }\n\n    return data;\n  };\n\n  var frameUtils = {\n    groupNalsIntoFrames: groupNalsIntoFrames,\n    groupFramesIntoGops: groupFramesIntoGops,\n    extendFirstKeyFrame: extendFirstKeyFrame,\n    generateSampleTable: generateSampleTable$1,\n    concatenateNalData: concatenateNalData,\n    generateSampleTableForFrame: generateSampleTableForFrame,\n    concatenateNalDataForFrame: concatenateNalDataForFrame\n  };\n\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n  var highPrefix = [33, 16, 5, 32, 164, 27];\n  var lowPrefix = [33, 65, 108, 84, 1, 2, 4, 8, 168, 2, 4, 8, 17, 191, 252];\n\n  var zeroFill = function zeroFill(count) {\n    var a = [];\n\n    while (count--) {\n      a.push(0);\n    }\n\n    return a;\n  };\n\n  var makeTable = function makeTable(metaTable) {\n    return Object.keys(metaTable).reduce(function (obj, key) {\n      obj[key] = new Uint8Array(metaTable[key].reduce(function (arr, part) {\n        return arr.concat(part);\n      }, []));\n      return obj;\n    }, {});\n  };\n\n  var silence;\n\n  var silence_1 = function silence_1() {\n    if (!silence) {\n      // Frames-of-silence to use for filling in missing AAC frames\n      var coneOfSilence = {\n        96000: [highPrefix, [227, 64], zeroFill(154), [56]],\n        88200: [highPrefix, [231], zeroFill(170), [56]],\n        64000: [highPrefix, [248, 192], zeroFill(240), [56]],\n        48000: [highPrefix, [255, 192], zeroFill(268), [55, 148, 128], zeroFill(54), [112]],\n        44100: [highPrefix, [255, 192], zeroFill(268), [55, 163, 128], zeroFill(84), [112]],\n        32000: [highPrefix, [255, 192], zeroFill(268), [55, 234], zeroFill(226), [112]],\n        24000: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 112], zeroFill(126), [224]],\n        16000: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 255], zeroFill(269), [223, 108], zeroFill(195), [1, 192]],\n        12000: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 253, 128], zeroFill(259), [56]],\n        11025: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 255, 192], zeroFill(268), [55, 175, 128], zeroFill(108), [112]],\n        8000: [lowPrefix, zeroFill(268), [3, 121, 16], zeroFill(47), [7]]\n      };\n      silence = makeTable(coneOfSilence);\n    }\n\n    return silence;\n  };\n\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n\n  /**\n   * Sum the `byteLength` properties of the data in each AAC frame\n   */\n\n  var sumFrameByteLengths = function sumFrameByteLengths(array) {\n    var i,\n        currentObj,\n        sum = 0; // sum the byteLength's all each nal unit in the frame\n\n    for (i = 0; i < array.length; i++) {\n      currentObj = array[i];\n      sum += currentObj.data.byteLength;\n    }\n\n    return sum;\n  }; // Possibly pad (prefix) the audio track with silence if appending this track\n  // would lead to the introduction of a gap in the audio buffer\n\n\n  var prefixWithSilence = function prefixWithSilence(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime) {\n    var baseMediaDecodeTimeTs,\n        frameDuration = 0,\n        audioGapDuration = 0,\n        audioFillFrameCount = 0,\n        audioFillDuration = 0,\n        silentFrame,\n        i,\n        firstFrame;\n\n    if (!frames.length) {\n      return;\n    }\n\n    baseMediaDecodeTimeTs = clock.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate); // determine frame clock duration based on sample rate, round up to avoid overfills\n\n    frameDuration = Math.ceil(clock.ONE_SECOND_IN_TS / (track.samplerate / 1024));\n\n    if (audioAppendStartTs && videoBaseMediaDecodeTime) {\n      // insert the shortest possible amount (audio gap or audio to video gap)\n      audioGapDuration = baseMediaDecodeTimeTs - Math.max(audioAppendStartTs, videoBaseMediaDecodeTime); // number of full frames in the audio gap\n\n      audioFillFrameCount = Math.floor(audioGapDuration / frameDuration);\n      audioFillDuration = audioFillFrameCount * frameDuration;\n    } // don't attempt to fill gaps smaller than a single frame or larger\n    // than a half second\n\n\n    if (audioFillFrameCount < 1 || audioFillDuration > clock.ONE_SECOND_IN_TS / 2) {\n      return;\n    }\n\n    silentFrame = silence_1()[track.samplerate];\n\n    if (!silentFrame) {\n      // we don't have a silent frame pregenerated for the sample rate, so use a frame\n      // from the content instead\n      silentFrame = frames[0].data;\n    }\n\n    for (i = 0; i < audioFillFrameCount; i++) {\n      firstFrame = frames[0];\n      frames.splice(0, 0, {\n        data: silentFrame,\n        dts: firstFrame.dts - frameDuration,\n        pts: firstFrame.pts - frameDuration\n      });\n    }\n\n    track.baseMediaDecodeTime -= Math.floor(clock.videoTsToAudioTs(audioFillDuration, track.samplerate));\n    return audioFillDuration;\n  }; // If the audio segment extends before the earliest allowed dts\n  // value, remove AAC frames until starts at or after the earliest\n  // allowed DTS so that we don't end up with a negative baseMedia-\n  // DecodeTime for the audio track\n\n\n  var trimAdtsFramesByEarliestDts = function trimAdtsFramesByEarliestDts(adtsFrames, track, earliestAllowedDts) {\n    if (track.minSegmentDts >= earliestAllowedDts) {\n      return adtsFrames;\n    } // We will need to recalculate the earliest segment Dts\n\n\n    track.minSegmentDts = Infinity;\n    return adtsFrames.filter(function (currentFrame) {\n      // If this is an allowed frame, keep it and record it's Dts\n      if (currentFrame.dts >= earliestAllowedDts) {\n        track.minSegmentDts = Math.min(track.minSegmentDts, currentFrame.dts);\n        track.minSegmentPts = track.minSegmentDts;\n        return true;\n      } // Otherwise, discard it\n\n\n      return false;\n    });\n  }; // generate the track's raw mdat data from an array of frames\n\n\n  var generateSampleTable = function generateSampleTable(frames) {\n    var i,\n        currentFrame,\n        samples = [];\n\n    for (i = 0; i < frames.length; i++) {\n      currentFrame = frames[i];\n      samples.push({\n        size: currentFrame.data.byteLength,\n        duration: 1024 // For AAC audio, all samples contain 1024 samples\n\n      });\n    }\n\n    return samples;\n  }; // generate the track's sample table from an array of frames\n\n\n  var concatenateFrameData = function concatenateFrameData(frames) {\n    var i,\n        currentFrame,\n        dataOffset = 0,\n        data = new Uint8Array(sumFrameByteLengths(frames));\n\n    for (i = 0; i < frames.length; i++) {\n      currentFrame = frames[i];\n      data.set(currentFrame.data, dataOffset);\n      dataOffset += currentFrame.data.byteLength;\n    }\n\n    return data;\n  };\n\n  var audioFrameUtils = {\n    prefixWithSilence: prefixWithSilence,\n    trimAdtsFramesByEarliestDts: trimAdtsFramesByEarliestDts,\n    generateSampleTable: generateSampleTable,\n    concatenateFrameData: concatenateFrameData\n  };\n\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n\n  var ONE_SECOND_IN_TS$3 = clock.ONE_SECOND_IN_TS;\n  /**\n   * Store information about the start and end of the track and the\n   * duration for each frame/sample we process in order to calculate\n   * the baseMediaDecodeTime\n   */\n\n  var collectDtsInfo = function collectDtsInfo(track, data) {\n    if (typeof data.pts === 'number') {\n      if (track.timelineStartInfo.pts === undefined) {\n        track.timelineStartInfo.pts = data.pts;\n      }\n\n      if (track.minSegmentPts === undefined) {\n        track.minSegmentPts = data.pts;\n      } else {\n        track.minSegmentPts = Math.min(track.minSegmentPts, data.pts);\n      }\n\n      if (track.maxSegmentPts === undefined) {\n        track.maxSegmentPts = data.pts;\n      } else {\n        track.maxSegmentPts = Math.max(track.maxSegmentPts, data.pts);\n      }\n    }\n\n    if (typeof data.dts === 'number') {\n      if (track.timelineStartInfo.dts === undefined) {\n        track.timelineStartInfo.dts = data.dts;\n      }\n\n      if (track.minSegmentDts === undefined) {\n        track.minSegmentDts = data.dts;\n      } else {\n        track.minSegmentDts = Math.min(track.minSegmentDts, data.dts);\n      }\n\n      if (track.maxSegmentDts === undefined) {\n        track.maxSegmentDts = data.dts;\n      } else {\n        track.maxSegmentDts = Math.max(track.maxSegmentDts, data.dts);\n      }\n    }\n  };\n  /**\n   * Clear values used to calculate the baseMediaDecodeTime between\n   * tracks\n   */\n\n\n  var clearDtsInfo = function clearDtsInfo(track) {\n    delete track.minSegmentDts;\n    delete track.maxSegmentDts;\n    delete track.minSegmentPts;\n    delete track.maxSegmentPts;\n  };\n  /**\n   * Calculate the track's baseMediaDecodeTime based on the earliest\n   * DTS the transmuxer has ever seen and the minimum DTS for the\n   * current track\n   * @param track {object} track metadata configuration\n   * @param keepOriginalTimestamps {boolean} If true, keep the timestamps\n   *        in the source; false to adjust the first segment to start at 0.\n   */\n\n\n  var calculateTrackBaseMediaDecodeTime = function calculateTrackBaseMediaDecodeTime(track, keepOriginalTimestamps) {\n    var baseMediaDecodeTime,\n        scale,\n        minSegmentDts = track.minSegmentDts; // Optionally adjust the time so the first segment starts at zero.\n\n    if (!keepOriginalTimestamps) {\n      minSegmentDts -= track.timelineStartInfo.dts;\n    } // track.timelineStartInfo.baseMediaDecodeTime is the location, in time, where\n    // we want the start of the first segment to be placed\n\n\n    baseMediaDecodeTime = track.timelineStartInfo.baseMediaDecodeTime; // Add to that the distance this segment is from the very first\n\n    baseMediaDecodeTime += minSegmentDts; // baseMediaDecodeTime must not become negative\n\n    baseMediaDecodeTime = Math.max(0, baseMediaDecodeTime);\n\n    if (track.type === 'audio') {\n      // Audio has a different clock equal to the sampling_rate so we need to\n      // scale the PTS values into the clock rate of the track\n      scale = track.samplerate / ONE_SECOND_IN_TS$3;\n      baseMediaDecodeTime *= scale;\n      baseMediaDecodeTime = Math.floor(baseMediaDecodeTime);\n    }\n\n    return baseMediaDecodeTime;\n  };\n\n  var trackDecodeInfo = {\n    clearDtsInfo: clearDtsInfo,\n    calculateTrackBaseMediaDecodeTime: calculateTrackBaseMediaDecodeTime,\n    collectDtsInfo: collectDtsInfo\n  };\n\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   *\n   * Reads in-band caption information from a video elementary\n   * stream. Captions must follow the CEA-708 standard for injection\n   * into an MPEG-2 transport streams.\n   * @see https://en.wikipedia.org/wiki/CEA-708\n   * @see https://www.gpo.gov/fdsys/pkg/CFR-2007-title47-vol1/pdf/CFR-2007-title47-vol1-sec15-119.pdf\n   */\n  // payload type field to indicate how they are to be\n  // interpreted. CEAS-708 caption content is always transmitted with\n  // payload type 0x04.\n\n  var USER_DATA_REGISTERED_ITU_T_T35 = 4,\n      RBSP_TRAILING_BITS = 128;\n  /**\n    * Parse a supplemental enhancement information (SEI) NAL unit.\n    * Stops parsing once a message of type ITU T T35 has been found.\n    *\n    * @param bytes {Uint8Array} the bytes of a SEI NAL unit\n    * @return {object} the parsed SEI payload\n    * @see Rec. ITU-T H.264, 7.3.2.3.1\n    */\n\n  var parseSei = function parseSei(bytes) {\n    var i = 0,\n        result = {\n      payloadType: -1,\n      payloadSize: 0\n    },\n        payloadType = 0,\n        payloadSize = 0; // go through the sei_rbsp parsing each each individual sei_message\n\n    while (i < bytes.byteLength) {\n      // stop once we have hit the end of the sei_rbsp\n      if (bytes[i] === RBSP_TRAILING_BITS) {\n        break;\n      } // Parse payload type\n\n\n      while (bytes[i] === 0xFF) {\n        payloadType += 255;\n        i++;\n      }\n\n      payloadType += bytes[i++]; // Parse payload size\n\n      while (bytes[i] === 0xFF) {\n        payloadSize += 255;\n        i++;\n      }\n\n      payloadSize += bytes[i++]; // this sei_message is a 608/708 caption so save it and break\n      // there can only ever be one caption message in a frame's sei\n\n      if (!result.payload && payloadType === USER_DATA_REGISTERED_ITU_T_T35) {\n        var userIdentifier = String.fromCharCode(bytes[i + 3], bytes[i + 4], bytes[i + 5], bytes[i + 6]);\n\n        if (userIdentifier === 'GA94') {\n          result.payloadType = payloadType;\n          result.payloadSize = payloadSize;\n          result.payload = bytes.subarray(i, i + payloadSize);\n          break;\n        } else {\n          result.payload = void 0;\n        }\n      } // skip the payload and parse the next message\n\n\n      i += payloadSize;\n      payloadType = 0;\n      payloadSize = 0;\n    }\n\n    return result;\n  }; // see ANSI/SCTE 128-1 (2013), section 8.1\n\n\n  var parseUserData = function parseUserData(sei) {\n    // itu_t_t35_contry_code must be 181 (United States) for\n    // captions\n    if (sei.payload[0] !== 181) {\n      return null;\n    } // itu_t_t35_provider_code should be 49 (ATSC) for captions\n\n\n    if ((sei.payload[1] << 8 | sei.payload[2]) !== 49) {\n      return null;\n    } // the user_identifier should be \"GA94\" to indicate ATSC1 data\n\n\n    if (String.fromCharCode(sei.payload[3], sei.payload[4], sei.payload[5], sei.payload[6]) !== 'GA94') {\n      return null;\n    } // finally, user_data_type_code should be 0x03 for caption data\n\n\n    if (sei.payload[7] !== 0x03) {\n      return null;\n    } // return the user_data_type_structure and strip the trailing\n    // marker bits\n\n\n    return sei.payload.subarray(8, sei.payload.length - 1);\n  }; // see CEA-708-D, section 4.4\n\n\n  var parseCaptionPackets = function parseCaptionPackets(pts, userData) {\n    var results = [],\n        i,\n        count,\n        offset,\n        data; // if this is just filler, return immediately\n\n    if (!(userData[0] & 0x40)) {\n      return results;\n    } // parse out the cc_data_1 and cc_data_2 fields\n\n\n    count = userData[0] & 0x1f;\n\n    for (i = 0; i < count; i++) {\n      offset = i * 3;\n      data = {\n        type: userData[offset + 2] & 0x03,\n        pts: pts\n      }; // capture cc data when cc_valid is 1\n\n      if (userData[offset + 2] & 0x04) {\n        data.ccData = userData[offset + 3] << 8 | userData[offset + 4];\n        results.push(data);\n      }\n    }\n\n    return results;\n  };\n\n  var discardEmulationPreventionBytes$1 = function discardEmulationPreventionBytes(data) {\n    var length = data.byteLength,\n        emulationPreventionBytesPositions = [],\n        i = 1,\n        newLength,\n        newData; // Find all `Emulation Prevention Bytes`\n\n    while (i < length - 2) {\n      if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n        emulationPreventionBytesPositions.push(i + 2);\n        i += 2;\n      } else {\n        i++;\n      }\n    } // If no Emulation Prevention Bytes were found just return the original\n    // array\n\n\n    if (emulationPreventionBytesPositions.length === 0) {\n      return data;\n    } // Create a new array to hold the NAL unit data\n\n\n    newLength = length - emulationPreventionBytesPositions.length;\n    newData = new Uint8Array(newLength);\n    var sourceIndex = 0;\n\n    for (i = 0; i < newLength; sourceIndex++, i++) {\n      if (sourceIndex === emulationPreventionBytesPositions[0]) {\n        // Skip this byte\n        sourceIndex++; // Remove this position index\n\n        emulationPreventionBytesPositions.shift();\n      }\n\n      newData[i] = data[sourceIndex];\n    }\n\n    return newData;\n  }; // exports\n\n\n  var captionPacketParser = {\n    parseSei: parseSei,\n    parseUserData: parseUserData,\n    parseCaptionPackets: parseCaptionPackets,\n    discardEmulationPreventionBytes: discardEmulationPreventionBytes$1,\n    USER_DATA_REGISTERED_ITU_T_T35: USER_DATA_REGISTERED_ITU_T_T35\n  };\n\n  // Link To Transport\n  // -----------------\n\n\n  var CaptionStream$1 = function CaptionStream(options) {\n    options = options || {};\n    CaptionStream.prototype.init.call(this); // parse708captions flag, default to true\n\n    this.parse708captions_ = typeof options.parse708captions === 'boolean' ? options.parse708captions : true;\n    this.captionPackets_ = [];\n    this.ccStreams_ = [new Cea608Stream(0, 0), // eslint-disable-line no-use-before-define\n    new Cea608Stream(0, 1), // eslint-disable-line no-use-before-define\n    new Cea608Stream(1, 0), // eslint-disable-line no-use-before-define\n    new Cea608Stream(1, 1) // eslint-disable-line no-use-before-define\n    ];\n\n    if (this.parse708captions_) {\n      this.cc708Stream_ = new Cea708Stream({\n        captionServices: options.captionServices\n      }); // eslint-disable-line no-use-before-define\n    }\n\n    this.reset(); // forward data and done events from CCs to this CaptionStream\n\n    this.ccStreams_.forEach(function (cc) {\n      cc.on('data', this.trigger.bind(this, 'data'));\n      cc.on('partialdone', this.trigger.bind(this, 'partialdone'));\n      cc.on('done', this.trigger.bind(this, 'done'));\n    }, this);\n\n    if (this.parse708captions_) {\n      this.cc708Stream_.on('data', this.trigger.bind(this, 'data'));\n      this.cc708Stream_.on('partialdone', this.trigger.bind(this, 'partialdone'));\n      this.cc708Stream_.on('done', this.trigger.bind(this, 'done'));\n    }\n  };\n\n  CaptionStream$1.prototype = new stream();\n\n  CaptionStream$1.prototype.push = function (event) {\n    var sei, userData, newCaptionPackets; // only examine SEI NALs\n\n    if (event.nalUnitType !== 'sei_rbsp') {\n      return;\n    } // parse the sei\n\n\n    sei = captionPacketParser.parseSei(event.escapedRBSP); // no payload data, skip\n\n    if (!sei.payload) {\n      return;\n    } // ignore everything but user_data_registered_itu_t_t35\n\n\n    if (sei.payloadType !== captionPacketParser.USER_DATA_REGISTERED_ITU_T_T35) {\n      return;\n    } // parse out the user data payload\n\n\n    userData = captionPacketParser.parseUserData(sei); // ignore unrecognized userData\n\n    if (!userData) {\n      return;\n    } // Sometimes, the same segment # will be downloaded twice. To stop the\n    // caption data from being processed twice, we track the latest dts we've\n    // received and ignore everything with a dts before that. However, since\n    // data for a specific dts can be split across packets on either side of\n    // a segment boundary, we need to make sure we *don't* ignore the packets\n    // from the *next* segment that have dts === this.latestDts_. By constantly\n    // tracking the number of packets received with dts === this.latestDts_, we\n    // know how many should be ignored once we start receiving duplicates.\n\n\n    if (event.dts < this.latestDts_) {\n      // We've started getting older data, so set the flag.\n      this.ignoreNextEqualDts_ = true;\n      return;\n    } else if (event.dts === this.latestDts_ && this.ignoreNextEqualDts_) {\n      this.numSameDts_--;\n\n      if (!this.numSameDts_) {\n        // We've received the last duplicate packet, time to start processing again\n        this.ignoreNextEqualDts_ = false;\n      }\n\n      return;\n    } // parse out CC data packets and save them for later\n\n\n    newCaptionPackets = captionPacketParser.parseCaptionPackets(event.pts, userData);\n    this.captionPackets_ = this.captionPackets_.concat(newCaptionPackets);\n\n    if (this.latestDts_ !== event.dts) {\n      this.numSameDts_ = 0;\n    }\n\n    this.numSameDts_++;\n    this.latestDts_ = event.dts;\n  };\n\n  CaptionStream$1.prototype.flushCCStreams = function (flushType) {\n    this.ccStreams_.forEach(function (cc) {\n      return flushType === 'flush' ? cc.flush() : cc.partialFlush();\n    }, this);\n  };\n\n  CaptionStream$1.prototype.flushStream = function (flushType) {\n    // make sure we actually parsed captions before proceeding\n    if (!this.captionPackets_.length) {\n      this.flushCCStreams(flushType);\n      return;\n    } // In Chrome, the Array#sort function is not stable so add a\n    // presortIndex that we can use to ensure we get a stable-sort\n\n\n    this.captionPackets_.forEach(function (elem, idx) {\n      elem.presortIndex = idx;\n    }); // sort caption byte-pairs based on their PTS values\n\n    this.captionPackets_.sort(function (a, b) {\n      if (a.pts === b.pts) {\n        return a.presortIndex - b.presortIndex;\n      }\n\n      return a.pts - b.pts;\n    });\n    this.captionPackets_.forEach(function (packet) {\n      if (packet.type < 2) {\n        // Dispatch packet to the right Cea608Stream\n        this.dispatchCea608Packet(packet);\n      } else {\n        // Dispatch packet to the Cea708Stream\n        this.dispatchCea708Packet(packet);\n      }\n    }, this);\n    this.captionPackets_.length = 0;\n    this.flushCCStreams(flushType);\n  };\n\n  CaptionStream$1.prototype.flush = function () {\n    return this.flushStream('flush');\n  }; // Only called if handling partial data\n\n\n  CaptionStream$1.prototype.partialFlush = function () {\n    return this.flushStream('partialFlush');\n  };\n\n  CaptionStream$1.prototype.reset = function () {\n    this.latestDts_ = null;\n    this.ignoreNextEqualDts_ = false;\n    this.numSameDts_ = 0;\n    this.activeCea608Channel_ = [null, null];\n    this.ccStreams_.forEach(function (ccStream) {\n      ccStream.reset();\n    });\n  }; // From the CEA-608 spec:\n\n  /*\n   * When XDS sub-packets are interleaved with other services, the end of each sub-packet shall be followed\n   * by a control pair to change to a different service. When any of the control codes from 0x10 to 0x1F is\n   * used to begin a control code pair, it indicates the return to captioning or Text data. The control code pair\n   * and subsequent data should then be processed according to the FCC rules. It may be necessary for the\n   * line 21 data encoder to automatically insert a control code pair (i.e. RCL, RU2, RU3, RU4, RDC, or RTD)\n   * to switch to captioning or Text.\n  */\n  // With that in mind, we ignore any data between an XDS control code and a\n  // subsequent closed-captioning control code.\n\n\n  CaptionStream$1.prototype.dispatchCea608Packet = function (packet) {\n    // NOTE: packet.type is the CEA608 field\n    if (this.setsTextOrXDSActive(packet)) {\n      this.activeCea608Channel_[packet.type] = null;\n    } else if (this.setsChannel1Active(packet)) {\n      this.activeCea608Channel_[packet.type] = 0;\n    } else if (this.setsChannel2Active(packet)) {\n      this.activeCea608Channel_[packet.type] = 1;\n    }\n\n    if (this.activeCea608Channel_[packet.type] === null) {\n      // If we haven't received anything to set the active channel, or the\n      // packets are Text/XDS data, discard the data; we don't want jumbled\n      // captions\n      return;\n    }\n\n    this.ccStreams_[(packet.type << 1) + this.activeCea608Channel_[packet.type]].push(packet);\n  };\n\n  CaptionStream$1.prototype.setsChannel1Active = function (packet) {\n    return (packet.ccData & 0x7800) === 0x1000;\n  };\n\n  CaptionStream$1.prototype.setsChannel2Active = function (packet) {\n    return (packet.ccData & 0x7800) === 0x1800;\n  };\n\n  CaptionStream$1.prototype.setsTextOrXDSActive = function (packet) {\n    return (packet.ccData & 0x7100) === 0x0100 || (packet.ccData & 0x78fe) === 0x102a || (packet.ccData & 0x78fe) === 0x182a;\n  };\n\n  CaptionStream$1.prototype.dispatchCea708Packet = function (packet) {\n    if (this.parse708captions_) {\n      this.cc708Stream_.push(packet);\n    }\n  }; // ----------------------\n  // Session to Application\n  // ----------------------\n  // This hash maps special and extended character codes to their\n  // proper Unicode equivalent. The first one-byte key is just a\n  // non-standard character code. The two-byte keys that follow are\n  // the extended CEA708 character codes, along with the preceding\n  // 0x10 extended character byte to distinguish these codes from\n  // non-extended character codes. Every CEA708 character code that\n  // is not in this object maps directly to a standard unicode\n  // character code.\n  // The transparent space and non-breaking transparent space are\n  // technically not fully supported since there is no code to\n  // make them transparent, so they have normal non-transparent\n  // stand-ins.\n  // The special closed caption (CC) character isn't a standard\n  // unicode character, so a fairly similar unicode character was\n  // chosen in it's place.\n\n\n  var CHARACTER_TRANSLATION_708 = {\n    0x7f: 0x266a,\n    // \n    0x1020: 0x20,\n    // Transparent Space\n    0x1021: 0xa0,\n    // Nob-breaking Transparent Space\n    0x1025: 0x2026,\n    // \n    0x102a: 0x0160,\n    // \n    0x102c: 0x0152,\n    // \n    0x1030: 0x2588,\n    // \n    0x1031: 0x2018,\n    // \n    0x1032: 0x2019,\n    // \n    0x1033: 0x201c,\n    // \n    0x1034: 0x201d,\n    // \n    0x1035: 0x2022,\n    // \n    0x1039: 0x2122,\n    // \n    0x103a: 0x0161,\n    // \n    0x103c: 0x0153,\n    // \n    0x103d: 0x2120,\n    // \n    0x103f: 0x0178,\n    // \n    0x1076: 0x215b,\n    // \n    0x1077: 0x215c,\n    // \n    0x1078: 0x215d,\n    // \n    0x1079: 0x215e,\n    // \n    0x107a: 0x23d0,\n    // \n    0x107b: 0x23a4,\n    // \n    0x107c: 0x23a3,\n    // \n    0x107d: 0x23af,\n    // \n    0x107e: 0x23a6,\n    // \n    0x107f: 0x23a1,\n    // \n    0x10a0: 0x3138 //  (CC char)\n\n  };\n\n  var get708CharFromCode = function get708CharFromCode(code) {\n    var newCode = CHARACTER_TRANSLATION_708[code] || code;\n\n    if (code & 0x1000 && code === newCode) {\n      // Invalid extended code\n      return '';\n    }\n\n    return String.fromCharCode(newCode);\n  };\n\n  var within708TextBlock = function within708TextBlock(b) {\n    return 0x20 <= b && b <= 0x7f || 0xa0 <= b && b <= 0xff;\n  };\n\n  var Cea708Window = function Cea708Window(windowNum) {\n    this.windowNum = windowNum;\n    this.reset();\n  };\n\n  Cea708Window.prototype.reset = function () {\n    this.clearText();\n    this.pendingNewLine = false;\n    this.winAttr = {};\n    this.penAttr = {};\n    this.penLoc = {};\n    this.penColor = {}; // These default values are arbitrary,\n    // defineWindow will usually override them\n\n    this.visible = 0;\n    this.rowLock = 0;\n    this.columnLock = 0;\n    this.priority = 0;\n    this.relativePositioning = 0;\n    this.anchorVertical = 0;\n    this.anchorHorizontal = 0;\n    this.anchorPoint = 0;\n    this.rowCount = 1;\n    this.virtualRowCount = this.rowCount + 1;\n    this.columnCount = 41;\n    this.windowStyle = 0;\n    this.penStyle = 0;\n  };\n\n  Cea708Window.prototype.getText = function () {\n    return this.rows.join('\\n');\n  };\n\n  Cea708Window.prototype.clearText = function () {\n    this.rows = [''];\n    this.rowIdx = 0;\n  };\n\n  Cea708Window.prototype.newLine = function (pts) {\n    if (this.rows.length >= this.virtualRowCount && typeof this.beforeRowOverflow === 'function') {\n      this.beforeRowOverflow(pts);\n    }\n\n    if (this.rows.length > 0) {\n      this.rows.push('');\n      this.rowIdx++;\n    } // Show all virtual rows since there's no visible scrolling\n\n\n    while (this.rows.length > this.virtualRowCount) {\n      this.rows.shift();\n      this.rowIdx--;\n    }\n  };\n\n  Cea708Window.prototype.isEmpty = function () {\n    if (this.rows.length === 0) {\n      return true;\n    } else if (this.rows.length === 1) {\n      return this.rows[0] === '';\n    }\n\n    return false;\n  };\n\n  Cea708Window.prototype.addText = function (text) {\n    this.rows[this.rowIdx] += text;\n  };\n\n  Cea708Window.prototype.backspace = function () {\n    if (!this.isEmpty()) {\n      var row = this.rows[this.rowIdx];\n      this.rows[this.rowIdx] = row.substr(0, row.length - 1);\n    }\n  };\n\n  var Cea708Service = function Cea708Service(serviceNum, encoding, stream) {\n    this.serviceNum = serviceNum;\n    this.text = '';\n    this.currentWindow = new Cea708Window(-1);\n    this.windows = [];\n    this.stream = stream; // Try to setup a TextDecoder if an `encoding` value was provided\n\n    if (typeof encoding === 'string') {\n      this.createTextDecoder(encoding);\n    }\n  };\n  /**\n   * Initialize service windows\n   * Must be run before service use\n   *\n   * @param  {Integer}  pts               PTS value\n   * @param  {Function} beforeRowOverflow Function to execute before row overflow of a window\n   */\n\n\n  Cea708Service.prototype.init = function (pts, beforeRowOverflow) {\n    this.startPts = pts;\n\n    for (var win = 0; win < 8; win++) {\n      this.windows[win] = new Cea708Window(win);\n\n      if (typeof beforeRowOverflow === 'function') {\n        this.windows[win].beforeRowOverflow = beforeRowOverflow;\n      }\n    }\n  };\n  /**\n   * Set current window of service to be affected by commands\n   *\n   * @param  {Integer} windowNum Window number\n   */\n\n\n  Cea708Service.prototype.setCurrentWindow = function (windowNum) {\n    this.currentWindow = this.windows[windowNum];\n  };\n  /**\n   * Try to create a TextDecoder if it is natively supported\n   */\n\n\n  Cea708Service.prototype.createTextDecoder = function (encoding) {\n    if (typeof TextDecoder === 'undefined') {\n      this.stream.trigger('log', {\n        level: 'warn',\n        message: 'The `encoding` option is unsupported without TextDecoder support'\n      });\n    } else {\n      try {\n        this.textDecoder_ = new TextDecoder(encoding);\n      } catch (error) {\n        this.stream.trigger('log', {\n          level: 'warn',\n          message: 'TextDecoder could not be created with ' + encoding + ' encoding. ' + error\n        });\n      }\n    }\n  };\n\n  var Cea708Stream = function Cea708Stream(options) {\n    options = options || {};\n    Cea708Stream.prototype.init.call(this);\n    var self = this;\n    var captionServices = options.captionServices || {};\n    var captionServiceEncodings = {};\n    var serviceProps; // Get service encodings from captionServices option block\n\n    Object.keys(captionServices).forEach(function (serviceName) {\n      serviceProps = captionServices[serviceName];\n\n      if (/^SERVICE/.test(serviceName)) {\n        captionServiceEncodings[serviceName] = serviceProps.encoding;\n      }\n    });\n    this.serviceEncodings = captionServiceEncodings;\n    this.current708Packet = null;\n    this.services = {};\n\n    this.push = function (packet) {\n      if (packet.type === 3) {\n        // 708 packet start\n        self.new708Packet();\n        self.add708Bytes(packet);\n      } else {\n        if (self.current708Packet === null) {\n          // This should only happen at the start of a file if there's no packet start.\n          self.new708Packet();\n        }\n\n        self.add708Bytes(packet);\n      }\n    };\n  };\n\n  Cea708Stream.prototype = new stream();\n  /**\n   * Push current 708 packet, create new 708 packet.\n   */\n\n  Cea708Stream.prototype.new708Packet = function () {\n    if (this.current708Packet !== null) {\n      this.push708Packet();\n    }\n\n    this.current708Packet = {\n      data: [],\n      ptsVals: []\n    };\n  };\n  /**\n   * Add pts and both bytes from packet into current 708 packet.\n   */\n\n\n  Cea708Stream.prototype.add708Bytes = function (packet) {\n    var data = packet.ccData;\n    var byte0 = data >>> 8;\n    var byte1 = data & 0xff; // I would just keep a list of packets instead of bytes, but it isn't clear in the spec\n    // that service blocks will always line up with byte pairs.\n\n    this.current708Packet.ptsVals.push(packet.pts);\n    this.current708Packet.data.push(byte0);\n    this.current708Packet.data.push(byte1);\n  };\n  /**\n   * Parse completed 708 packet into service blocks and push each service block.\n   */\n\n\n  Cea708Stream.prototype.push708Packet = function () {\n    var packet708 = this.current708Packet;\n    var packetData = packet708.data;\n    var serviceNum = null;\n    var blockSize = null;\n    var i = 0;\n    var b = packetData[i++];\n    packet708.seq = b >> 6;\n    packet708.sizeCode = b & 0x3f; // 0b00111111;\n\n    for (; i < packetData.length; i++) {\n      b = packetData[i++];\n      serviceNum = b >> 5;\n      blockSize = b & 0x1f; // 0b00011111\n\n      if (serviceNum === 7 && blockSize > 0) {\n        // Extended service num\n        b = packetData[i++];\n        serviceNum = b;\n      }\n\n      this.pushServiceBlock(serviceNum, i, blockSize);\n\n      if (blockSize > 0) {\n        i += blockSize - 1;\n      }\n    }\n  };\n  /**\n   * Parse service block, execute commands, read text.\n   *\n   * Note: While many of these commands serve important purposes,\n   * many others just parse out the parameters or attributes, but\n   * nothing is done with them because this is not a full and complete\n   * implementation of the entire 708 spec.\n   *\n   * @param  {Integer} serviceNum Service number\n   * @param  {Integer} start      Start index of the 708 packet data\n   * @param  {Integer} size       Block size\n   */\n\n\n  Cea708Stream.prototype.pushServiceBlock = function (serviceNum, start, size) {\n    var b;\n    var i = start;\n    var packetData = this.current708Packet.data;\n    var service = this.services[serviceNum];\n\n    if (!service) {\n      service = this.initService(serviceNum, i);\n    }\n\n    for (; i < start + size && i < packetData.length; i++) {\n      b = packetData[i];\n\n      if (within708TextBlock(b)) {\n        i = this.handleText(i, service);\n      } else if (b === 0x18) {\n        i = this.multiByteCharacter(i, service);\n      } else if (b === 0x10) {\n        i = this.extendedCommands(i, service);\n      } else if (0x80 <= b && b <= 0x87) {\n        i = this.setCurrentWindow(i, service);\n      } else if (0x98 <= b && b <= 0x9f) {\n        i = this.defineWindow(i, service);\n      } else if (b === 0x88) {\n        i = this.clearWindows(i, service);\n      } else if (b === 0x8c) {\n        i = this.deleteWindows(i, service);\n      } else if (b === 0x89) {\n        i = this.displayWindows(i, service);\n      } else if (b === 0x8a) {\n        i = this.hideWindows(i, service);\n      } else if (b === 0x8b) {\n        i = this.toggleWindows(i, service);\n      } else if (b === 0x97) {\n        i = this.setWindowAttributes(i, service);\n      } else if (b === 0x90) {\n        i = this.setPenAttributes(i, service);\n      } else if (b === 0x91) {\n        i = this.setPenColor(i, service);\n      } else if (b === 0x92) {\n        i = this.setPenLocation(i, service);\n      } else if (b === 0x8f) {\n        service = this.reset(i, service);\n      } else if (b === 0x08) {\n        // BS: Backspace\n        service.currentWindow.backspace();\n      } else if (b === 0x0c) {\n        // FF: Form feed\n        service.currentWindow.clearText();\n      } else if (b === 0x0d) {\n        // CR: Carriage return\n        service.currentWindow.pendingNewLine = true;\n      } else if (b === 0x0e) {\n        // HCR: Horizontal carriage return\n        service.currentWindow.clearText();\n      } else if (b === 0x8d) {\n        // DLY: Delay, nothing to do\n        i++;\n      } else ;\n    }\n  };\n  /**\n   * Execute an extended command\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.extendedCommands = function (i, service) {\n    var packetData = this.current708Packet.data;\n    var b = packetData[++i];\n\n    if (within708TextBlock(b)) {\n      i = this.handleText(i, service, {\n        isExtended: true\n      });\n    }\n\n    return i;\n  };\n  /**\n   * Get PTS value of a given byte index\n   *\n   * @param  {Integer} byteIndex  Index of the byte\n   * @return {Integer}            PTS\n   */\n\n\n  Cea708Stream.prototype.getPts = function (byteIndex) {\n    // There's 1 pts value per 2 bytes\n    return this.current708Packet.ptsVals[Math.floor(byteIndex / 2)];\n  };\n  /**\n   * Initializes a service\n   *\n   * @param  {Integer} serviceNum Service number\n   * @return {Service}            Initialized service object\n   */\n\n\n  Cea708Stream.prototype.initService = function (serviceNum, i) {\n    var serviceName = 'SERVICE' + serviceNum;\n    var self = this;\n    var serviceName;\n    var encoding;\n\n    if (serviceName in this.serviceEncodings) {\n      encoding = this.serviceEncodings[serviceName];\n    }\n\n    this.services[serviceNum] = new Cea708Service(serviceNum, encoding, self);\n    this.services[serviceNum].init(this.getPts(i), function (pts) {\n      self.flushDisplayed(pts, self.services[serviceNum]);\n    });\n    return this.services[serviceNum];\n  };\n  /**\n   * Execute text writing to current window\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.handleText = function (i, service, options) {\n    var isExtended = options && options.isExtended;\n    var isMultiByte = options && options.isMultiByte;\n    var packetData = this.current708Packet.data;\n    var extended = isExtended ? 0x1000 : 0x0000;\n    var currentByte = packetData[i];\n    var nextByte = packetData[i + 1];\n    var win = service.currentWindow;\n    var char;\n    var charCodeArray; // Use the TextDecoder if one was created for this service\n\n    if (service.textDecoder_ && !isExtended) {\n      if (isMultiByte) {\n        charCodeArray = [currentByte, nextByte];\n        i++;\n      } else {\n        charCodeArray = [currentByte];\n      }\n\n      char = service.textDecoder_.decode(new Uint8Array(charCodeArray));\n    } else {\n      char = get708CharFromCode(extended | currentByte);\n    }\n\n    if (win.pendingNewLine && !win.isEmpty()) {\n      win.newLine(this.getPts(i));\n    }\n\n    win.pendingNewLine = false;\n    win.addText(char);\n    return i;\n  };\n  /**\n   * Handle decoding of multibyte character\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.multiByteCharacter = function (i, service) {\n    var packetData = this.current708Packet.data;\n    var firstByte = packetData[i + 1];\n    var secondByte = packetData[i + 2];\n\n    if (within708TextBlock(firstByte) && within708TextBlock(secondByte)) {\n      i = this.handleText(++i, service, {\n        isMultiByte: true\n      });\n    }\n\n    return i;\n  };\n  /**\n   * Parse and execute the CW# command.\n   *\n   * Set the current window.\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.setCurrentWindow = function (i, service) {\n    var packetData = this.current708Packet.data;\n    var b = packetData[i];\n    var windowNum = b & 0x07;\n    service.setCurrentWindow(windowNum);\n    return i;\n  };\n  /**\n   * Parse and execute the DF# command.\n   *\n   * Define a window and set it as the current window.\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.defineWindow = function (i, service) {\n    var packetData = this.current708Packet.data;\n    var b = packetData[i];\n    var windowNum = b & 0x07;\n    service.setCurrentWindow(windowNum);\n    var win = service.currentWindow;\n    b = packetData[++i];\n    win.visible = (b & 0x20) >> 5; // v\n\n    win.rowLock = (b & 0x10) >> 4; // rl\n\n    win.columnLock = (b & 0x08) >> 3; // cl\n\n    win.priority = b & 0x07; // p\n\n    b = packetData[++i];\n    win.relativePositioning = (b & 0x80) >> 7; // rp\n\n    win.anchorVertical = b & 0x7f; // av\n\n    b = packetData[++i];\n    win.anchorHorizontal = b; // ah\n\n    b = packetData[++i];\n    win.anchorPoint = (b & 0xf0) >> 4; // ap\n\n    win.rowCount = b & 0x0f; // rc\n\n    b = packetData[++i];\n    win.columnCount = b & 0x3f; // cc\n\n    b = packetData[++i];\n    win.windowStyle = (b & 0x38) >> 3; // ws\n\n    win.penStyle = b & 0x07; // ps\n    // The spec says there are (rowCount+1) \"virtual rows\"\n\n    win.virtualRowCount = win.rowCount + 1;\n    return i;\n  };\n  /**\n   * Parse and execute the SWA command.\n   *\n   * Set attributes of the current window.\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.setWindowAttributes = function (i, service) {\n    var packetData = this.current708Packet.data;\n    var b = packetData[i];\n    var winAttr = service.currentWindow.winAttr;\n    b = packetData[++i];\n    winAttr.fillOpacity = (b & 0xc0) >> 6; // fo\n\n    winAttr.fillRed = (b & 0x30) >> 4; // fr\n\n    winAttr.fillGreen = (b & 0x0c) >> 2; // fg\n\n    winAttr.fillBlue = b & 0x03; // fb\n\n    b = packetData[++i];\n    winAttr.borderType = (b & 0xc0) >> 6; // bt\n\n    winAttr.borderRed = (b & 0x30) >> 4; // br\n\n    winAttr.borderGreen = (b & 0x0c) >> 2; // bg\n\n    winAttr.borderBlue = b & 0x03; // bb\n\n    b = packetData[++i];\n    winAttr.borderType += (b & 0x80) >> 5; // bt\n\n    winAttr.wordWrap = (b & 0x40) >> 6; // ww\n\n    winAttr.printDirection = (b & 0x30) >> 4; // pd\n\n    winAttr.scrollDirection = (b & 0x0c) >> 2; // sd\n\n    winAttr.justify = b & 0x03; // j\n\n    b = packetData[++i];\n    winAttr.effectSpeed = (b & 0xf0) >> 4; // es\n\n    winAttr.effectDirection = (b & 0x0c) >> 2; // ed\n\n    winAttr.displayEffect = b & 0x03; // de\n\n    return i;\n  };\n  /**\n   * Gather text from all displayed windows and push a caption to output.\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   */\n\n\n  Cea708Stream.prototype.flushDisplayed = function (pts, service) {\n    var displayedText = []; // TODO: Positioning not supported, displaying multiple windows will not necessarily\n    // display text in the correct order, but sample files so far have not shown any issue.\n\n    for (var winId = 0; winId < 8; winId++) {\n      if (service.windows[winId].visible && !service.windows[winId].isEmpty()) {\n        displayedText.push(service.windows[winId].getText());\n      }\n    }\n\n    service.endPts = pts;\n    service.text = displayedText.join('\\n\\n');\n    this.pushCaption(service);\n    service.startPts = pts;\n  };\n  /**\n   * Push a caption to output if the caption contains text.\n   *\n   * @param  {Service} service  The service object to be affected\n   */\n\n\n  Cea708Stream.prototype.pushCaption = function (service) {\n    if (service.text !== '') {\n      this.trigger('data', {\n        startPts: service.startPts,\n        endPts: service.endPts,\n        text: service.text,\n        stream: 'cc708_' + service.serviceNum\n      });\n      service.text = '';\n      service.startPts = service.endPts;\n    }\n  };\n  /**\n   * Parse and execute the DSW command.\n   *\n   * Set visible property of windows based on the parsed bitmask.\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.displayWindows = function (i, service) {\n    var packetData = this.current708Packet.data;\n    var b = packetData[++i];\n    var pts = this.getPts(i);\n    this.flushDisplayed(pts, service);\n\n    for (var winId = 0; winId < 8; winId++) {\n      if (b & 0x01 << winId) {\n        service.windows[winId].visible = 1;\n      }\n    }\n\n    return i;\n  };\n  /**\n   * Parse and execute the HDW command.\n   *\n   * Set visible property of windows based on the parsed bitmask.\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.hideWindows = function (i, service) {\n    var packetData = this.current708Packet.data;\n    var b = packetData[++i];\n    var pts = this.getPts(i);\n    this.flushDisplayed(pts, service);\n\n    for (var winId = 0; winId < 8; winId++) {\n      if (b & 0x01 << winId) {\n        service.windows[winId].visible = 0;\n      }\n    }\n\n    return i;\n  };\n  /**\n   * Parse and execute the TGW command.\n   *\n   * Set visible property of windows based on the parsed bitmask.\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.toggleWindows = function (i, service) {\n    var packetData = this.current708Packet.data;\n    var b = packetData[++i];\n    var pts = this.getPts(i);\n    this.flushDisplayed(pts, service);\n\n    for (var winId = 0; winId < 8; winId++) {\n      if (b & 0x01 << winId) {\n        service.windows[winId].visible ^= 1;\n      }\n    }\n\n    return i;\n  };\n  /**\n   * Parse and execute the CLW command.\n   *\n   * Clear text of windows based on the parsed bitmask.\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.clearWindows = function (i, service) {\n    var packetData = this.current708Packet.data;\n    var b = packetData[++i];\n    var pts = this.getPts(i);\n    this.flushDisplayed(pts, service);\n\n    for (var winId = 0; winId < 8; winId++) {\n      if (b & 0x01 << winId) {\n        service.windows[winId].clearText();\n      }\n    }\n\n    return i;\n  };\n  /**\n   * Parse and execute the DLW command.\n   *\n   * Re-initialize windows based on the parsed bitmask.\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.deleteWindows = function (i, service) {\n    var packetData = this.current708Packet.data;\n    var b = packetData[++i];\n    var pts = this.getPts(i);\n    this.flushDisplayed(pts, service);\n\n    for (var winId = 0; winId < 8; winId++) {\n      if (b & 0x01 << winId) {\n        service.windows[winId].reset();\n      }\n    }\n\n    return i;\n  };\n  /**\n   * Parse and execute the SPA command.\n   *\n   * Set pen attributes of the current window.\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.setPenAttributes = function (i, service) {\n    var packetData = this.current708Packet.data;\n    var b = packetData[i];\n    var penAttr = service.currentWindow.penAttr;\n    b = packetData[++i];\n    penAttr.textTag = (b & 0xf0) >> 4; // tt\n\n    penAttr.offset = (b & 0x0c) >> 2; // o\n\n    penAttr.penSize = b & 0x03; // s\n\n    b = packetData[++i];\n    penAttr.italics = (b & 0x80) >> 7; // i\n\n    penAttr.underline = (b & 0x40) >> 6; // u\n\n    penAttr.edgeType = (b & 0x38) >> 3; // et\n\n    penAttr.fontStyle = b & 0x07; // fs\n\n    return i;\n  };\n  /**\n   * Parse and execute the SPC command.\n   *\n   * Set pen color of the current window.\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.setPenColor = function (i, service) {\n    var packetData = this.current708Packet.data;\n    var b = packetData[i];\n    var penColor = service.currentWindow.penColor;\n    b = packetData[++i];\n    penColor.fgOpacity = (b & 0xc0) >> 6; // fo\n\n    penColor.fgRed = (b & 0x30) >> 4; // fr\n\n    penColor.fgGreen = (b & 0x0c) >> 2; // fg\n\n    penColor.fgBlue = b & 0x03; // fb\n\n    b = packetData[++i];\n    penColor.bgOpacity = (b & 0xc0) >> 6; // bo\n\n    penColor.bgRed = (b & 0x30) >> 4; // br\n\n    penColor.bgGreen = (b & 0x0c) >> 2; // bg\n\n    penColor.bgBlue = b & 0x03; // bb\n\n    b = packetData[++i];\n    penColor.edgeRed = (b & 0x30) >> 4; // er\n\n    penColor.edgeGreen = (b & 0x0c) >> 2; // eg\n\n    penColor.edgeBlue = b & 0x03; // eb\n\n    return i;\n  };\n  /**\n   * Parse and execute the SPL command.\n   *\n   * Set pen location of the current window.\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.setPenLocation = function (i, service) {\n    var packetData = this.current708Packet.data;\n    var b = packetData[i];\n    var penLoc = service.currentWindow.penLoc; // Positioning isn't really supported at the moment, so this essentially just inserts a linebreak\n\n    service.currentWindow.pendingNewLine = true;\n    b = packetData[++i];\n    penLoc.row = b & 0x0f; // r\n\n    b = packetData[++i];\n    penLoc.column = b & 0x3f; // c\n\n    return i;\n  };\n  /**\n   * Execute the RST command.\n   *\n   * Reset service to a clean slate. Re-initialize.\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Service}          Re-initialized service\n   */\n\n\n  Cea708Stream.prototype.reset = function (i, service) {\n    var pts = this.getPts(i);\n    this.flushDisplayed(pts, service);\n    return this.initService(service.serviceNum, i);\n  }; // This hash maps non-ASCII, special, and extended character codes to their\n  // proper Unicode equivalent. The first keys that are only a single byte\n  // are the non-standard ASCII characters, which simply map the CEA608 byte\n  // to the standard ASCII/Unicode. The two-byte keys that follow are the CEA608\n  // character codes, but have their MSB bitmasked with 0x03 so that a lookup\n  // can be performed regardless of the field and data channel on which the\n  // character code was received.\n\n\n  var CHARACTER_TRANSLATION = {\n    0x2a: 0xe1,\n    // \n    0x5c: 0xe9,\n    // \n    0x5e: 0xed,\n    // \n    0x5f: 0xf3,\n    // \n    0x60: 0xfa,\n    // \n    0x7b: 0xe7,\n    // \n    0x7c: 0xf7,\n    // \n    0x7d: 0xd1,\n    // \n    0x7e: 0xf1,\n    // \n    0x7f: 0x2588,\n    // \n    0x0130: 0xae,\n    // \n    0x0131: 0xb0,\n    // \n    0x0132: 0xbd,\n    // \n    0x0133: 0xbf,\n    // \n    0x0134: 0x2122,\n    // \n    0x0135: 0xa2,\n    // \n    0x0136: 0xa3,\n    // \n    0x0137: 0x266a,\n    // \n    0x0138: 0xe0,\n    // \n    0x0139: 0xa0,\n    //\n    0x013a: 0xe8,\n    // \n    0x013b: 0xe2,\n    // \n    0x013c: 0xea,\n    // \n    0x013d: 0xee,\n    // \n    0x013e: 0xf4,\n    // \n    0x013f: 0xfb,\n    // \n    0x0220: 0xc1,\n    // \n    0x0221: 0xc9,\n    // \n    0x0222: 0xd3,\n    // \n    0x0223: 0xda,\n    // \n    0x0224: 0xdc,\n    // \n    0x0225: 0xfc,\n    // \n    0x0226: 0x2018,\n    // \n    0x0227: 0xa1,\n    // \n    0x0228: 0x2a,\n    // *\n    0x0229: 0x27,\n    // '\n    0x022a: 0x2014,\n    // \n    0x022b: 0xa9,\n    // \n    0x022c: 0x2120,\n    // \n    0x022d: 0x2022,\n    // \n    0x022e: 0x201c,\n    // \n    0x022f: 0x201d,\n    // \n    0x0230: 0xc0,\n    // \n    0x0231: 0xc2,\n    // \n    0x0232: 0xc7,\n    // \n    0x0233: 0xc8,\n    // \n    0x0234: 0xca,\n    // \n    0x0235: 0xcb,\n    // \n    0x0236: 0xeb,\n    // \n    0x0237: 0xce,\n    // \n    0x0238: 0xcf,\n    // \n    0x0239: 0xef,\n    // \n    0x023a: 0xd4,\n    // \n    0x023b: 0xd9,\n    // \n    0x023c: 0xf9,\n    // \n    0x023d: 0xdb,\n    // \n    0x023e: 0xab,\n    // \n    0x023f: 0xbb,\n    // \n    0x0320: 0xc3,\n    // \n    0x0321: 0xe3,\n    // \n    0x0322: 0xcd,\n    // \n    0x0323: 0xcc,\n    // \n    0x0324: 0xec,\n    // \n    0x0325: 0xd2,\n    // \n    0x0326: 0xf2,\n    // \n    0x0327: 0xd5,\n    // \n    0x0328: 0xf5,\n    // \n    0x0329: 0x7b,\n    // {\n    0x032a: 0x7d,\n    // }\n    0x032b: 0x5c,\n    // \\\n    0x032c: 0x5e,\n    // ^\n    0x032d: 0x5f,\n    // _\n    0x032e: 0x7c,\n    // |\n    0x032f: 0x7e,\n    // ~\n    0x0330: 0xc4,\n    // \n    0x0331: 0xe4,\n    // \n    0x0332: 0xd6,\n    // \n    0x0333: 0xf6,\n    // \n    0x0334: 0xdf,\n    // \n    0x0335: 0xa5,\n    // \n    0x0336: 0xa4,\n    // \n    0x0337: 0x2502,\n    // \n    0x0338: 0xc5,\n    // \n    0x0339: 0xe5,\n    // \n    0x033a: 0xd8,\n    // \n    0x033b: 0xf8,\n    // \n    0x033c: 0x250c,\n    // \n    0x033d: 0x2510,\n    // \n    0x033e: 0x2514,\n    // \n    0x033f: 0x2518 // \n\n  };\n\n  var getCharFromCode = function getCharFromCode(code) {\n    if (code === null) {\n      return '';\n    }\n\n    code = CHARACTER_TRANSLATION[code] || code;\n    return String.fromCharCode(code);\n  }; // the index of the last row in a CEA-608 display buffer\n\n\n  var BOTTOM_ROW = 14; // This array is used for mapping PACs -> row #, since there's no way of\n  // getting it through bit logic.\n\n  var ROWS = [0x1100, 0x1120, 0x1200, 0x1220, 0x1500, 0x1520, 0x1600, 0x1620, 0x1700, 0x1720, 0x1000, 0x1300, 0x1320, 0x1400, 0x1420]; // CEA-608 captions are rendered onto a 34x15 matrix of character\n  // cells. The \"bottom\" row is the last element in the outer array.\n\n  var createDisplayBuffer = function createDisplayBuffer() {\n    var result = [],\n        i = BOTTOM_ROW + 1;\n\n    while (i--) {\n      result.push('');\n    }\n\n    return result;\n  };\n\n  var Cea608Stream = function Cea608Stream(field, dataChannel) {\n    Cea608Stream.prototype.init.call(this);\n    this.field_ = field || 0;\n    this.dataChannel_ = dataChannel || 0;\n    this.name_ = 'CC' + ((this.field_ << 1 | this.dataChannel_) + 1);\n    this.setConstants();\n    this.reset();\n\n    this.push = function (packet) {\n      var data, swap, char0, char1, text; // remove the parity bits\n\n      data = packet.ccData & 0x7f7f; // ignore duplicate control codes; the spec demands they're sent twice\n\n      if (data === this.lastControlCode_) {\n        this.lastControlCode_ = null;\n        return;\n      } // Store control codes\n\n\n      if ((data & 0xf000) === 0x1000) {\n        this.lastControlCode_ = data;\n      } else if (data !== this.PADDING_) {\n        this.lastControlCode_ = null;\n      }\n\n      char0 = data >>> 8;\n      char1 = data & 0xff;\n\n      if (data === this.PADDING_) {\n        return;\n      } else if (data === this.RESUME_CAPTION_LOADING_) {\n        this.mode_ = 'popOn';\n      } else if (data === this.END_OF_CAPTION_) {\n        // If an EOC is received while in paint-on mode, the displayed caption\n        // text should be swapped to non-displayed memory as if it was a pop-on\n        // caption. Because of that, we should explicitly switch back to pop-on\n        // mode\n        this.mode_ = 'popOn';\n        this.clearFormatting(packet.pts); // if a caption was being displayed, it's gone now\n\n        this.flushDisplayed(packet.pts); // flip memory\n\n        swap = this.displayed_;\n        this.displayed_ = this.nonDisplayed_;\n        this.nonDisplayed_ = swap; // start measuring the time to display the caption\n\n        this.startPts_ = packet.pts;\n      } else if (data === this.ROLL_UP_2_ROWS_) {\n        this.rollUpRows_ = 2;\n        this.setRollUp(packet.pts);\n      } else if (data === this.ROLL_UP_3_ROWS_) {\n        this.rollUpRows_ = 3;\n        this.setRollUp(packet.pts);\n      } else if (data === this.ROLL_UP_4_ROWS_) {\n        this.rollUpRows_ = 4;\n        this.setRollUp(packet.pts);\n      } else if (data === this.CARRIAGE_RETURN_) {\n        this.clearFormatting(packet.pts);\n        this.flushDisplayed(packet.pts);\n        this.shiftRowsUp_();\n        this.startPts_ = packet.pts;\n      } else if (data === this.BACKSPACE_) {\n        if (this.mode_ === 'popOn') {\n          this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1);\n        } else {\n          this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1);\n        }\n      } else if (data === this.ERASE_DISPLAYED_MEMORY_) {\n        this.flushDisplayed(packet.pts);\n        this.displayed_ = createDisplayBuffer();\n      } else if (data === this.ERASE_NON_DISPLAYED_MEMORY_) {\n        this.nonDisplayed_ = createDisplayBuffer();\n      } else if (data === this.RESUME_DIRECT_CAPTIONING_) {\n        if (this.mode_ !== 'paintOn') {\n          // NOTE: This should be removed when proper caption positioning is\n          // implemented\n          this.flushDisplayed(packet.pts);\n          this.displayed_ = createDisplayBuffer();\n        }\n\n        this.mode_ = 'paintOn';\n        this.startPts_ = packet.pts; // Append special characters to caption text\n      } else if (this.isSpecialCharacter(char0, char1)) {\n        // Bitmask char0 so that we can apply character transformations\n        // regardless of field and data channel.\n        // Then byte-shift to the left and OR with char1 so we can pass the\n        // entire character code to `getCharFromCode`.\n        char0 = (char0 & 0x03) << 8;\n        text = getCharFromCode(char0 | char1);\n        this[this.mode_](packet.pts, text);\n        this.column_++; // Append extended characters to caption text\n      } else if (this.isExtCharacter(char0, char1)) {\n        // Extended characters always follow their \"non-extended\" equivalents.\n        // IE if a \"\" is desired, you'll always receive \"e\"; non-compliant\n        // decoders are supposed to drop the \"\", while compliant decoders\n        // backspace the \"e\" and insert \"\".\n        // Delete the previous character\n        if (this.mode_ === 'popOn') {\n          this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1);\n        } else {\n          this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1);\n        } // Bitmask char0 so that we can apply character transformations\n        // regardless of field and data channel.\n        // Then byte-shift to the left and OR with char1 so we can pass the\n        // entire character code to `getCharFromCode`.\n\n\n        char0 = (char0 & 0x03) << 8;\n        text = getCharFromCode(char0 | char1);\n        this[this.mode_](packet.pts, text);\n        this.column_++; // Process mid-row codes\n      } else if (this.isMidRowCode(char0, char1)) {\n        // Attributes are not additive, so clear all formatting\n        this.clearFormatting(packet.pts); // According to the standard, mid-row codes\n        // should be replaced with spaces, so add one now\n\n        this[this.mode_](packet.pts, ' ');\n        this.column_++;\n\n        if ((char1 & 0xe) === 0xe) {\n          this.addFormatting(packet.pts, ['i']);\n        }\n\n        if ((char1 & 0x1) === 0x1) {\n          this.addFormatting(packet.pts, ['u']);\n        } // Detect offset control codes and adjust cursor\n\n      } else if (this.isOffsetControlCode(char0, char1)) {\n        // Cursor position is set by indent PAC (see below) in 4-column\n        // increments, with an additional offset code of 1-3 to reach any\n        // of the 32 columns specified by CEA-608. So all we need to do\n        // here is increment the column cursor by the given offset.\n        this.column_ += char1 & 0x03; // Detect PACs (Preamble Address Codes)\n      } else if (this.isPAC(char0, char1)) {\n        // There's no logic for PAC -> row mapping, so we have to just\n        // find the row code in an array and use its index :(\n        var row = ROWS.indexOf(data & 0x1f20); // Configure the caption window if we're in roll-up mode\n\n        if (this.mode_ === 'rollUp') {\n          // This implies that the base row is incorrectly set.\n          // As per the recommendation in CEA-608(Base Row Implementation), defer to the number\n          // of roll-up rows set.\n          if (row - this.rollUpRows_ + 1 < 0) {\n            row = this.rollUpRows_ - 1;\n          }\n\n          this.setRollUp(packet.pts, row);\n        }\n\n        if (row !== this.row_) {\n          // formatting is only persistent for current row\n          this.clearFormatting(packet.pts);\n          this.row_ = row;\n        } // All PACs can apply underline, so detect and apply\n        // (All odd-numbered second bytes set underline)\n\n\n        if (char1 & 0x1 && this.formatting_.indexOf('u') === -1) {\n          this.addFormatting(packet.pts, ['u']);\n        }\n\n        if ((data & 0x10) === 0x10) {\n          // We've got an indent level code. Each successive even number\n          // increments the column cursor by 4, so we can get the desired\n          // column position by bit-shifting to the right (to get n/2)\n          // and multiplying by 4.\n          this.column_ = ((data & 0xe) >> 1) * 4;\n        }\n\n        if (this.isColorPAC(char1)) {\n          // it's a color code, though we only support white, which\n          // can be either normal or italicized. white italics can be\n          // either 0x4e or 0x6e depending on the row, so we just\n          // bitwise-and with 0xe to see if italics should be turned on\n          if ((char1 & 0xe) === 0xe) {\n            this.addFormatting(packet.pts, ['i']);\n          }\n        } // We have a normal character in char0, and possibly one in char1\n\n      } else if (this.isNormalChar(char0)) {\n        if (char1 === 0x00) {\n          char1 = null;\n        }\n\n        text = getCharFromCode(char0);\n        text += getCharFromCode(char1);\n        this[this.mode_](packet.pts, text);\n        this.column_ += text.length;\n      } // finish data processing\n\n    };\n  };\n\n  Cea608Stream.prototype = new stream(); // Trigger a cue point that captures the current state of the\n  // display buffer\n\n  Cea608Stream.prototype.flushDisplayed = function (pts) {\n    var content = this.displayed_ // remove spaces from the start and end of the string\n    .map(function (row, index) {\n      try {\n        return row.trim();\n      } catch (e) {\n        // Ordinarily, this shouldn't happen. However, caption\n        // parsing errors should not throw exceptions and\n        // break playback.\n        this.trigger('log', {\n          level: 'warn',\n          message: 'Skipping a malformed 608 caption at index ' + index + '.'\n        });\n        return '';\n      }\n    }, this) // combine all text rows to display in one cue\n    .join('\\n') // and remove blank rows from the start and end, but not the middle\n    .replace(/^\\n+|\\n+$/g, '');\n\n    if (content.length) {\n      this.trigger('data', {\n        startPts: this.startPts_,\n        endPts: pts,\n        text: content,\n        stream: this.name_\n      });\n    }\n  };\n  /**\n   * Zero out the data, used for startup and on seek\n   */\n\n\n  Cea608Stream.prototype.reset = function () {\n    this.mode_ = 'popOn'; // When in roll-up mode, the index of the last row that will\n    // actually display captions. If a caption is shifted to a row\n    // with a lower index than this, it is cleared from the display\n    // buffer\n\n    this.topRow_ = 0;\n    this.startPts_ = 0;\n    this.displayed_ = createDisplayBuffer();\n    this.nonDisplayed_ = createDisplayBuffer();\n    this.lastControlCode_ = null; // Track row and column for proper line-breaking and spacing\n\n    this.column_ = 0;\n    this.row_ = BOTTOM_ROW;\n    this.rollUpRows_ = 2; // This variable holds currently-applied formatting\n\n    this.formatting_ = [];\n  };\n  /**\n   * Sets up control code and related constants for this instance\n   */\n\n\n  Cea608Stream.prototype.setConstants = function () {\n    // The following attributes have these uses:\n    // ext_ :    char0 for mid-row codes, and the base for extended\n    //           chars (ext_+0, ext_+1, and ext_+2 are char0s for\n    //           extended codes)\n    // control_: char0 for control codes, except byte-shifted to the\n    //           left so that we can do this.control_ | CONTROL_CODE\n    // offset_:  char0 for tab offset codes\n    //\n    // It's also worth noting that control codes, and _only_ control codes,\n    // differ between field 1 and field2. Field 2 control codes are always\n    // their field 1 value plus 1. That's why there's the \"| field\" on the\n    // control value.\n    if (this.dataChannel_ === 0) {\n      this.BASE_ = 0x10;\n      this.EXT_ = 0x11;\n      this.CONTROL_ = (0x14 | this.field_) << 8;\n      this.OFFSET_ = 0x17;\n    } else if (this.dataChannel_ === 1) {\n      this.BASE_ = 0x18;\n      this.EXT_ = 0x19;\n      this.CONTROL_ = (0x1c | this.field_) << 8;\n      this.OFFSET_ = 0x1f;\n    } // Constants for the LSByte command codes recognized by Cea608Stream. This\n    // list is not exhaustive. For a more comprehensive listing and semantics see\n    // http://www.gpo.gov/fdsys/pkg/CFR-2010-title47-vol1/pdf/CFR-2010-title47-vol1-sec15-119.pdf\n    // Padding\n\n\n    this.PADDING_ = 0x0000; // Pop-on Mode\n\n    this.RESUME_CAPTION_LOADING_ = this.CONTROL_ | 0x20;\n    this.END_OF_CAPTION_ = this.CONTROL_ | 0x2f; // Roll-up Mode\n\n    this.ROLL_UP_2_ROWS_ = this.CONTROL_ | 0x25;\n    this.ROLL_UP_3_ROWS_ = this.CONTROL_ | 0x26;\n    this.ROLL_UP_4_ROWS_ = this.CONTROL_ | 0x27;\n    this.CARRIAGE_RETURN_ = this.CONTROL_ | 0x2d; // paint-on mode\n\n    this.RESUME_DIRECT_CAPTIONING_ = this.CONTROL_ | 0x29; // Erasure\n\n    this.BACKSPACE_ = this.CONTROL_ | 0x21;\n    this.ERASE_DISPLAYED_MEMORY_ = this.CONTROL_ | 0x2c;\n    this.ERASE_NON_DISPLAYED_MEMORY_ = this.CONTROL_ | 0x2e;\n  };\n  /**\n   * Detects if the 2-byte packet data is a special character\n   *\n   * Special characters have a second byte in the range 0x30 to 0x3f,\n   * with the first byte being 0x11 (for data channel 1) or 0x19 (for\n   * data channel 2).\n   *\n   * @param  {Integer} char0 The first byte\n   * @param  {Integer} char1 The second byte\n   * @return {Boolean}       Whether the 2 bytes are an special character\n   */\n\n\n  Cea608Stream.prototype.isSpecialCharacter = function (char0, char1) {\n    return char0 === this.EXT_ && char1 >= 0x30 && char1 <= 0x3f;\n  };\n  /**\n   * Detects if the 2-byte packet data is an extended character\n   *\n   * Extended characters have a second byte in the range 0x20 to 0x3f,\n   * with the first byte being 0x12 or 0x13 (for data channel 1) or\n   * 0x1a or 0x1b (for data channel 2).\n   *\n   * @param  {Integer} char0 The first byte\n   * @param  {Integer} char1 The second byte\n   * @return {Boolean}       Whether the 2 bytes are an extended character\n   */\n\n\n  Cea608Stream.prototype.isExtCharacter = function (char0, char1) {\n    return (char0 === this.EXT_ + 1 || char0 === this.EXT_ + 2) && char1 >= 0x20 && char1 <= 0x3f;\n  };\n  /**\n   * Detects if the 2-byte packet is a mid-row code\n   *\n   * Mid-row codes have a second byte in the range 0x20 to 0x2f, with\n   * the first byte being 0x11 (for data channel 1) or 0x19 (for data\n   * channel 2).\n   *\n   * @param  {Integer} char0 The first byte\n   * @param  {Integer} char1 The second byte\n   * @return {Boolean}       Whether the 2 bytes are a mid-row code\n   */\n\n\n  Cea608Stream.prototype.isMidRowCode = function (char0, char1) {\n    return char0 === this.EXT_ && char1 >= 0x20 && char1 <= 0x2f;\n  };\n  /**\n   * Detects if the 2-byte packet is an offset control code\n   *\n   * Offset control codes have a second byte in the range 0x21 to 0x23,\n   * with the first byte being 0x17 (for data channel 1) or 0x1f (for\n   * data channel 2).\n   *\n   * @param  {Integer} char0 The first byte\n   * @param  {Integer} char1 The second byte\n   * @return {Boolean}       Whether the 2 bytes are an offset control code\n   */\n\n\n  Cea608Stream.prototype.isOffsetControlCode = function (char0, char1) {\n    return char0 === this.OFFSET_ && char1 >= 0x21 && char1 <= 0x23;\n  };\n  /**\n   * Detects if the 2-byte packet is a Preamble Address Code\n   *\n   * PACs have a first byte in the range 0x10 to 0x17 (for data channel 1)\n   * or 0x18 to 0x1f (for data channel 2), with the second byte in the\n   * range 0x40 to 0x7f.\n   *\n   * @param  {Integer} char0 The first byte\n   * @param  {Integer} char1 The second byte\n   * @return {Boolean}       Whether the 2 bytes are a PAC\n   */\n\n\n  Cea608Stream.prototype.isPAC = function (char0, char1) {\n    return char0 >= this.BASE_ && char0 < this.BASE_ + 8 && char1 >= 0x40 && char1 <= 0x7f;\n  };\n  /**\n   * Detects if a packet's second byte is in the range of a PAC color code\n   *\n   * PAC color codes have the second byte be in the range 0x40 to 0x4f, or\n   * 0x60 to 0x6f.\n   *\n   * @param  {Integer} char1 The second byte\n   * @return {Boolean}       Whether the byte is a color PAC\n   */\n\n\n  Cea608Stream.prototype.isColorPAC = function (char1) {\n    return char1 >= 0x40 && char1 <= 0x4f || char1 >= 0x60 && char1 <= 0x7f;\n  };\n  /**\n   * Detects if a single byte is in the range of a normal character\n   *\n   * Normal text bytes are in the range 0x20 to 0x7f.\n   *\n   * @param  {Integer} char  The byte\n   * @return {Boolean}       Whether the byte is a normal character\n   */\n\n\n  Cea608Stream.prototype.isNormalChar = function (char) {\n    return char >= 0x20 && char <= 0x7f;\n  };\n  /**\n   * Configures roll-up\n   *\n   * @param  {Integer} pts         Current PTS\n   * @param  {Integer} newBaseRow  Used by PACs to slide the current window to\n   *                               a new position\n   */\n\n\n  Cea608Stream.prototype.setRollUp = function (pts, newBaseRow) {\n    // Reset the base row to the bottom row when switching modes\n    if (this.mode_ !== 'rollUp') {\n      this.row_ = BOTTOM_ROW;\n      this.mode_ = 'rollUp'; // Spec says to wipe memories when switching to roll-up\n\n      this.flushDisplayed(pts);\n      this.nonDisplayed_ = createDisplayBuffer();\n      this.displayed_ = createDisplayBuffer();\n    }\n\n    if (newBaseRow !== undefined && newBaseRow !== this.row_) {\n      // move currently displayed captions (up or down) to the new base row\n      for (var i = 0; i < this.rollUpRows_; i++) {\n        this.displayed_[newBaseRow - i] = this.displayed_[this.row_ - i];\n        this.displayed_[this.row_ - i] = '';\n      }\n    }\n\n    if (newBaseRow === undefined) {\n      newBaseRow = this.row_;\n    }\n\n    this.topRow_ = newBaseRow - this.rollUpRows_ + 1;\n  }; // Adds the opening HTML tag for the passed character to the caption text,\n  // and keeps track of it for later closing\n\n\n  Cea608Stream.prototype.addFormatting = function (pts, format) {\n    this.formatting_ = this.formatting_.concat(format);\n    var text = format.reduce(function (text, format) {\n      return text + '<' + format + '>';\n    }, '');\n    this[this.mode_](pts, text);\n  }; // Adds HTML closing tags for current formatting to caption text and\n  // clears remembered formatting\n\n\n  Cea608Stream.prototype.clearFormatting = function (pts) {\n    if (!this.formatting_.length) {\n      return;\n    }\n\n    var text = this.formatting_.reverse().reduce(function (text, format) {\n      return text + '</' + format + '>';\n    }, '');\n    this.formatting_ = [];\n    this[this.mode_](pts, text);\n  }; // Mode Implementations\n\n\n  Cea608Stream.prototype.popOn = function (pts, text) {\n    var baseRow = this.nonDisplayed_[this.row_]; // buffer characters\n\n    baseRow += text;\n    this.nonDisplayed_[this.row_] = baseRow;\n  };\n\n  Cea608Stream.prototype.rollUp = function (pts, text) {\n    var baseRow = this.displayed_[this.row_];\n    baseRow += text;\n    this.displayed_[this.row_] = baseRow;\n  };\n\n  Cea608Stream.prototype.shiftRowsUp_ = function () {\n    var i; // clear out inactive rows\n\n    for (i = 0; i < this.topRow_; i++) {\n      this.displayed_[i] = '';\n    }\n\n    for (i = this.row_ + 1; i < BOTTOM_ROW + 1; i++) {\n      this.displayed_[i] = '';\n    } // shift displayed rows up\n\n\n    for (i = this.topRow_; i < this.row_; i++) {\n      this.displayed_[i] = this.displayed_[i + 1];\n    } // clear out the bottom row\n\n\n    this.displayed_[this.row_] = '';\n  };\n\n  Cea608Stream.prototype.paintOn = function (pts, text) {\n    var baseRow = this.displayed_[this.row_];\n    baseRow += text;\n    this.displayed_[this.row_] = baseRow;\n  }; // exports\n\n\n  var captionStream = {\n    CaptionStream: CaptionStream$1,\n    Cea608Stream: Cea608Stream,\n    Cea708Stream: Cea708Stream\n  };\n\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n\n  var streamTypes = {\n    H264_STREAM_TYPE: 0x1B,\n    ADTS_STREAM_TYPE: 0x0F,\n    METADATA_STREAM_TYPE: 0x15\n  };\n\n  var MAX_TS = 8589934592;\n  var RO_THRESH = 4294967296;\n  var TYPE_SHARED = 'shared';\n\n  var handleRollover$1 = function handleRollover(value, reference) {\n    var direction = 1;\n\n    if (value > reference) {\n      // If the current timestamp value is greater than our reference timestamp and we detect a\n      // timestamp rollover, this means the roll over is happening in the opposite direction.\n      // Example scenario: Enter a long stream/video just after a rollover occurred. The reference\n      // point will be set to a small number, e.g. 1. The user then seeks backwards over the\n      // rollover point. In loading this segment, the timestamp values will be very large,\n      // e.g. 2^33 - 1. Since this comes before the data we loaded previously, we want to adjust\n      // the time stamp to be `value - 2^33`.\n      direction = -1;\n    } // Note: A seek forwards or back that is greater than the RO_THRESH (2^32, ~13 hours) will\n    // cause an incorrect adjustment.\n\n\n    while (Math.abs(reference - value) > RO_THRESH) {\n      value += direction * MAX_TS;\n    }\n\n    return value;\n  };\n\n  var TimestampRolloverStream$1 = function TimestampRolloverStream(type) {\n    var lastDTS, referenceDTS;\n    TimestampRolloverStream.prototype.init.call(this); // The \"shared\" type is used in cases where a stream will contain muxed\n    // video and audio. We could use `undefined` here, but having a string\n    // makes debugging a little clearer.\n\n    this.type_ = type || TYPE_SHARED;\n\n    this.push = function (data) {\n      // Any \"shared\" rollover streams will accept _all_ data. Otherwise,\n      // streams will only accept data that matches their type.\n      if (this.type_ !== TYPE_SHARED && data.type !== this.type_) {\n        return;\n      }\n\n      if (referenceDTS === undefined) {\n        referenceDTS = data.dts;\n      }\n\n      data.dts = handleRollover$1(data.dts, referenceDTS);\n      data.pts = handleRollover$1(data.pts, referenceDTS);\n      lastDTS = data.dts;\n      this.trigger('data', data);\n    };\n\n    this.flush = function () {\n      referenceDTS = lastDTS;\n      this.trigger('done');\n    };\n\n    this.endTimeline = function () {\n      this.flush();\n      this.trigger('endedtimeline');\n    };\n\n    this.discontinuity = function () {\n      referenceDTS = void 0;\n      lastDTS = void 0;\n    };\n\n    this.reset = function () {\n      this.discontinuity();\n      this.trigger('reset');\n    };\n  };\n\n  TimestampRolloverStream$1.prototype = new stream();\n  var timestampRolloverStream = {\n    TimestampRolloverStream: TimestampRolloverStream$1,\n    handleRollover: handleRollover$1\n  };\n\n  var percentEncode$1 = function percentEncode(bytes, start, end) {\n    var i,\n        result = '';\n\n    for (i = start; i < end; i++) {\n      result += '%' + ('00' + bytes[i].toString(16)).slice(-2);\n    }\n\n    return result;\n  },\n      // return the string representation of the specified byte range,\n  // interpreted as UTf-8.\n  parseUtf8 = function parseUtf8(bytes, start, end) {\n    return decodeURIComponent(percentEncode$1(bytes, start, end));\n  },\n      // return the string representation of the specified byte range,\n  // interpreted as ISO-8859-1.\n  parseIso88591$1 = function parseIso88591(bytes, start, end) {\n    return unescape(percentEncode$1(bytes, start, end)); // jshint ignore:line\n  },\n      parseSyncSafeInteger$1 = function parseSyncSafeInteger(data) {\n    return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];\n  },\n      tagParsers = {\n    TXXX: function TXXX(tag) {\n      var i;\n\n      if (tag.data[0] !== 3) {\n        // ignore frames with unrecognized character encodings\n        return;\n      }\n\n      for (i = 1; i < tag.data.length; i++) {\n        if (tag.data[i] === 0) {\n          // parse the text fields\n          tag.description = parseUtf8(tag.data, 1, i); // do not include the null terminator in the tag value\n\n          tag.value = parseUtf8(tag.data, i + 1, tag.data.length).replace(/\\0*$/, '');\n          break;\n        }\n      }\n\n      tag.data = tag.value;\n    },\n    WXXX: function WXXX(tag) {\n      var i;\n\n      if (tag.data[0] !== 3) {\n        // ignore frames with unrecognized character encodings\n        return;\n      }\n\n      for (i = 1; i < tag.data.length; i++) {\n        if (tag.data[i] === 0) {\n          // parse the description and URL fields\n          tag.description = parseUtf8(tag.data, 1, i);\n          tag.url = parseUtf8(tag.data, i + 1, tag.data.length);\n          break;\n        }\n      }\n    },\n    PRIV: function PRIV(tag) {\n      var i;\n\n      for (i = 0; i < tag.data.length; i++) {\n        if (tag.data[i] === 0) {\n          // parse the description and URL fields\n          tag.owner = parseIso88591$1(tag.data, 0, i);\n          break;\n        }\n      }\n\n      tag.privateData = tag.data.subarray(i + 1);\n      tag.data = tag.privateData;\n    }\n  },\n      _MetadataStream;\n\n  _MetadataStream = function MetadataStream(options) {\n    var settings = {\n      // the bytes of the program-level descriptor field in MP2T\n      // see ISO/IEC 13818-1:2013 (E), section 2.6 \"Program and\n      // program element descriptors\"\n      descriptor: options && options.descriptor\n    },\n        // the total size in bytes of the ID3 tag being parsed\n    tagSize = 0,\n        // tag data that is not complete enough to be parsed\n    buffer = [],\n        // the total number of bytes currently in the buffer\n    bufferSize = 0,\n        i;\n\n    _MetadataStream.prototype.init.call(this); // calculate the text track in-band metadata track dispatch type\n    // https://html.spec.whatwg.org/multipage/embedded-content.html#steps-to-expose-a-media-resource-specific-text-track\n\n\n    this.dispatchType = streamTypes.METADATA_STREAM_TYPE.toString(16);\n\n    if (settings.descriptor) {\n      for (i = 0; i < settings.descriptor.length; i++) {\n        this.dispatchType += ('00' + settings.descriptor[i].toString(16)).slice(-2);\n      }\n    }\n\n    this.push = function (chunk) {\n      var tag, frameStart, frameSize, frame, i, frameHeader;\n\n      if (chunk.type !== 'timed-metadata') {\n        return;\n      } // if data_alignment_indicator is set in the PES header,\n      // we must have the start of a new ID3 tag. Assume anything\n      // remaining in the buffer was malformed and throw it out\n\n\n      if (chunk.dataAlignmentIndicator) {\n        bufferSize = 0;\n        buffer.length = 0;\n      } // ignore events that don't look like ID3 data\n\n\n      if (buffer.length === 0 && (chunk.data.length < 10 || chunk.data[0] !== 'I'.charCodeAt(0) || chunk.data[1] !== 'D'.charCodeAt(0) || chunk.data[2] !== '3'.charCodeAt(0))) {\n        this.trigger('log', {\n          level: 'warn',\n          message: 'Skipping unrecognized metadata packet'\n        });\n        return;\n      } // add this chunk to the data we've collected so far\n\n\n      buffer.push(chunk);\n      bufferSize += chunk.data.byteLength; // grab the size of the entire frame from the ID3 header\n\n      if (buffer.length === 1) {\n        // the frame size is transmitted as a 28-bit integer in the\n        // last four bytes of the ID3 header.\n        // The most significant bit of each byte is dropped and the\n        // results concatenated to recover the actual value.\n        tagSize = parseSyncSafeInteger$1(chunk.data.subarray(6, 10)); // ID3 reports the tag size excluding the header but it's more\n        // convenient for our comparisons to include it\n\n        tagSize += 10;\n      } // if the entire frame has not arrived, wait for more data\n\n\n      if (bufferSize < tagSize) {\n        return;\n      } // collect the entire frame so it can be parsed\n\n\n      tag = {\n        data: new Uint8Array(tagSize),\n        frames: [],\n        pts: buffer[0].pts,\n        dts: buffer[0].dts\n      };\n\n      for (i = 0; i < tagSize;) {\n        tag.data.set(buffer[0].data.subarray(0, tagSize - i), i);\n        i += buffer[0].data.byteLength;\n        bufferSize -= buffer[0].data.byteLength;\n        buffer.shift();\n      } // find the start of the first frame and the end of the tag\n\n\n      frameStart = 10;\n\n      if (tag.data[5] & 0x40) {\n        // advance the frame start past the extended header\n        frameStart += 4; // header size field\n\n        frameStart += parseSyncSafeInteger$1(tag.data.subarray(10, 14)); // clip any padding off the end\n\n        tagSize -= parseSyncSafeInteger$1(tag.data.subarray(16, 20));\n      } // parse one or more ID3 frames\n      // http://id3.org/id3v2.3.0#ID3v2_frame_overview\n\n\n      do {\n        // determine the number of bytes in this frame\n        frameSize = parseSyncSafeInteger$1(tag.data.subarray(frameStart + 4, frameStart + 8));\n\n        if (frameSize < 1) {\n          this.trigger('log', {\n            level: 'warn',\n            message: 'Malformed ID3 frame encountered. Skipping metadata parsing.'\n          });\n          return;\n        }\n\n        frameHeader = String.fromCharCode(tag.data[frameStart], tag.data[frameStart + 1], tag.data[frameStart + 2], tag.data[frameStart + 3]);\n        frame = {\n          id: frameHeader,\n          data: tag.data.subarray(frameStart + 10, frameStart + frameSize + 10)\n        };\n        frame.key = frame.id;\n\n        if (tagParsers[frame.id]) {\n          tagParsers[frame.id](frame); // handle the special PRIV frame used to indicate the start\n          // time for raw AAC data\n\n          if (frame.owner === 'com.apple.streaming.transportStreamTimestamp') {\n            var d = frame.data,\n                size = (d[3] & 0x01) << 30 | d[4] << 22 | d[5] << 14 | d[6] << 6 | d[7] >>> 2;\n            size *= 4;\n            size += d[7] & 0x03;\n            frame.timeStamp = size; // in raw AAC, all subsequent data will be timestamped based\n            // on the value of this frame\n            // we couldn't have known the appropriate pts and dts before\n            // parsing this ID3 tag so set those values now\n\n            if (tag.pts === undefined && tag.dts === undefined) {\n              tag.pts = frame.timeStamp;\n              tag.dts = frame.timeStamp;\n            }\n\n            this.trigger('timestamp', frame);\n          }\n        }\n\n        tag.frames.push(frame);\n        frameStart += 10; // advance past the frame header\n\n        frameStart += frameSize; // advance past the frame body\n      } while (frameStart < tagSize);\n\n      this.trigger('data', tag);\n    };\n  };\n\n  _MetadataStream.prototype = new stream();\n  var metadataStream = _MetadataStream;\n\n  var TimestampRolloverStream = timestampRolloverStream.TimestampRolloverStream; // object types\n\n  var _TransportPacketStream, _TransportParseStream, _ElementaryStream; // constants\n\n\n  var MP2T_PACKET_LENGTH$1 = 188,\n      // bytes\n  SYNC_BYTE$1 = 0x47;\n  /**\n   * Splits an incoming stream of binary data into MPEG-2 Transport\n   * Stream packets.\n   */\n\n  _TransportPacketStream = function TransportPacketStream() {\n    var buffer = new Uint8Array(MP2T_PACKET_LENGTH$1),\n        bytesInBuffer = 0;\n\n    _TransportPacketStream.prototype.init.call(this); // Deliver new bytes to the stream.\n\n    /**\n     * Split a stream of data into M2TS packets\n    **/\n\n\n    this.push = function (bytes) {\n      var startIndex = 0,\n          endIndex = MP2T_PACKET_LENGTH$1,\n          everything; // If there are bytes remaining from the last segment, prepend them to the\n      // bytes that were pushed in\n\n      if (bytesInBuffer) {\n        everything = new Uint8Array(bytes.byteLength + bytesInBuffer);\n        everything.set(buffer.subarray(0, bytesInBuffer));\n        everything.set(bytes, bytesInBuffer);\n        bytesInBuffer = 0;\n      } else {\n        everything = bytes;\n      } // While we have enough data for a packet\n\n\n      while (endIndex < everything.byteLength) {\n        // Look for a pair of start and end sync bytes in the data..\n        if (everything[startIndex] === SYNC_BYTE$1 && everything[endIndex] === SYNC_BYTE$1) {\n          // We found a packet so emit it and jump one whole packet forward in\n          // the stream\n          this.trigger('data', everything.subarray(startIndex, endIndex));\n          startIndex += MP2T_PACKET_LENGTH$1;\n          endIndex += MP2T_PACKET_LENGTH$1;\n          continue;\n        } // If we get here, we have somehow become de-synchronized and we need to step\n        // forward one byte at a time until we find a pair of sync bytes that denote\n        // a packet\n\n\n        startIndex++;\n        endIndex++;\n      } // If there was some data left over at the end of the segment that couldn't\n      // possibly be a whole packet, keep it because it might be the start of a packet\n      // that continues in the next segment\n\n\n      if (startIndex < everything.byteLength) {\n        buffer.set(everything.subarray(startIndex), 0);\n        bytesInBuffer = everything.byteLength - startIndex;\n      }\n    };\n    /**\n     * Passes identified M2TS packets to the TransportParseStream to be parsed\n    **/\n\n\n    this.flush = function () {\n      // If the buffer contains a whole packet when we are being flushed, emit it\n      // and empty the buffer. Otherwise hold onto the data because it may be\n      // important for decoding the next segment\n      if (bytesInBuffer === MP2T_PACKET_LENGTH$1 && buffer[0] === SYNC_BYTE$1) {\n        this.trigger('data', buffer);\n        bytesInBuffer = 0;\n      }\n\n      this.trigger('done');\n    };\n\n    this.endTimeline = function () {\n      this.flush();\n      this.trigger('endedtimeline');\n    };\n\n    this.reset = function () {\n      bytesInBuffer = 0;\n      this.trigger('reset');\n    };\n  };\n\n  _TransportPacketStream.prototype = new stream();\n  /**\n   * Accepts an MP2T TransportPacketStream and emits data events with parsed\n   * forms of the individual transport stream packets.\n   */\n\n  _TransportParseStream = function TransportParseStream() {\n    var parsePsi, parsePat, parsePmt, self;\n\n    _TransportParseStream.prototype.init.call(this);\n\n    self = this;\n    this.packetsWaitingForPmt = [];\n    this.programMapTable = undefined;\n\n    parsePsi = function parsePsi(payload, psi) {\n      var offset = 0; // PSI packets may be split into multiple sections and those\n      // sections may be split into multiple packets. If a PSI\n      // section starts in this packet, the payload_unit_start_indicator\n      // will be true and the first byte of the payload will indicate\n      // the offset from the current position to the start of the\n      // section.\n\n      if (psi.payloadUnitStartIndicator) {\n        offset += payload[offset] + 1;\n      }\n\n      if (psi.type === 'pat') {\n        parsePat(payload.subarray(offset), psi);\n      } else {\n        parsePmt(payload.subarray(offset), psi);\n      }\n    };\n\n    parsePat = function parsePat(payload, pat) {\n      pat.section_number = payload[7]; // eslint-disable-line camelcase\n\n      pat.last_section_number = payload[8]; // eslint-disable-line camelcase\n      // skip the PSI header and parse the first PMT entry\n\n      self.pmtPid = (payload[10] & 0x1F) << 8 | payload[11];\n      pat.pmtPid = self.pmtPid;\n    };\n    /**\n     * Parse out the relevant fields of a Program Map Table (PMT).\n     * @param payload {Uint8Array} the PMT-specific portion of an MP2T\n     * packet. The first byte in this array should be the table_id\n     * field.\n     * @param pmt {object} the object that should be decorated with\n     * fields parsed from the PMT.\n     */\n\n\n    parsePmt = function parsePmt(payload, pmt) {\n      var sectionLength, tableEnd, programInfoLength, offset; // PMTs can be sent ahead of the time when they should actually\n      // take effect. We don't believe this should ever be the case\n      // for HLS but we'll ignore \"forward\" PMT declarations if we see\n      // them. Future PMT declarations have the current_next_indicator\n      // set to zero.\n\n      if (!(payload[5] & 0x01)) {\n        return;\n      } // overwrite any existing program map table\n\n\n      self.programMapTable = {\n        video: null,\n        audio: null,\n        'timed-metadata': {}\n      }; // the mapping table ends at the end of the current section\n\n      sectionLength = (payload[1] & 0x0f) << 8 | payload[2];\n      tableEnd = 3 + sectionLength - 4; // to determine where the table is, we have to figure out how\n      // long the program info descriptors are\n\n      programInfoLength = (payload[10] & 0x0f) << 8 | payload[11]; // advance the offset to the first entry in the mapping table\n\n      offset = 12 + programInfoLength;\n\n      while (offset < tableEnd) {\n        var streamType = payload[offset];\n        var pid = (payload[offset + 1] & 0x1F) << 8 | payload[offset + 2]; // only map a single elementary_pid for audio and video stream types\n        // TODO: should this be done for metadata too? for now maintain behavior of\n        //       multiple metadata streams\n\n        if (streamType === streamTypes.H264_STREAM_TYPE && self.programMapTable.video === null) {\n          self.programMapTable.video = pid;\n        } else if (streamType === streamTypes.ADTS_STREAM_TYPE && self.programMapTable.audio === null) {\n          self.programMapTable.audio = pid;\n        } else if (streamType === streamTypes.METADATA_STREAM_TYPE) {\n          // map pid to stream type for metadata streams\n          self.programMapTable['timed-metadata'][pid] = streamType;\n        } // move to the next table entry\n        // skip past the elementary stream descriptors, if present\n\n\n        offset += ((payload[offset + 3] & 0x0F) << 8 | payload[offset + 4]) + 5;\n      } // record the map on the packet as well\n\n\n      pmt.programMapTable = self.programMapTable;\n    };\n    /**\n     * Deliver a new MP2T packet to the next stream in the pipeline.\n     */\n\n\n    this.push = function (packet) {\n      var result = {},\n          offset = 4;\n      result.payloadUnitStartIndicator = !!(packet[1] & 0x40); // pid is a 13-bit field starting at the last bit of packet[1]\n\n      result.pid = packet[1] & 0x1f;\n      result.pid <<= 8;\n      result.pid |= packet[2]; // if an adaption field is present, its length is specified by the\n      // fifth byte of the TS packet header. The adaptation field is\n      // used to add stuffing to PES packets that don't fill a complete\n      // TS packet, and to specify some forms of timing and control data\n      // that we do not currently use.\n\n      if ((packet[3] & 0x30) >>> 4 > 0x01) {\n        offset += packet[offset] + 1;\n      } // parse the rest of the packet based on the type\n\n\n      if (result.pid === 0) {\n        result.type = 'pat';\n        parsePsi(packet.subarray(offset), result);\n        this.trigger('data', result);\n      } else if (result.pid === this.pmtPid) {\n        result.type = 'pmt';\n        parsePsi(packet.subarray(offset), result);\n        this.trigger('data', result); // if there are any packets waiting for a PMT to be found, process them now\n\n        while (this.packetsWaitingForPmt.length) {\n          this.processPes_.apply(this, this.packetsWaitingForPmt.shift());\n        }\n      } else if (this.programMapTable === undefined) {\n        // When we have not seen a PMT yet, defer further processing of\n        // PES packets until one has been parsed\n        this.packetsWaitingForPmt.push([packet, offset, result]);\n      } else {\n        this.processPes_(packet, offset, result);\n      }\n    };\n\n    this.processPes_ = function (packet, offset, result) {\n      // set the appropriate stream type\n      if (result.pid === this.programMapTable.video) {\n        result.streamType = streamTypes.H264_STREAM_TYPE;\n      } else if (result.pid === this.programMapTable.audio) {\n        result.streamType = streamTypes.ADTS_STREAM_TYPE;\n      } else {\n        // if not video or audio, it is timed-metadata or unknown\n        // if unknown, streamType will be undefined\n        result.streamType = this.programMapTable['timed-metadata'][result.pid];\n      }\n\n      result.type = 'pes';\n      result.data = packet.subarray(offset);\n      this.trigger('data', result);\n    };\n  };\n\n  _TransportParseStream.prototype = new stream();\n  _TransportParseStream.STREAM_TYPES = {\n    h264: 0x1b,\n    adts: 0x0f\n  };\n  /**\n   * Reconsistutes program elementary stream (PES) packets from parsed\n   * transport stream packets. That is, if you pipe an\n   * mp2t.TransportParseStream into a mp2t.ElementaryStream, the output\n   * events will be events which capture the bytes for individual PES\n   * packets plus relevant metadata that has been extracted from the\n   * container.\n   */\n\n  _ElementaryStream = function ElementaryStream() {\n    var self = this,\n        segmentHadPmt = false,\n        // PES packet fragments\n    video = {\n      data: [],\n      size: 0\n    },\n        audio = {\n      data: [],\n      size: 0\n    },\n        timedMetadata = {\n      data: [],\n      size: 0\n    },\n        programMapTable,\n        parsePes = function parsePes(payload, pes) {\n      var ptsDtsFlags;\n      var startPrefix = payload[0] << 16 | payload[1] << 8 | payload[2]; // default to an empty array\n\n      pes.data = new Uint8Array(); // In certain live streams, the start of a TS fragment has ts packets\n      // that are frame data that is continuing from the previous fragment. This\n      // is to check that the pes data is the start of a new pes payload\n\n      if (startPrefix !== 1) {\n        return;\n      } // get the packet length, this will be 0 for video\n\n\n      pes.packetLength = 6 + (payload[4] << 8 | payload[5]); // find out if this packets starts a new keyframe\n\n      pes.dataAlignmentIndicator = (payload[6] & 0x04) !== 0; // PES packets may be annotated with a PTS value, or a PTS value\n      // and a DTS value. Determine what combination of values is\n      // available to work with.\n\n      ptsDtsFlags = payload[7]; // PTS and DTS are normally stored as a 33-bit number.  Javascript\n      // performs all bitwise operations on 32-bit integers but javascript\n      // supports a much greater range (52-bits) of integer using standard\n      // mathematical operations.\n      // We construct a 31-bit value using bitwise operators over the 31\n      // most significant bits and then multiply by 4 (equal to a left-shift\n      // of 2) before we add the final 2 least significant bits of the\n      // timestamp (equal to an OR.)\n\n      if (ptsDtsFlags & 0xC0) {\n        // the PTS and DTS are not written out directly. For information\n        // on how they are encoded, see\n        // http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n        pes.pts = (payload[9] & 0x0E) << 27 | (payload[10] & 0xFF) << 20 | (payload[11] & 0xFE) << 12 | (payload[12] & 0xFF) << 5 | (payload[13] & 0xFE) >>> 3;\n        pes.pts *= 4; // Left shift by 2\n\n        pes.pts += (payload[13] & 0x06) >>> 1; // OR by the two LSBs\n\n        pes.dts = pes.pts;\n\n        if (ptsDtsFlags & 0x40) {\n          pes.dts = (payload[14] & 0x0E) << 27 | (payload[15] & 0xFF) << 20 | (payload[16] & 0xFE) << 12 | (payload[17] & 0xFF) << 5 | (payload[18] & 0xFE) >>> 3;\n          pes.dts *= 4; // Left shift by 2\n\n          pes.dts += (payload[18] & 0x06) >>> 1; // OR by the two LSBs\n        }\n      } // the data section starts immediately after the PES header.\n      // pes_header_data_length specifies the number of header bytes\n      // that follow the last byte of the field.\n\n\n      pes.data = payload.subarray(9 + payload[8]);\n    },\n\n    /**\n      * Pass completely parsed PES packets to the next stream in the pipeline\n     **/\n    flushStream = function flushStream(stream, type, forceFlush) {\n      var packetData = new Uint8Array(stream.size),\n          event = {\n        type: type\n      },\n          i = 0,\n          offset = 0,\n          packetFlushable = false,\n          fragment; // do nothing if there is not enough buffered data for a complete\n      // PES header\n\n      if (!stream.data.length || stream.size < 9) {\n        return;\n      }\n\n      event.trackId = stream.data[0].pid; // reassemble the packet\n\n      for (i = 0; i < stream.data.length; i++) {\n        fragment = stream.data[i];\n        packetData.set(fragment.data, offset);\n        offset += fragment.data.byteLength;\n      } // parse assembled packet's PES header\n\n\n      parsePes(packetData, event); // non-video PES packets MUST have a non-zero PES_packet_length\n      // check that there is enough stream data to fill the packet\n\n      packetFlushable = type === 'video' || event.packetLength <= stream.size; // flush pending packets if the conditions are right\n\n      if (forceFlush || packetFlushable) {\n        stream.size = 0;\n        stream.data.length = 0;\n      } // only emit packets that are complete. this is to avoid assembling\n      // incomplete PES packets due to poor segmentation\n\n\n      if (packetFlushable) {\n        self.trigger('data', event);\n      }\n    };\n\n    _ElementaryStream.prototype.init.call(this);\n    /**\n     * Identifies M2TS packet types and parses PES packets using metadata\n     * parsed from the PMT\n     **/\n\n\n    this.push = function (data) {\n      ({\n        pat: function pat() {// we have to wait for the PMT to arrive as well before we\n          // have any meaningful metadata\n        },\n        pes: function pes() {\n          var stream, streamType;\n\n          switch (data.streamType) {\n            case streamTypes.H264_STREAM_TYPE:\n              stream = video;\n              streamType = 'video';\n              break;\n\n            case streamTypes.ADTS_STREAM_TYPE:\n              stream = audio;\n              streamType = 'audio';\n              break;\n\n            case streamTypes.METADATA_STREAM_TYPE:\n              stream = timedMetadata;\n              streamType = 'timed-metadata';\n              break;\n\n            default:\n              // ignore unknown stream types\n              return;\n          } // if a new packet is starting, we can flush the completed\n          // packet\n\n\n          if (data.payloadUnitStartIndicator) {\n            flushStream(stream, streamType, true);\n          } // buffer this fragment until we are sure we've received the\n          // complete payload\n\n\n          stream.data.push(data);\n          stream.size += data.data.byteLength;\n        },\n        pmt: function pmt() {\n          var event = {\n            type: 'metadata',\n            tracks: []\n          };\n          programMapTable = data.programMapTable; // translate audio and video streams to tracks\n\n          if (programMapTable.video !== null) {\n            event.tracks.push({\n              timelineStartInfo: {\n                baseMediaDecodeTime: 0\n              },\n              id: +programMapTable.video,\n              codec: 'avc',\n              type: 'video'\n            });\n          }\n\n          if (programMapTable.audio !== null) {\n            event.tracks.push({\n              timelineStartInfo: {\n                baseMediaDecodeTime: 0\n              },\n              id: +programMapTable.audio,\n              codec: 'adts',\n              type: 'audio'\n            });\n          }\n\n          segmentHadPmt = true;\n          self.trigger('data', event);\n        }\n      })[data.type]();\n    };\n\n    this.reset = function () {\n      video.size = 0;\n      video.data.length = 0;\n      audio.size = 0;\n      audio.data.length = 0;\n      this.trigger('reset');\n    };\n    /**\n     * Flush any remaining input. Video PES packets may be of variable\n     * length. Normally, the start of a new video packet can trigger the\n     * finalization of the previous packet. That is not possible if no\n     * more video is forthcoming, however. In that case, some other\n     * mechanism (like the end of the file) has to be employed. When it is\n     * clear that no additional data is forthcoming, calling this method\n     * will flush the buffered packets.\n     */\n\n\n    this.flushStreams_ = function () {\n      // !!THIS ORDER IS IMPORTANT!!\n      // video first then audio\n      flushStream(video, 'video');\n      flushStream(audio, 'audio');\n      flushStream(timedMetadata, 'timed-metadata');\n    };\n\n    this.flush = function () {\n      // if on flush we haven't had a pmt emitted\n      // and we have a pmt to emit. emit the pmt\n      // so that we trigger a trackinfo downstream.\n      if (!segmentHadPmt && programMapTable) {\n        var pmt = {\n          type: 'metadata',\n          tracks: []\n        }; // translate audio and video streams to tracks\n\n        if (programMapTable.video !== null) {\n          pmt.tracks.push({\n            timelineStartInfo: {\n              baseMediaDecodeTime: 0\n            },\n            id: +programMapTable.video,\n            codec: 'avc',\n            type: 'video'\n          });\n        }\n\n        if (programMapTable.audio !== null) {\n          pmt.tracks.push({\n            timelineStartInfo: {\n              baseMediaDecodeTime: 0\n            },\n            id: +programMapTable.audio,\n            codec: 'adts',\n            type: 'audio'\n          });\n        }\n\n        self.trigger('data', pmt);\n      }\n\n      segmentHadPmt = false;\n      this.flushStreams_();\n      this.trigger('done');\n    };\n  };\n\n  _ElementaryStream.prototype = new stream();\n  var m2ts$1 = {\n    PAT_PID: 0x0000,\n    MP2T_PACKET_LENGTH: MP2T_PACKET_LENGTH$1,\n    TransportPacketStream: _TransportPacketStream,\n    TransportParseStream: _TransportParseStream,\n    ElementaryStream: _ElementaryStream,\n    TimestampRolloverStream: TimestampRolloverStream,\n    CaptionStream: captionStream.CaptionStream,\n    Cea608Stream: captionStream.Cea608Stream,\n    Cea708Stream: captionStream.Cea708Stream,\n    MetadataStream: metadataStream\n  };\n\n  for (var type in streamTypes) {\n    if (streamTypes.hasOwnProperty(type)) {\n      m2ts$1[type] = streamTypes[type];\n    }\n  }\n\n  var m2ts_1 = m2ts$1;\n\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   *\n   * Utilities to detect basic properties and metadata about Aac data.\n   */\n\n  var ADTS_SAMPLING_FREQUENCIES = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n\n  var parseId3TagSize = function parseId3TagSize(header, byteIndex) {\n    var returnSize = header[byteIndex + 6] << 21 | header[byteIndex + 7] << 14 | header[byteIndex + 8] << 7 | header[byteIndex + 9],\n        flags = header[byteIndex + 5],\n        footerPresent = (flags & 16) >> 4; // if we get a negative returnSize clamp it to 0\n\n    returnSize = returnSize >= 0 ? returnSize : 0;\n\n    if (footerPresent) {\n      return returnSize + 20;\n    }\n\n    return returnSize + 10;\n  };\n\n  var getId3Offset = function getId3Offset(data, offset) {\n    if (data.length - offset < 10 || data[offset] !== 'I'.charCodeAt(0) || data[offset + 1] !== 'D'.charCodeAt(0) || data[offset + 2] !== '3'.charCodeAt(0)) {\n      return offset;\n    }\n\n    offset += parseId3TagSize(data, offset);\n    return getId3Offset(data, offset);\n  }; // TODO: use vhs-utils\n\n\n  var isLikelyAacData$2 = function isLikelyAacData(data) {\n    var offset = getId3Offset(data, 0);\n    return data.length >= offset + 2 && (data[offset] & 0xFF) === 0xFF && (data[offset + 1] & 0xF0) === 0xF0 && // verify that the 2 layer bits are 0, aka this\n    // is not mp3 data but aac data.\n    (data[offset + 1] & 0x16) === 0x10;\n  };\n\n  var parseSyncSafeInteger = function parseSyncSafeInteger(data) {\n    return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];\n  }; // return a percent-encoded representation of the specified byte range\n  // @see http://en.wikipedia.org/wiki/Percent-encoding\n\n\n  var percentEncode = function percentEncode(bytes, start, end) {\n    var i,\n        result = '';\n\n    for (i = start; i < end; i++) {\n      result += '%' + ('00' + bytes[i].toString(16)).slice(-2);\n    }\n\n    return result;\n  }; // return the string representation of the specified byte range,\n  // interpreted as ISO-8859-1.\n\n\n  var parseIso88591 = function parseIso88591(bytes, start, end) {\n    return unescape(percentEncode(bytes, start, end)); // jshint ignore:line\n  };\n\n  var parseAdtsSize = function parseAdtsSize(header, byteIndex) {\n    var lowThree = (header[byteIndex + 5] & 0xE0) >> 5,\n        middle = header[byteIndex + 4] << 3,\n        highTwo = header[byteIndex + 3] & 0x3 << 11;\n    return highTwo | middle | lowThree;\n  };\n\n  var parseType$1 = function parseType(header, byteIndex) {\n    if (header[byteIndex] === 'I'.charCodeAt(0) && header[byteIndex + 1] === 'D'.charCodeAt(0) && header[byteIndex + 2] === '3'.charCodeAt(0)) {\n      return 'timed-metadata';\n    } else if (header[byteIndex] & 0xff === 0xff && (header[byteIndex + 1] & 0xf0) === 0xf0) {\n      return 'audio';\n    }\n\n    return null;\n  };\n\n  var parseSampleRate = function parseSampleRate(packet) {\n    var i = 0;\n\n    while (i + 5 < packet.length) {\n      if (packet[i] !== 0xFF || (packet[i + 1] & 0xF6) !== 0xF0) {\n        // If a valid header was not found,  jump one forward and attempt to\n        // find a valid ADTS header starting at the next byte\n        i++;\n        continue;\n      }\n\n      return ADTS_SAMPLING_FREQUENCIES[(packet[i + 2] & 0x3c) >>> 2];\n    }\n\n    return null;\n  };\n\n  var parseAacTimestamp = function parseAacTimestamp(packet) {\n    var frameStart, frameSize, frame, frameHeader; // find the start of the first frame and the end of the tag\n\n    frameStart = 10;\n\n    if (packet[5] & 0x40) {\n      // advance the frame start past the extended header\n      frameStart += 4; // header size field\n\n      frameStart += parseSyncSafeInteger(packet.subarray(10, 14));\n    } // parse one or more ID3 frames\n    // http://id3.org/id3v2.3.0#ID3v2_frame_overview\n\n\n    do {\n      // determine the number of bytes in this frame\n      frameSize = parseSyncSafeInteger(packet.subarray(frameStart + 4, frameStart + 8));\n\n      if (frameSize < 1) {\n        return null;\n      }\n\n      frameHeader = String.fromCharCode(packet[frameStart], packet[frameStart + 1], packet[frameStart + 2], packet[frameStart + 3]);\n\n      if (frameHeader === 'PRIV') {\n        frame = packet.subarray(frameStart + 10, frameStart + frameSize + 10);\n\n        for (var i = 0; i < frame.byteLength; i++) {\n          if (frame[i] === 0) {\n            var owner = parseIso88591(frame, 0, i);\n\n            if (owner === 'com.apple.streaming.transportStreamTimestamp') {\n              var d = frame.subarray(i + 1);\n              var size = (d[3] & 0x01) << 30 | d[4] << 22 | d[5] << 14 | d[6] << 6 | d[7] >>> 2;\n              size *= 4;\n              size += d[7] & 0x03;\n              return size;\n            }\n\n            break;\n          }\n        }\n      }\n\n      frameStart += 10; // advance past the frame header\n\n      frameStart += frameSize; // advance past the frame body\n    } while (frameStart < packet.byteLength);\n\n    return null;\n  };\n\n  var utils = {\n    isLikelyAacData: isLikelyAacData$2,\n    parseId3TagSize: parseId3TagSize,\n    parseAdtsSize: parseAdtsSize,\n    parseType: parseType$1,\n    parseSampleRate: parseSampleRate,\n    parseAacTimestamp: parseAacTimestamp\n  };\n\n  var _AacStream;\n  /**\n   * Splits an incoming stream of binary data into ADTS and ID3 Frames.\n   */\n\n\n  _AacStream = function AacStream() {\n    var everything = new Uint8Array(),\n        timeStamp = 0;\n\n    _AacStream.prototype.init.call(this);\n\n    this.setTimestamp = function (timestamp) {\n      timeStamp = timestamp;\n    };\n\n    this.push = function (bytes) {\n      var frameSize = 0,\n          byteIndex = 0,\n          bytesLeft,\n          chunk,\n          packet,\n          tempLength; // If there are bytes remaining from the last segment, prepend them to the\n      // bytes that were pushed in\n\n      if (everything.length) {\n        tempLength = everything.length;\n        everything = new Uint8Array(bytes.byteLength + tempLength);\n        everything.set(everything.subarray(0, tempLength));\n        everything.set(bytes, tempLength);\n      } else {\n        everything = bytes;\n      }\n\n      while (everything.length - byteIndex >= 3) {\n        if (everything[byteIndex] === 'I'.charCodeAt(0) && everything[byteIndex + 1] === 'D'.charCodeAt(0) && everything[byteIndex + 2] === '3'.charCodeAt(0)) {\n          // Exit early because we don't have enough to parse\n          // the ID3 tag header\n          if (everything.length - byteIndex < 10) {\n            break;\n          } // check framesize\n\n\n          frameSize = utils.parseId3TagSize(everything, byteIndex); // Exit early if we don't have enough in the buffer\n          // to emit a full packet\n          // Add to byteIndex to support multiple ID3 tags in sequence\n\n          if (byteIndex + frameSize > everything.length) {\n            break;\n          }\n\n          chunk = {\n            type: 'timed-metadata',\n            data: everything.subarray(byteIndex, byteIndex + frameSize)\n          };\n          this.trigger('data', chunk);\n          byteIndex += frameSize;\n          continue;\n        } else if ((everything[byteIndex] & 0xff) === 0xff && (everything[byteIndex + 1] & 0xf0) === 0xf0) {\n          // Exit early because we don't have enough to parse\n          // the ADTS frame header\n          if (everything.length - byteIndex < 7) {\n            break;\n          }\n\n          frameSize = utils.parseAdtsSize(everything, byteIndex); // Exit early if we don't have enough in the buffer\n          // to emit a full packet\n\n          if (byteIndex + frameSize > everything.length) {\n            break;\n          }\n\n          packet = {\n            type: 'audio',\n            data: everything.subarray(byteIndex, byteIndex + frameSize),\n            pts: timeStamp,\n            dts: timeStamp\n          };\n          this.trigger('data', packet);\n          byteIndex += frameSize;\n          continue;\n        }\n\n        byteIndex++;\n      }\n\n      bytesLeft = everything.length - byteIndex;\n\n      if (bytesLeft > 0) {\n        everything = everything.subarray(byteIndex);\n      } else {\n        everything = new Uint8Array();\n      }\n    };\n\n    this.reset = function () {\n      everything = new Uint8Array();\n      this.trigger('reset');\n    };\n\n    this.endTimeline = function () {\n      everything = new Uint8Array();\n      this.trigger('endedtimeline');\n    };\n  };\n\n  _AacStream.prototype = new stream();\n  var aac = _AacStream;\n\n  // constants\n  var AUDIO_PROPERTIES = ['audioobjecttype', 'channelcount', 'samplerate', 'samplingfrequencyindex', 'samplesize'];\n  var audioProperties = AUDIO_PROPERTIES;\n\n  var VIDEO_PROPERTIES = ['width', 'height', 'profileIdc', 'levelIdc', 'profileCompatibility', 'sarRatio'];\n  var videoProperties = VIDEO_PROPERTIES;\n\n  var H264Stream$1 = h264.H264Stream;\n  var isLikelyAacData$1 = utils.isLikelyAacData;\n  var ONE_SECOND_IN_TS$2 = clock.ONE_SECOND_IN_TS; // object types\n\n  var _VideoSegmentStream$1, _AudioSegmentStream$1, _Transmuxer$1, _CoalesceStream;\n\n  var retriggerForStream = function retriggerForStream(key, event) {\n    event.stream = key;\n    this.trigger('log', event);\n  };\n\n  var addPipelineLogRetriggers = function addPipelineLogRetriggers(transmuxer, pipeline) {\n    var keys = Object.keys(pipeline);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]; // skip non-stream keys and headOfPipeline\n      // which is just a duplicate\n\n      if (key === 'headOfPipeline' || !pipeline[key].on) {\n        continue;\n      }\n\n      pipeline[key].on('log', retriggerForStream.bind(transmuxer, key));\n    }\n  };\n  /**\n   * Compare two arrays (even typed) for same-ness\n   */\n\n\n  var arrayEquals = function arrayEquals(a, b) {\n    var i;\n\n    if (a.length !== b.length) {\n      return false;\n    } // compare the value of each element in the array\n\n\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  var generateSegmentTimingInfo = function generateSegmentTimingInfo(baseMediaDecodeTime, startDts, startPts, endDts, endPts, prependedContentDuration) {\n    var ptsOffsetFromDts = startPts - startDts,\n        decodeDuration = endDts - startDts,\n        presentationDuration = endPts - startPts; // The PTS and DTS values are based on the actual stream times from the segment,\n    // however, the player time values will reflect a start from the baseMediaDecodeTime.\n    // In order to provide relevant values for the player times, base timing info on the\n    // baseMediaDecodeTime and the DTS and PTS durations of the segment.\n\n    return {\n      start: {\n        dts: baseMediaDecodeTime,\n        pts: baseMediaDecodeTime + ptsOffsetFromDts\n      },\n      end: {\n        dts: baseMediaDecodeTime + decodeDuration,\n        pts: baseMediaDecodeTime + presentationDuration\n      },\n      prependedContentDuration: prependedContentDuration,\n      baseMediaDecodeTime: baseMediaDecodeTime\n    };\n  };\n  /**\n   * Constructs a single-track, ISO BMFF media segment from AAC data\n   * events. The output of this stream can be fed to a SourceBuffer\n   * configured with a suitable initialization segment.\n   * @param track {object} track metadata configuration\n   * @param options {object} transmuxer options object\n   * @param options.keepOriginalTimestamps {boolean} If true, keep the timestamps\n   *        in the source; false to adjust the first segment to start at 0.\n   */\n\n\n  _AudioSegmentStream$1 = function AudioSegmentStream(track, options) {\n    var adtsFrames = [],\n        sequenceNumber,\n        earliestAllowedDts = 0,\n        audioAppendStartTs = 0,\n        videoBaseMediaDecodeTime = Infinity;\n    options = options || {};\n    sequenceNumber = options.firstSequenceNumber || 0;\n\n    _AudioSegmentStream$1.prototype.init.call(this);\n\n    this.push = function (data) {\n      trackDecodeInfo.collectDtsInfo(track, data);\n\n      if (track) {\n        audioProperties.forEach(function (prop) {\n          track[prop] = data[prop];\n        });\n      } // buffer audio data until end() is called\n\n\n      adtsFrames.push(data);\n    };\n\n    this.setEarliestDts = function (earliestDts) {\n      earliestAllowedDts = earliestDts;\n    };\n\n    this.setVideoBaseMediaDecodeTime = function (baseMediaDecodeTime) {\n      videoBaseMediaDecodeTime = baseMediaDecodeTime;\n    };\n\n    this.setAudioAppendStart = function (timestamp) {\n      audioAppendStartTs = timestamp;\n    };\n\n    this.flush = function () {\n      var frames, moof, mdat, boxes, frameDuration, segmentDuration, videoClockCyclesOfSilencePrefixed; // return early if no audio data has been observed\n\n      if (adtsFrames.length === 0) {\n        this.trigger('done', 'AudioSegmentStream');\n        return;\n      }\n\n      frames = audioFrameUtils.trimAdtsFramesByEarliestDts(adtsFrames, track, earliestAllowedDts);\n      track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps); // amount of audio filled but the value is in video clock rather than audio clock\n\n      videoClockCyclesOfSilencePrefixed = audioFrameUtils.prefixWithSilence(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime); // we have to build the index from byte locations to\n      // samples (that is, adts frames) in the audio data\n\n      track.samples = audioFrameUtils.generateSampleTable(frames); // concatenate the audio data to constuct the mdat\n\n      mdat = mp4Generator.mdat(audioFrameUtils.concatenateFrameData(frames));\n      adtsFrames = [];\n      moof = mp4Generator.moof(sequenceNumber, [track]);\n      boxes = new Uint8Array(moof.byteLength + mdat.byteLength); // bump the sequence number for next time\n\n      sequenceNumber++;\n      boxes.set(moof);\n      boxes.set(mdat, moof.byteLength);\n      trackDecodeInfo.clearDtsInfo(track);\n      frameDuration = Math.ceil(ONE_SECOND_IN_TS$2 * 1024 / track.samplerate); // TODO this check was added to maintain backwards compatibility (particularly with\n      // tests) on adding the timingInfo event. However, it seems unlikely that there's a\n      // valid use-case where an init segment/data should be triggered without associated\n      // frames. Leaving for now, but should be looked into.\n\n      if (frames.length) {\n        segmentDuration = frames.length * frameDuration;\n        this.trigger('segmentTimingInfo', generateSegmentTimingInfo( // The audio track's baseMediaDecodeTime is in audio clock cycles, but the\n        // frame info is in video clock cycles. Convert to match expectation of\n        // listeners (that all timestamps will be based on video clock cycles).\n        clock.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate), // frame times are already in video clock, as is segment duration\n        frames[0].dts, frames[0].pts, frames[0].dts + segmentDuration, frames[0].pts + segmentDuration, videoClockCyclesOfSilencePrefixed || 0));\n        this.trigger('timingInfo', {\n          start: frames[0].pts,\n          end: frames[0].pts + segmentDuration\n        });\n      }\n\n      this.trigger('data', {\n        track: track,\n        boxes: boxes\n      });\n      this.trigger('done', 'AudioSegmentStream');\n    };\n\n    this.reset = function () {\n      trackDecodeInfo.clearDtsInfo(track);\n      adtsFrames = [];\n      this.trigger('reset');\n    };\n  };\n\n  _AudioSegmentStream$1.prototype = new stream();\n  /**\n   * Constructs a single-track, ISO BMFF media segment from H264 data\n   * events. The output of this stream can be fed to a SourceBuffer\n   * configured with a suitable initialization segment.\n   * @param track {object} track metadata configuration\n   * @param options {object} transmuxer options object\n   * @param options.alignGopsAtEnd {boolean} If true, start from the end of the\n   *        gopsToAlignWith list when attempting to align gop pts\n   * @param options.keepOriginalTimestamps {boolean} If true, keep the timestamps\n   *        in the source; false to adjust the first segment to start at 0.\n   */\n\n  _VideoSegmentStream$1 = function VideoSegmentStream(track, options) {\n    var sequenceNumber,\n        nalUnits = [],\n        gopsToAlignWith = [],\n        config,\n        pps;\n    options = options || {};\n    sequenceNumber = options.firstSequenceNumber || 0;\n\n    _VideoSegmentStream$1.prototype.init.call(this);\n\n    delete track.minPTS;\n    this.gopCache_ = [];\n    /**\n      * Constructs a ISO BMFF segment given H264 nalUnits\n      * @param {Object} nalUnit A data event representing a nalUnit\n      * @param {String} nalUnit.nalUnitType\n      * @param {Object} nalUnit.config Properties for a mp4 track\n      * @param {Uint8Array} nalUnit.data The nalUnit bytes\n      * @see lib/codecs/h264.js\n     **/\n\n    this.push = function (nalUnit) {\n      trackDecodeInfo.collectDtsInfo(track, nalUnit); // record the track config\n\n      if (nalUnit.nalUnitType === 'seq_parameter_set_rbsp' && !config) {\n        config = nalUnit.config;\n        track.sps = [nalUnit.data];\n        videoProperties.forEach(function (prop) {\n          track[prop] = config[prop];\n        }, this);\n      }\n\n      if (nalUnit.nalUnitType === 'pic_parameter_set_rbsp' && !pps) {\n        pps = nalUnit.data;\n        track.pps = [nalUnit.data];\n      } // buffer video until flush() is called\n\n\n      nalUnits.push(nalUnit);\n    };\n    /**\n      * Pass constructed ISO BMFF track and boxes on to the\n      * next stream in the pipeline\n     **/\n\n\n    this.flush = function () {\n      var frames,\n          gopForFusion,\n          gops,\n          moof,\n          mdat,\n          boxes,\n          prependedContentDuration = 0,\n          firstGop,\n          lastGop; // Throw away nalUnits at the start of the byte stream until\n      // we find the first AUD\n\n      while (nalUnits.length) {\n        if (nalUnits[0].nalUnitType === 'access_unit_delimiter_rbsp') {\n          break;\n        }\n\n        nalUnits.shift();\n      } // Return early if no video data has been observed\n\n\n      if (nalUnits.length === 0) {\n        this.resetStream_();\n        this.trigger('done', 'VideoSegmentStream');\n        return;\n      } // Organize the raw nal-units into arrays that represent\n      // higher-level constructs such as frames and gops\n      // (group-of-pictures)\n\n\n      frames = frameUtils.groupNalsIntoFrames(nalUnits);\n      gops = frameUtils.groupFramesIntoGops(frames); // If the first frame of this fragment is not a keyframe we have\n      // a problem since MSE (on Chrome) requires a leading keyframe.\n      //\n      // We have two approaches to repairing this situation:\n      // 1) GOP-FUSION:\n      //    This is where we keep track of the GOPS (group-of-pictures)\n      //    from previous fragments and attempt to find one that we can\n      //    prepend to the current fragment in order to create a valid\n      //    fragment.\n      // 2) KEYFRAME-PULLING:\n      //    Here we search for the first keyframe in the fragment and\n      //    throw away all the frames between the start of the fragment\n      //    and that keyframe. We then extend the duration and pull the\n      //    PTS of the keyframe forward so that it covers the time range\n      //    of the frames that were disposed of.\n      //\n      // #1 is far prefereable over #2 which can cause \"stuttering\" but\n      // requires more things to be just right.\n\n      if (!gops[0][0].keyFrame) {\n        // Search for a gop for fusion from our gopCache\n        gopForFusion = this.getGopForFusion_(nalUnits[0], track);\n\n        if (gopForFusion) {\n          // in order to provide more accurate timing information about the segment, save\n          // the number of seconds prepended to the original segment due to GOP fusion\n          prependedContentDuration = gopForFusion.duration;\n          gops.unshift(gopForFusion); // Adjust Gops' metadata to account for the inclusion of the\n          // new gop at the beginning\n\n          gops.byteLength += gopForFusion.byteLength;\n          gops.nalCount += gopForFusion.nalCount;\n          gops.pts = gopForFusion.pts;\n          gops.dts = gopForFusion.dts;\n          gops.duration += gopForFusion.duration;\n        } else {\n          // If we didn't find a candidate gop fall back to keyframe-pulling\n          gops = frameUtils.extendFirstKeyFrame(gops);\n        }\n      } // Trim gops to align with gopsToAlignWith\n\n\n      if (gopsToAlignWith.length) {\n        var alignedGops;\n\n        if (options.alignGopsAtEnd) {\n          alignedGops = this.alignGopsAtEnd_(gops);\n        } else {\n          alignedGops = this.alignGopsAtStart_(gops);\n        }\n\n        if (!alignedGops) {\n          // save all the nals in the last GOP into the gop cache\n          this.gopCache_.unshift({\n            gop: gops.pop(),\n            pps: track.pps,\n            sps: track.sps\n          }); // Keep a maximum of 6 GOPs in the cache\n\n          this.gopCache_.length = Math.min(6, this.gopCache_.length); // Clear nalUnits\n\n          nalUnits = []; // return early no gops can be aligned with desired gopsToAlignWith\n\n          this.resetStream_();\n          this.trigger('done', 'VideoSegmentStream');\n          return;\n        } // Some gops were trimmed. clear dts info so minSegmentDts and pts are correct\n        // when recalculated before sending off to CoalesceStream\n\n\n        trackDecodeInfo.clearDtsInfo(track);\n        gops = alignedGops;\n      }\n\n      trackDecodeInfo.collectDtsInfo(track, gops); // First, we have to build the index from byte locations to\n      // samples (that is, frames) in the video data\n\n      track.samples = frameUtils.generateSampleTable(gops); // Concatenate the video data and construct the mdat\n\n      mdat = mp4Generator.mdat(frameUtils.concatenateNalData(gops));\n      track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);\n      this.trigger('processedGopsInfo', gops.map(function (gop) {\n        return {\n          pts: gop.pts,\n          dts: gop.dts,\n          byteLength: gop.byteLength\n        };\n      }));\n      firstGop = gops[0];\n      lastGop = gops[gops.length - 1];\n      this.trigger('segmentTimingInfo', generateSegmentTimingInfo(track.baseMediaDecodeTime, firstGop.dts, firstGop.pts, lastGop.dts + lastGop.duration, lastGop.pts + lastGop.duration, prependedContentDuration));\n      this.trigger('timingInfo', {\n        start: gops[0].pts,\n        end: gops[gops.length - 1].pts + gops[gops.length - 1].duration\n      }); // save all the nals in the last GOP into the gop cache\n\n      this.gopCache_.unshift({\n        gop: gops.pop(),\n        pps: track.pps,\n        sps: track.sps\n      }); // Keep a maximum of 6 GOPs in the cache\n\n      this.gopCache_.length = Math.min(6, this.gopCache_.length); // Clear nalUnits\n\n      nalUnits = [];\n      this.trigger('baseMediaDecodeTime', track.baseMediaDecodeTime);\n      this.trigger('timelineStartInfo', track.timelineStartInfo);\n      moof = mp4Generator.moof(sequenceNumber, [track]); // it would be great to allocate this array up front instead of\n      // throwing away hundreds of media segment fragments\n\n      boxes = new Uint8Array(moof.byteLength + mdat.byteLength); // Bump the sequence number for next time\n\n      sequenceNumber++;\n      boxes.set(moof);\n      boxes.set(mdat, moof.byteLength);\n      this.trigger('data', {\n        track: track,\n        boxes: boxes\n      });\n      this.resetStream_(); // Continue with the flush process now\n\n      this.trigger('done', 'VideoSegmentStream');\n    };\n\n    this.reset = function () {\n      this.resetStream_();\n      nalUnits = [];\n      this.gopCache_.length = 0;\n      gopsToAlignWith.length = 0;\n      this.trigger('reset');\n    };\n\n    this.resetStream_ = function () {\n      trackDecodeInfo.clearDtsInfo(track); // reset config and pps because they may differ across segments\n      // for instance, when we are rendition switching\n\n      config = undefined;\n      pps = undefined;\n    }; // Search for a candidate Gop for gop-fusion from the gop cache and\n    // return it or return null if no good candidate was found\n\n\n    this.getGopForFusion_ = function (nalUnit) {\n      var halfSecond = 45000,\n          // Half-a-second in a 90khz clock\n      allowableOverlap = 10000,\n          // About 3 frames @ 30fps\n      nearestDistance = Infinity,\n          dtsDistance,\n          nearestGopObj,\n          currentGop,\n          currentGopObj,\n          i; // Search for the GOP nearest to the beginning of this nal unit\n\n      for (i = 0; i < this.gopCache_.length; i++) {\n        currentGopObj = this.gopCache_[i];\n        currentGop = currentGopObj.gop; // Reject Gops with different SPS or PPS\n\n        if (!(track.pps && arrayEquals(track.pps[0], currentGopObj.pps[0])) || !(track.sps && arrayEquals(track.sps[0], currentGopObj.sps[0]))) {\n          continue;\n        } // Reject Gops that would require a negative baseMediaDecodeTime\n\n\n        if (currentGop.dts < track.timelineStartInfo.dts) {\n          continue;\n        } // The distance between the end of the gop and the start of the nalUnit\n\n\n        dtsDistance = nalUnit.dts - currentGop.dts - currentGop.duration; // Only consider GOPS that start before the nal unit and end within\n        // a half-second of the nal unit\n\n        if (dtsDistance >= -allowableOverlap && dtsDistance <= halfSecond) {\n          // Always use the closest GOP we found if there is more than\n          // one candidate\n          if (!nearestGopObj || nearestDistance > dtsDistance) {\n            nearestGopObj = currentGopObj;\n            nearestDistance = dtsDistance;\n          }\n        }\n      }\n\n      if (nearestGopObj) {\n        return nearestGopObj.gop;\n      }\n\n      return null;\n    }; // trim gop list to the first gop found that has a matching pts with a gop in the list\n    // of gopsToAlignWith starting from the START of the list\n\n\n    this.alignGopsAtStart_ = function (gops) {\n      var alignIndex, gopIndex, align, gop, byteLength, nalCount, duration, alignedGops;\n      byteLength = gops.byteLength;\n      nalCount = gops.nalCount;\n      duration = gops.duration;\n      alignIndex = gopIndex = 0;\n\n      while (alignIndex < gopsToAlignWith.length && gopIndex < gops.length) {\n        align = gopsToAlignWith[alignIndex];\n        gop = gops[gopIndex];\n\n        if (align.pts === gop.pts) {\n          break;\n        }\n\n        if (gop.pts > align.pts) {\n          // this current gop starts after the current gop we want to align on, so increment\n          // align index\n          alignIndex++;\n          continue;\n        } // current gop starts before the current gop we want to align on. so increment gop\n        // index\n\n\n        gopIndex++;\n        byteLength -= gop.byteLength;\n        nalCount -= gop.nalCount;\n        duration -= gop.duration;\n      }\n\n      if (gopIndex === 0) {\n        // no gops to trim\n        return gops;\n      }\n\n      if (gopIndex === gops.length) {\n        // all gops trimmed, skip appending all gops\n        return null;\n      }\n\n      alignedGops = gops.slice(gopIndex);\n      alignedGops.byteLength = byteLength;\n      alignedGops.duration = duration;\n      alignedGops.nalCount = nalCount;\n      alignedGops.pts = alignedGops[0].pts;\n      alignedGops.dts = alignedGops[0].dts;\n      return alignedGops;\n    }; // trim gop list to the first gop found that has a matching pts with a gop in the list\n    // of gopsToAlignWith starting from the END of the list\n\n\n    this.alignGopsAtEnd_ = function (gops) {\n      var alignIndex, gopIndex, align, gop, alignEndIndex, matchFound;\n      alignIndex = gopsToAlignWith.length - 1;\n      gopIndex = gops.length - 1;\n      alignEndIndex = null;\n      matchFound = false;\n\n      while (alignIndex >= 0 && gopIndex >= 0) {\n        align = gopsToAlignWith[alignIndex];\n        gop = gops[gopIndex];\n\n        if (align.pts === gop.pts) {\n          matchFound = true;\n          break;\n        }\n\n        if (align.pts > gop.pts) {\n          alignIndex--;\n          continue;\n        }\n\n        if (alignIndex === gopsToAlignWith.length - 1) {\n          // gop.pts is greater than the last alignment candidate. If no match is found\n          // by the end of this loop, we still want to append gops that come after this\n          // point\n          alignEndIndex = gopIndex;\n        }\n\n        gopIndex--;\n      }\n\n      if (!matchFound && alignEndIndex === null) {\n        return null;\n      }\n\n      var trimIndex;\n\n      if (matchFound) {\n        trimIndex = gopIndex;\n      } else {\n        trimIndex = alignEndIndex;\n      }\n\n      if (trimIndex === 0) {\n        return gops;\n      }\n\n      var alignedGops = gops.slice(trimIndex);\n      var metadata = alignedGops.reduce(function (total, gop) {\n        total.byteLength += gop.byteLength;\n        total.duration += gop.duration;\n        total.nalCount += gop.nalCount;\n        return total;\n      }, {\n        byteLength: 0,\n        duration: 0,\n        nalCount: 0\n      });\n      alignedGops.byteLength = metadata.byteLength;\n      alignedGops.duration = metadata.duration;\n      alignedGops.nalCount = metadata.nalCount;\n      alignedGops.pts = alignedGops[0].pts;\n      alignedGops.dts = alignedGops[0].dts;\n      return alignedGops;\n    };\n\n    this.alignGopsWith = function (newGopsToAlignWith) {\n      gopsToAlignWith = newGopsToAlignWith;\n    };\n  };\n\n  _VideoSegmentStream$1.prototype = new stream();\n  /**\n   * A Stream that can combine multiple streams (ie. audio & video)\n   * into a single output segment for MSE. Also supports audio-only\n   * and video-only streams.\n   * @param options {object} transmuxer options object\n   * @param options.keepOriginalTimestamps {boolean} If true, keep the timestamps\n   *        in the source; false to adjust the first segment to start at media timeline start.\n   */\n\n  _CoalesceStream = function CoalesceStream(options, metadataStream) {\n    // Number of Tracks per output segment\n    // If greater than 1, we combine multiple\n    // tracks into a single segment\n    this.numberOfTracks = 0;\n    this.metadataStream = metadataStream;\n    options = options || {};\n\n    if (typeof options.remux !== 'undefined') {\n      this.remuxTracks = !!options.remux;\n    } else {\n      this.remuxTracks = true;\n    }\n\n    if (typeof options.keepOriginalTimestamps === 'boolean') {\n      this.keepOriginalTimestamps = options.keepOriginalTimestamps;\n    } else {\n      this.keepOriginalTimestamps = false;\n    }\n\n    this.pendingTracks = [];\n    this.videoTrack = null;\n    this.pendingBoxes = [];\n    this.pendingCaptions = [];\n    this.pendingMetadata = [];\n    this.pendingBytes = 0;\n    this.emittedTracks = 0;\n\n    _CoalesceStream.prototype.init.call(this); // Take output from multiple\n\n\n    this.push = function (output) {\n      // buffer incoming captions until the associated video segment\n      // finishes\n      if (output.text) {\n        return this.pendingCaptions.push(output);\n      } // buffer incoming id3 tags until the final flush\n\n\n      if (output.frames) {\n        return this.pendingMetadata.push(output);\n      } // Add this track to the list of pending tracks and store\n      // important information required for the construction of\n      // the final segment\n\n\n      this.pendingTracks.push(output.track);\n      this.pendingBytes += output.boxes.byteLength; // TODO: is there an issue for this against chrome?\n      // We unshift audio and push video because\n      // as of Chrome 75 when switching from\n      // one init segment to another if the video\n      // mdat does not appear after the audio mdat\n      // only audio will play for the duration of our transmux.\n\n      if (output.track.type === 'video') {\n        this.videoTrack = output.track;\n        this.pendingBoxes.push(output.boxes);\n      }\n\n      if (output.track.type === 'audio') {\n        this.audioTrack = output.track;\n        this.pendingBoxes.unshift(output.boxes);\n      }\n    };\n  };\n\n  _CoalesceStream.prototype = new stream();\n\n  _CoalesceStream.prototype.flush = function (flushSource) {\n    var offset = 0,\n        event = {\n      captions: [],\n      captionStreams: {},\n      metadata: [],\n      info: {}\n    },\n        caption,\n        id3,\n        initSegment,\n        timelineStartPts = 0,\n        i;\n\n    if (this.pendingTracks.length < this.numberOfTracks) {\n      if (flushSource !== 'VideoSegmentStream' && flushSource !== 'AudioSegmentStream') {\n        // Return because we haven't received a flush from a data-generating\n        // portion of the segment (meaning that we have only recieved meta-data\n        // or captions.)\n        return;\n      } else if (this.remuxTracks) {\n        // Return until we have enough tracks from the pipeline to remux (if we\n        // are remuxing audio and video into a single MP4)\n        return;\n      } else if (this.pendingTracks.length === 0) {\n        // In the case where we receive a flush without any data having been\n        // received we consider it an emitted track for the purposes of coalescing\n        // `done` events.\n        // We do this for the case where there is an audio and video track in the\n        // segment but no audio data. (seen in several playlists with alternate\n        // audio tracks and no audio present in the main TS segments.)\n        this.emittedTracks++;\n\n        if (this.emittedTracks >= this.numberOfTracks) {\n          this.trigger('done');\n          this.emittedTracks = 0;\n        }\n\n        return;\n      }\n    }\n\n    if (this.videoTrack) {\n      timelineStartPts = this.videoTrack.timelineStartInfo.pts;\n      videoProperties.forEach(function (prop) {\n        event.info[prop] = this.videoTrack[prop];\n      }, this);\n    } else if (this.audioTrack) {\n      timelineStartPts = this.audioTrack.timelineStartInfo.pts;\n      audioProperties.forEach(function (prop) {\n        event.info[prop] = this.audioTrack[prop];\n      }, this);\n    }\n\n    if (this.videoTrack || this.audioTrack) {\n      if (this.pendingTracks.length === 1) {\n        event.type = this.pendingTracks[0].type;\n      } else {\n        event.type = 'combined';\n      }\n\n      this.emittedTracks += this.pendingTracks.length;\n      initSegment = mp4Generator.initSegment(this.pendingTracks); // Create a new typed array to hold the init segment\n\n      event.initSegment = new Uint8Array(initSegment.byteLength); // Create an init segment containing a moov\n      // and track definitions\n\n      event.initSegment.set(initSegment); // Create a new typed array to hold the moof+mdats\n\n      event.data = new Uint8Array(this.pendingBytes); // Append each moof+mdat (one per track) together\n\n      for (i = 0; i < this.pendingBoxes.length; i++) {\n        event.data.set(this.pendingBoxes[i], offset);\n        offset += this.pendingBoxes[i].byteLength;\n      } // Translate caption PTS times into second offsets to match the\n      // video timeline for the segment, and add track info\n\n\n      for (i = 0; i < this.pendingCaptions.length; i++) {\n        caption = this.pendingCaptions[i];\n        caption.startTime = clock.metadataTsToSeconds(caption.startPts, timelineStartPts, this.keepOriginalTimestamps);\n        caption.endTime = clock.metadataTsToSeconds(caption.endPts, timelineStartPts, this.keepOriginalTimestamps);\n        event.captionStreams[caption.stream] = true;\n        event.captions.push(caption);\n      } // Translate ID3 frame PTS times into second offsets to match the\n      // video timeline for the segment\n\n\n      for (i = 0; i < this.pendingMetadata.length; i++) {\n        id3 = this.pendingMetadata[i];\n        id3.cueTime = clock.metadataTsToSeconds(id3.pts, timelineStartPts, this.keepOriginalTimestamps);\n        event.metadata.push(id3);\n      } // We add this to every single emitted segment even though we only need\n      // it for the first\n\n\n      event.metadata.dispatchType = this.metadataStream.dispatchType; // Reset stream state\n\n      this.pendingTracks.length = 0;\n      this.videoTrack = null;\n      this.pendingBoxes.length = 0;\n      this.pendingCaptions.length = 0;\n      this.pendingBytes = 0;\n      this.pendingMetadata.length = 0; // Emit the built segment\n      // We include captions and ID3 tags for backwards compatibility,\n      // ideally we should send only video and audio in the data event\n\n      this.trigger('data', event); // Emit each caption to the outside world\n      // Ideally, this would happen immediately on parsing captions,\n      // but we need to ensure that video data is sent back first\n      // so that caption timing can be adjusted to match video timing\n\n      for (i = 0; i < event.captions.length; i++) {\n        caption = event.captions[i];\n        this.trigger('caption', caption);\n      } // Emit each id3 tag to the outside world\n      // Ideally, this would happen immediately on parsing the tag,\n      // but we need to ensure that video data is sent back first\n      // so that ID3 frame timing can be adjusted to match video timing\n\n\n      for (i = 0; i < event.metadata.length; i++) {\n        id3 = event.metadata[i];\n        this.trigger('id3Frame', id3);\n      }\n    } // Only emit `done` if all tracks have been flushed and emitted\n\n\n    if (this.emittedTracks >= this.numberOfTracks) {\n      this.trigger('done');\n      this.emittedTracks = 0;\n    }\n  };\n\n  _CoalesceStream.prototype.setRemux = function (val) {\n    this.remuxTracks = val;\n  };\n  /**\n   * A Stream that expects MP2T binary data as input and produces\n   * corresponding media segments, suitable for use with Media Source\n   * Extension (MSE) implementations that support the ISO BMFF byte\n   * stream format, like Chrome.\n   */\n\n\n  _Transmuxer$1 = function Transmuxer(options) {\n    var self = this,\n        hasFlushed = true,\n        videoTrack,\n        audioTrack;\n\n    _Transmuxer$1.prototype.init.call(this);\n\n    options = options || {};\n    this.baseMediaDecodeTime = options.baseMediaDecodeTime || 0;\n    this.transmuxPipeline_ = {};\n\n    this.setupAacPipeline = function () {\n      var pipeline = {};\n      this.transmuxPipeline_ = pipeline;\n      pipeline.type = 'aac';\n      pipeline.metadataStream = new m2ts_1.MetadataStream(); // set up the parsing pipeline\n\n      pipeline.aacStream = new aac();\n      pipeline.audioTimestampRolloverStream = new m2ts_1.TimestampRolloverStream('audio');\n      pipeline.timedMetadataTimestampRolloverStream = new m2ts_1.TimestampRolloverStream('timed-metadata');\n      pipeline.adtsStream = new adts();\n      pipeline.coalesceStream = new _CoalesceStream(options, pipeline.metadataStream);\n      pipeline.headOfPipeline = pipeline.aacStream;\n      pipeline.aacStream.pipe(pipeline.audioTimestampRolloverStream).pipe(pipeline.adtsStream);\n      pipeline.aacStream.pipe(pipeline.timedMetadataTimestampRolloverStream).pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream);\n      pipeline.metadataStream.on('timestamp', function (frame) {\n        pipeline.aacStream.setTimestamp(frame.timeStamp);\n      });\n      pipeline.aacStream.on('data', function (data) {\n        if (data.type !== 'timed-metadata' && data.type !== 'audio' || pipeline.audioSegmentStream) {\n          return;\n        }\n\n        audioTrack = audioTrack || {\n          timelineStartInfo: {\n            baseMediaDecodeTime: self.baseMediaDecodeTime\n          },\n          codec: 'adts',\n          type: 'audio'\n        }; // hook up the audio segment stream to the first track with aac data\n\n        pipeline.coalesceStream.numberOfTracks++;\n        pipeline.audioSegmentStream = new _AudioSegmentStream$1(audioTrack, options);\n        pipeline.audioSegmentStream.on('log', self.getLogTrigger_('audioSegmentStream'));\n        pipeline.audioSegmentStream.on('timingInfo', self.trigger.bind(self, 'audioTimingInfo')); // Set up the final part of the audio pipeline\n\n        pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream); // emit pmt info\n\n        self.trigger('trackinfo', {\n          hasAudio: !!audioTrack,\n          hasVideo: !!videoTrack\n        });\n      }); // Re-emit any data coming from the coalesce stream to the outside world\n\n      pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data')); // Let the consumer know we have finished flushing the entire pipeline\n\n      pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));\n      addPipelineLogRetriggers(this, pipeline);\n    };\n\n    this.setupTsPipeline = function () {\n      var pipeline = {};\n      this.transmuxPipeline_ = pipeline;\n      pipeline.type = 'ts';\n      pipeline.metadataStream = new m2ts_1.MetadataStream(); // set up the parsing pipeline\n\n      pipeline.packetStream = new m2ts_1.TransportPacketStream();\n      pipeline.parseStream = new m2ts_1.TransportParseStream();\n      pipeline.elementaryStream = new m2ts_1.ElementaryStream();\n      pipeline.timestampRolloverStream = new m2ts_1.TimestampRolloverStream();\n      pipeline.adtsStream = new adts();\n      pipeline.h264Stream = new H264Stream$1();\n      pipeline.captionStream = new m2ts_1.CaptionStream(options);\n      pipeline.coalesceStream = new _CoalesceStream(options, pipeline.metadataStream);\n      pipeline.headOfPipeline = pipeline.packetStream; // disassemble MPEG2-TS packets into elementary streams\n\n      pipeline.packetStream.pipe(pipeline.parseStream).pipe(pipeline.elementaryStream).pipe(pipeline.timestampRolloverStream); // !!THIS ORDER IS IMPORTANT!!\n      // demux the streams\n\n      pipeline.timestampRolloverStream.pipe(pipeline.h264Stream);\n      pipeline.timestampRolloverStream.pipe(pipeline.adtsStream);\n      pipeline.timestampRolloverStream.pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream); // Hook up CEA-608/708 caption stream\n\n      pipeline.h264Stream.pipe(pipeline.captionStream).pipe(pipeline.coalesceStream);\n      pipeline.elementaryStream.on('data', function (data) {\n        var i;\n\n        if (data.type === 'metadata') {\n          i = data.tracks.length; // scan the tracks listed in the metadata\n\n          while (i--) {\n            if (!videoTrack && data.tracks[i].type === 'video') {\n              videoTrack = data.tracks[i];\n              videoTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;\n            } else if (!audioTrack && data.tracks[i].type === 'audio') {\n              audioTrack = data.tracks[i];\n              audioTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;\n            }\n          } // hook up the video segment stream to the first track with h264 data\n\n\n          if (videoTrack && !pipeline.videoSegmentStream) {\n            pipeline.coalesceStream.numberOfTracks++;\n            pipeline.videoSegmentStream = new _VideoSegmentStream$1(videoTrack, options);\n            pipeline.videoSegmentStream.on('log', self.getLogTrigger_('videoSegmentStream'));\n            pipeline.videoSegmentStream.on('timelineStartInfo', function (timelineStartInfo) {\n              // When video emits timelineStartInfo data after a flush, we forward that\n              // info to the AudioSegmentStream, if it exists, because video timeline\n              // data takes precedence.  Do not do this if keepOriginalTimestamps is set,\n              // because this is a particularly subtle form of timestamp alteration.\n              if (audioTrack && !options.keepOriginalTimestamps) {\n                audioTrack.timelineStartInfo = timelineStartInfo; // On the first segment we trim AAC frames that exist before the\n                // very earliest DTS we have seen in video because Chrome will\n                // interpret any video track with a baseMediaDecodeTime that is\n                // non-zero as a gap.\n\n                pipeline.audioSegmentStream.setEarliestDts(timelineStartInfo.dts - self.baseMediaDecodeTime);\n              }\n            });\n            pipeline.videoSegmentStream.on('processedGopsInfo', self.trigger.bind(self, 'gopInfo'));\n            pipeline.videoSegmentStream.on('segmentTimingInfo', self.trigger.bind(self, 'videoSegmentTimingInfo'));\n            pipeline.videoSegmentStream.on('baseMediaDecodeTime', function (baseMediaDecodeTime) {\n              if (audioTrack) {\n                pipeline.audioSegmentStream.setVideoBaseMediaDecodeTime(baseMediaDecodeTime);\n              }\n            });\n            pipeline.videoSegmentStream.on('timingInfo', self.trigger.bind(self, 'videoTimingInfo')); // Set up the final part of the video pipeline\n\n            pipeline.h264Stream.pipe(pipeline.videoSegmentStream).pipe(pipeline.coalesceStream);\n          }\n\n          if (audioTrack && !pipeline.audioSegmentStream) {\n            // hook up the audio segment stream to the first track with aac data\n            pipeline.coalesceStream.numberOfTracks++;\n            pipeline.audioSegmentStream = new _AudioSegmentStream$1(audioTrack, options);\n            pipeline.audioSegmentStream.on('log', self.getLogTrigger_('audioSegmentStream'));\n            pipeline.audioSegmentStream.on('timingInfo', self.trigger.bind(self, 'audioTimingInfo'));\n            pipeline.audioSegmentStream.on('segmentTimingInfo', self.trigger.bind(self, 'audioSegmentTimingInfo')); // Set up the final part of the audio pipeline\n\n            pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream);\n          } // emit pmt info\n\n\n          self.trigger('trackinfo', {\n            hasAudio: !!audioTrack,\n            hasVideo: !!videoTrack\n          });\n        }\n      }); // Re-emit any data coming from the coalesce stream to the outside world\n\n      pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data'));\n      pipeline.coalesceStream.on('id3Frame', function (id3Frame) {\n        id3Frame.dispatchType = pipeline.metadataStream.dispatchType;\n        self.trigger('id3Frame', id3Frame);\n      });\n      pipeline.coalesceStream.on('caption', this.trigger.bind(this, 'caption')); // Let the consumer know we have finished flushing the entire pipeline\n\n      pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));\n      addPipelineLogRetriggers(this, pipeline);\n    }; // hook up the segment streams once track metadata is delivered\n\n\n    this.setBaseMediaDecodeTime = function (baseMediaDecodeTime) {\n      var pipeline = this.transmuxPipeline_;\n\n      if (!options.keepOriginalTimestamps) {\n        this.baseMediaDecodeTime = baseMediaDecodeTime;\n      }\n\n      if (audioTrack) {\n        audioTrack.timelineStartInfo.dts = undefined;\n        audioTrack.timelineStartInfo.pts = undefined;\n        trackDecodeInfo.clearDtsInfo(audioTrack);\n\n        if (pipeline.audioTimestampRolloverStream) {\n          pipeline.audioTimestampRolloverStream.discontinuity();\n        }\n      }\n\n      if (videoTrack) {\n        if (pipeline.videoSegmentStream) {\n          pipeline.videoSegmentStream.gopCache_ = [];\n        }\n\n        videoTrack.timelineStartInfo.dts = undefined;\n        videoTrack.timelineStartInfo.pts = undefined;\n        trackDecodeInfo.clearDtsInfo(videoTrack);\n        pipeline.captionStream.reset();\n      }\n\n      if (pipeline.timestampRolloverStream) {\n        pipeline.timestampRolloverStream.discontinuity();\n      }\n    };\n\n    this.setAudioAppendStart = function (timestamp) {\n      if (audioTrack) {\n        this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(timestamp);\n      }\n    };\n\n    this.setRemux = function (val) {\n      var pipeline = this.transmuxPipeline_;\n      options.remux = val;\n\n      if (pipeline && pipeline.coalesceStream) {\n        pipeline.coalesceStream.setRemux(val);\n      }\n    };\n\n    this.alignGopsWith = function (gopsToAlignWith) {\n      if (videoTrack && this.transmuxPipeline_.videoSegmentStream) {\n        this.transmuxPipeline_.videoSegmentStream.alignGopsWith(gopsToAlignWith);\n      }\n    };\n\n    this.getLogTrigger_ = function (key) {\n      var self = this;\n      return function (event) {\n        event.stream = key;\n        self.trigger('log', event);\n      };\n    }; // feed incoming data to the front of the parsing pipeline\n\n\n    this.push = function (data) {\n      if (hasFlushed) {\n        var isAac = isLikelyAacData$1(data);\n\n        if (isAac && this.transmuxPipeline_.type !== 'aac') {\n          this.setupAacPipeline();\n        } else if (!isAac && this.transmuxPipeline_.type !== 'ts') {\n          this.setupTsPipeline();\n        }\n\n        hasFlushed = false;\n      }\n\n      this.transmuxPipeline_.headOfPipeline.push(data);\n    }; // flush any buffered data\n\n\n    this.flush = function () {\n      hasFlushed = true; // Start at the top of the pipeline and flush all pending work\n\n      this.transmuxPipeline_.headOfPipeline.flush();\n    };\n\n    this.endTimeline = function () {\n      this.transmuxPipeline_.headOfPipeline.endTimeline();\n    };\n\n    this.reset = function () {\n      if (this.transmuxPipeline_.headOfPipeline) {\n        this.transmuxPipeline_.headOfPipeline.reset();\n      }\n    }; // Caption data has to be reset when seeking outside buffered range\n\n\n    this.resetCaptions = function () {\n      if (this.transmuxPipeline_.captionStream) {\n        this.transmuxPipeline_.captionStream.reset();\n      }\n    };\n  };\n\n  _Transmuxer$1.prototype = new stream();\n  var transmuxer$2 = {\n    Transmuxer: _Transmuxer$1,\n    VideoSegmentStream: _VideoSegmentStream$1,\n    AudioSegmentStream: _AudioSegmentStream$1,\n    AUDIO_PROPERTIES: audioProperties,\n    VIDEO_PROPERTIES: videoProperties,\n    // exported for testing\n    generateSegmentTimingInfo: generateSegmentTimingInfo\n  };\n\n  var discardEmulationPreventionBytes = captionPacketParser.discardEmulationPreventionBytes;\n  var CaptionStream = captionStream.CaptionStream;\n  /**\n    * Maps an offset in the mdat to a sample based on the the size of the samples.\n    * Assumes that `parseSamples` has been called first.\n    *\n    * @param {Number} offset - The offset into the mdat\n    * @param {Object[]} samples - An array of samples, parsed using `parseSamples`\n    * @return {?Object} The matching sample, or null if no match was found.\n    *\n    * @see ISO-BMFF-12/2015, Section 8.8.8\n   **/\n\n  var mapToSample = function mapToSample(offset, samples) {\n    var approximateOffset = offset;\n\n    for (var i = 0; i < samples.length; i++) {\n      var sample = samples[i];\n\n      if (approximateOffset < sample.size) {\n        return sample;\n      }\n\n      approximateOffset -= sample.size;\n    }\n\n    return null;\n  };\n  /**\n    * Finds SEI nal units contained in a Media Data Box.\n    * Assumes that `parseSamples` has been called first.\n    *\n    * @param {Uint8Array} avcStream - The bytes of the mdat\n    * @param {Object[]} samples - The samples parsed out by `parseSamples`\n    * @param {Number} trackId - The trackId of this video track\n    * @return {Object[]} seiNals - the parsed SEI NALUs found.\n    *   The contents of the seiNal should match what is expected by\n    *   CaptionStream.push (nalUnitType, size, data, escapedRBSP, pts, dts)\n    *\n    * @see ISO-BMFF-12/2015, Section 8.1.1\n    * @see Rec. ITU-T H.264, 7.3.2.3.1\n   **/\n\n\n  var findSeiNals = function findSeiNals(avcStream, samples, trackId) {\n    var avcView = new DataView(avcStream.buffer, avcStream.byteOffset, avcStream.byteLength),\n        result = {\n      logs: [],\n      seiNals: []\n    },\n        seiNal,\n        i,\n        length,\n        lastMatchedSample;\n\n    for (i = 0; i + 4 < avcStream.length; i += length) {\n      length = avcView.getUint32(i);\n      i += 4; // Bail if this doesn't appear to be an H264 stream\n\n      if (length <= 0) {\n        continue;\n      }\n\n      switch (avcStream[i] & 0x1F) {\n        case 0x06:\n          var data = avcStream.subarray(i + 1, i + 1 + length);\n          var matchingSample = mapToSample(i, samples);\n          seiNal = {\n            nalUnitType: 'sei_rbsp',\n            size: length,\n            data: data,\n            escapedRBSP: discardEmulationPreventionBytes(data),\n            trackId: trackId\n          };\n\n          if (matchingSample) {\n            seiNal.pts = matchingSample.pts;\n            seiNal.dts = matchingSample.dts;\n            lastMatchedSample = matchingSample;\n          } else if (lastMatchedSample) {\n            // If a matching sample cannot be found, use the last\n            // sample's values as they should be as close as possible\n            seiNal.pts = lastMatchedSample.pts;\n            seiNal.dts = lastMatchedSample.dts;\n          } else {\n            result.logs.push({\n              level: 'warn',\n              message: 'We\\'ve encountered a nal unit without data at ' + i + ' for trackId ' + trackId + '. See mux.js#223.'\n            });\n            break;\n          }\n\n          result.seiNals.push(seiNal);\n          break;\n      }\n    }\n\n    return result;\n  };\n  /**\n    * Parses sample information out of Track Run Boxes and calculates\n    * the absolute presentation and decode timestamps of each sample.\n    *\n    * @param {Array<Uint8Array>} truns - The Trun Run boxes to be parsed\n    * @param {Number|BigInt} baseMediaDecodeTime - base media decode time from tfdt\n        @see ISO-BMFF-12/2015, Section 8.8.12\n    * @param {Object} tfhd - The parsed Track Fragment Header\n    *   @see inspect.parseTfhd\n    * @return {Object[]} the parsed samples\n    *\n    * @see ISO-BMFF-12/2015, Section 8.8.8\n   **/\n\n\n  var parseSamples = function parseSamples(truns, baseMediaDecodeTime, tfhd) {\n    var currentDts = baseMediaDecodeTime;\n    var defaultSampleDuration = tfhd.defaultSampleDuration || 0;\n    var defaultSampleSize = tfhd.defaultSampleSize || 0;\n    var trackId = tfhd.trackId;\n    var allSamples = [];\n    truns.forEach(function (trun) {\n      // Note: We currently do not parse the sample table as well\n      // as the trun. It's possible some sources will require this.\n      // moov > trak > mdia > minf > stbl\n      var trackRun = parseTrun(trun);\n      var samples = trackRun.samples;\n      samples.forEach(function (sample) {\n        if (sample.duration === undefined) {\n          sample.duration = defaultSampleDuration;\n        }\n\n        if (sample.size === undefined) {\n          sample.size = defaultSampleSize;\n        }\n\n        sample.trackId = trackId;\n        sample.dts = currentDts;\n\n        if (sample.compositionTimeOffset === undefined) {\n          sample.compositionTimeOffset = 0;\n        }\n\n        if (typeof currentDts === 'bigint') {\n          sample.pts = currentDts + window__default['default'].BigInt(sample.compositionTimeOffset);\n          currentDts += window__default['default'].BigInt(sample.duration);\n        } else {\n          sample.pts = currentDts + sample.compositionTimeOffset;\n          currentDts += sample.duration;\n        }\n      });\n      allSamples = allSamples.concat(samples);\n    });\n    return allSamples;\n  };\n  /**\n    * Parses out caption nals from an FMP4 segment's video tracks.\n    *\n    * @param {Uint8Array} segment - The bytes of a single segment\n    * @param {Number} videoTrackId - The trackId of a video track in the segment\n    * @return {Object.<Number, Object[]>} A mapping of video trackId to\n    *   a list of seiNals found in that track\n   **/\n\n\n  var parseCaptionNals = function parseCaptionNals(segment, videoTrackId) {\n    // To get the samples\n    var trafs = findBox_1(segment, ['moof', 'traf']); // To get SEI NAL units\n\n    var mdats = findBox_1(segment, ['mdat']);\n    var captionNals = {};\n    var mdatTrafPairs = []; // Pair up each traf with a mdat as moofs and mdats are in pairs\n\n    mdats.forEach(function (mdat, index) {\n      var matchingTraf = trafs[index];\n      mdatTrafPairs.push({\n        mdat: mdat,\n        traf: matchingTraf\n      });\n    });\n    mdatTrafPairs.forEach(function (pair) {\n      var mdat = pair.mdat;\n      var traf = pair.traf;\n      var tfhd = findBox_1(traf, ['tfhd']); // Exactly 1 tfhd per traf\n\n      var headerInfo = parseTfhd(tfhd[0]);\n      var trackId = headerInfo.trackId;\n      var tfdt = findBox_1(traf, ['tfdt']); // Either 0 or 1 tfdt per traf\n\n      var baseMediaDecodeTime = tfdt.length > 0 ? parseTfdt(tfdt[0]).baseMediaDecodeTime : 0;\n      var truns = findBox_1(traf, ['trun']);\n      var samples;\n      var result; // Only parse video data for the chosen video track\n\n      if (videoTrackId === trackId && truns.length > 0) {\n        samples = parseSamples(truns, baseMediaDecodeTime, headerInfo);\n        result = findSeiNals(mdat, samples, trackId);\n\n        if (!captionNals[trackId]) {\n          captionNals[trackId] = {\n            seiNals: [],\n            logs: []\n          };\n        }\n\n        captionNals[trackId].seiNals = captionNals[trackId].seiNals.concat(result.seiNals);\n        captionNals[trackId].logs = captionNals[trackId].logs.concat(result.logs);\n      }\n    });\n    return captionNals;\n  };\n  /**\n    * Parses out inband captions from an MP4 container and returns\n    * caption objects that can be used by WebVTT and the TextTrack API.\n    * @see https://developer.mozilla.org/en-US/docs/Web/API/VTTCue\n    * @see https://developer.mozilla.org/en-US/docs/Web/API/TextTrack\n    * Assumes that `probe.getVideoTrackIds` and `probe.timescale` have been called first\n    *\n    * @param {Uint8Array} segment - The fmp4 segment containing embedded captions\n    * @param {Number} trackId - The id of the video track to parse\n    * @param {Number} timescale - The timescale for the video track from the init segment\n    *\n    * @return {?Object[]} parsedCaptions - A list of captions or null if no video tracks\n    * @return {Number} parsedCaptions[].startTime - The time to show the caption in seconds\n    * @return {Number} parsedCaptions[].endTime - The time to stop showing the caption in seconds\n    * @return {String} parsedCaptions[].text - The visible content of the caption\n   **/\n\n\n  var parseEmbeddedCaptions = function parseEmbeddedCaptions(segment, trackId, timescale) {\n    var captionNals; // the ISO-BMFF spec says that trackId can't be zero, but there's some broken content out there\n\n    if (trackId === null) {\n      return null;\n    }\n\n    captionNals = parseCaptionNals(segment, trackId);\n    var trackNals = captionNals[trackId] || {};\n    return {\n      seiNals: trackNals.seiNals,\n      logs: trackNals.logs,\n      timescale: timescale\n    };\n  };\n  /**\n    * Converts SEI NALUs into captions that can be used by video.js\n   **/\n\n\n  var CaptionParser = function CaptionParser() {\n    var isInitialized = false;\n    var captionStream; // Stores segments seen before trackId and timescale are set\n\n    var segmentCache; // Stores video track ID of the track being parsed\n\n    var trackId; // Stores the timescale of the track being parsed\n\n    var timescale; // Stores captions parsed so far\n\n    var parsedCaptions; // Stores whether we are receiving partial data or not\n\n    var parsingPartial;\n    /**\n      * A method to indicate whether a CaptionParser has been initalized\n      * @returns {Boolean}\n     **/\n\n    this.isInitialized = function () {\n      return isInitialized;\n    };\n    /**\n      * Initializes the underlying CaptionStream, SEI NAL parsing\n      * and management, and caption collection\n     **/\n\n\n    this.init = function (options) {\n      captionStream = new CaptionStream();\n      isInitialized = true;\n      parsingPartial = options ? options.isPartial : false; // Collect dispatched captions\n\n      captionStream.on('data', function (event) {\n        // Convert to seconds in the source's timescale\n        event.startTime = event.startPts / timescale;\n        event.endTime = event.endPts / timescale;\n        parsedCaptions.captions.push(event);\n        parsedCaptions.captionStreams[event.stream] = true;\n      });\n      captionStream.on('log', function (log) {\n        parsedCaptions.logs.push(log);\n      });\n    };\n    /**\n      * Determines if a new video track will be selected\n      * or if the timescale changed\n      * @return {Boolean}\n     **/\n\n\n    this.isNewInit = function (videoTrackIds, timescales) {\n      if (videoTrackIds && videoTrackIds.length === 0 || timescales && typeof timescales === 'object' && Object.keys(timescales).length === 0) {\n        return false;\n      }\n\n      return trackId !== videoTrackIds[0] || timescale !== timescales[trackId];\n    };\n    /**\n      * Parses out SEI captions and interacts with underlying\n      * CaptionStream to return dispatched captions\n      *\n      * @param {Uint8Array} segment - The fmp4 segment containing embedded captions\n      * @param {Number[]} videoTrackIds - A list of video tracks found in the init segment\n      * @param {Object.<Number, Number>} timescales - The timescales found in the init segment\n      * @see parseEmbeddedCaptions\n      * @see m2ts/caption-stream.js\n     **/\n\n\n    this.parse = function (segment, videoTrackIds, timescales) {\n      var parsedData;\n\n      if (!this.isInitialized()) {\n        return null; // This is not likely to be a video segment\n      } else if (!videoTrackIds || !timescales) {\n        return null;\n      } else if (this.isNewInit(videoTrackIds, timescales)) {\n        // Use the first video track only as there is no\n        // mechanism to switch to other video tracks\n        trackId = videoTrackIds[0];\n        timescale = timescales[trackId]; // If an init segment has not been seen yet, hold onto segment\n        // data until we have one.\n        // the ISO-BMFF spec says that trackId can't be zero, but there's some broken content out there\n      } else if (trackId === null || !timescale) {\n        segmentCache.push(segment);\n        return null;\n      } // Now that a timescale and trackId is set, parse cached segments\n\n\n      while (segmentCache.length > 0) {\n        var cachedSegment = segmentCache.shift();\n        this.parse(cachedSegment, videoTrackIds, timescales);\n      }\n\n      parsedData = parseEmbeddedCaptions(segment, trackId, timescale);\n\n      if (parsedData && parsedData.logs) {\n        parsedCaptions.logs = parsedCaptions.logs.concat(parsedData.logs);\n      }\n\n      if (parsedData === null || !parsedData.seiNals) {\n        if (parsedCaptions.logs.length) {\n          return {\n            logs: parsedCaptions.logs,\n            captions: [],\n            captionStreams: []\n          };\n        }\n\n        return null;\n      }\n\n      this.pushNals(parsedData.seiNals); // Force the parsed captions to be dispatched\n\n      this.flushStream();\n      return parsedCaptions;\n    };\n    /**\n      * Pushes SEI NALUs onto CaptionStream\n      * @param {Object[]} nals - A list of SEI nals parsed using `parseCaptionNals`\n      * Assumes that `parseCaptionNals` has been called first\n      * @see m2ts/caption-stream.js\n      **/\n\n\n    this.pushNals = function (nals) {\n      if (!this.isInitialized() || !nals || nals.length === 0) {\n        return null;\n      }\n\n      nals.forEach(function (nal) {\n        captionStream.push(nal);\n      });\n    };\n    /**\n      * Flushes underlying CaptionStream to dispatch processed, displayable captions\n      * @see m2ts/caption-stream.js\n     **/\n\n\n    this.flushStream = function () {\n      if (!this.isInitialized()) {\n        return null;\n      }\n\n      if (!parsingPartial) {\n        captionStream.flush();\n      } else {\n        captionStream.partialFlush();\n      }\n    };\n    /**\n      * Reset caption buckets for new data\n     **/\n\n\n    this.clearParsedCaptions = function () {\n      parsedCaptions.captions = [];\n      parsedCaptions.captionStreams = {};\n      parsedCaptions.logs = [];\n    };\n    /**\n      * Resets underlying CaptionStream\n      * @see m2ts/caption-stream.js\n     **/\n\n\n    this.resetCaptionStream = function () {\n      if (!this.isInitialized()) {\n        return null;\n      }\n\n      captionStream.reset();\n    };\n    /**\n      * Convenience method to clear all captions flushed from the\n      * CaptionStream and still being parsed\n      * @see m2ts/caption-stream.js\n     **/\n\n\n    this.clearAllCaptions = function () {\n      this.clearParsedCaptions();\n      this.resetCaptionStream();\n    };\n    /**\n      * Reset caption parser\n     **/\n\n\n    this.reset = function () {\n      segmentCache = [];\n      trackId = null;\n      timescale = null;\n\n      if (!parsedCaptions) {\n        parsedCaptions = {\n          captions: [],\n          // CC1, CC2, CC3, CC4\n          captionStreams: {},\n          logs: []\n        };\n      } else {\n        this.clearParsedCaptions();\n      }\n\n      this.resetCaptionStream();\n    };\n\n    this.reset();\n  };\n\n  var captionParser = CaptionParser;\n\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n\n  var mp4 = {\n    generator: mp4Generator,\n    probe: probe$2,\n    Transmuxer: transmuxer$2.Transmuxer,\n    AudioSegmentStream: transmuxer$2.AudioSegmentStream,\n    VideoSegmentStream: transmuxer$2.VideoSegmentStream,\n    CaptionParser: captionParser\n  };\n\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   *\n   * An object that stores the bytes of an FLV tag and methods for\n   * querying and manipulating that data.\n   * @see http://download.macromedia.com/f4v/video_file_format_spec_v10_1.pdf\n   */\n\n  var _FlvTag; // (type:uint, extraData:Boolean = false) extends ByteArray\n\n\n  _FlvTag = function FlvTag(type, extraData) {\n    var // Counter if this is a metadata tag, nal start marker if this is a video\n    // tag. unused if this is an audio tag\n    adHoc = 0,\n        // :uint\n    // The default size is 16kb but this is not enough to hold iframe\n    // data and the resizing algorithm costs a bit so we create a larger\n    // starting buffer for video tags\n    bufferStartSize = 16384,\n        // checks whether the FLV tag has enough capacity to accept the proposed\n    // write and re-allocates the internal buffers if necessary\n    prepareWrite = function prepareWrite(flv, count) {\n      var bytes,\n          minLength = flv.position + count;\n\n      if (minLength < flv.bytes.byteLength) {\n        // there's enough capacity so do nothing\n        return;\n      } // allocate a new buffer and copy over the data that will not be modified\n\n\n      bytes = new Uint8Array(minLength * 2);\n      bytes.set(flv.bytes.subarray(0, flv.position), 0);\n      flv.bytes = bytes;\n      flv.view = new DataView(flv.bytes.buffer);\n    },\n        // commonly used metadata properties\n    widthBytes = _FlvTag.widthBytes || new Uint8Array('width'.length),\n        heightBytes = _FlvTag.heightBytes || new Uint8Array('height'.length),\n        videocodecidBytes = _FlvTag.videocodecidBytes || new Uint8Array('videocodecid'.length),\n        i;\n\n    if (!_FlvTag.widthBytes) {\n      // calculating the bytes of common metadata names ahead of time makes the\n      // corresponding writes faster because we don't have to loop over the\n      // characters\n      // re-test with test/perf.html if you're planning on changing this\n      for (i = 0; i < 'width'.length; i++) {\n        widthBytes[i] = 'width'.charCodeAt(i);\n      }\n\n      for (i = 0; i < 'height'.length; i++) {\n        heightBytes[i] = 'height'.charCodeAt(i);\n      }\n\n      for (i = 0; i < 'videocodecid'.length; i++) {\n        videocodecidBytes[i] = 'videocodecid'.charCodeAt(i);\n      }\n\n      _FlvTag.widthBytes = widthBytes;\n      _FlvTag.heightBytes = heightBytes;\n      _FlvTag.videocodecidBytes = videocodecidBytes;\n    }\n\n    this.keyFrame = false; // :Boolean\n\n    switch (type) {\n      case _FlvTag.VIDEO_TAG:\n        this.length = 16; // Start the buffer at 256k\n\n        bufferStartSize *= 6;\n        break;\n\n      case _FlvTag.AUDIO_TAG:\n        this.length = 13;\n        this.keyFrame = true;\n        break;\n\n      case _FlvTag.METADATA_TAG:\n        this.length = 29;\n        this.keyFrame = true;\n        break;\n\n      default:\n        throw new Error('Unknown FLV tag type');\n    }\n\n    this.bytes = new Uint8Array(bufferStartSize);\n    this.view = new DataView(this.bytes.buffer);\n    this.bytes[0] = type;\n    this.position = this.length;\n    this.keyFrame = extraData; // Defaults to false\n    // presentation timestamp\n\n    this.pts = 0; // decoder timestamp\n\n    this.dts = 0; // ByteArray#writeBytes(bytes:ByteArray, offset:uint = 0, length:uint = 0)\n\n    this.writeBytes = function (bytes, offset, length) {\n      var start = offset || 0,\n          end;\n      length = length || bytes.byteLength;\n      end = start + length;\n      prepareWrite(this, length);\n      this.bytes.set(bytes.subarray(start, end), this.position);\n      this.position += length;\n      this.length = Math.max(this.length, this.position);\n    }; // ByteArray#writeByte(value:int):void\n\n\n    this.writeByte = function (byte) {\n      prepareWrite(this, 1);\n      this.bytes[this.position] = byte;\n      this.position++;\n      this.length = Math.max(this.length, this.position);\n    }; // ByteArray#writeShort(value:int):void\n\n\n    this.writeShort = function (short) {\n      prepareWrite(this, 2);\n      this.view.setUint16(this.position, short);\n      this.position += 2;\n      this.length = Math.max(this.length, this.position);\n    }; // Negative index into array\n    // (pos:uint):int\n\n\n    this.negIndex = function (pos) {\n      return this.bytes[this.length - pos];\n    }; // The functions below ONLY work when this[0] == VIDEO_TAG.\n    // We are not going to check for that because we dont want the overhead\n    // (nal:ByteArray = null):int\n\n\n    this.nalUnitSize = function () {\n      if (adHoc === 0) {\n        return 0;\n      }\n\n      return this.length - (adHoc + 4);\n    };\n\n    this.startNalUnit = function () {\n      // remember position and add 4 bytes\n      if (adHoc > 0) {\n        throw new Error('Attempted to create new NAL wihout closing the old one');\n      } // reserve 4 bytes for nal unit size\n\n\n      adHoc = this.length;\n      this.length += 4;\n      this.position = this.length;\n    }; // (nal:ByteArray = null):void\n\n\n    this.endNalUnit = function (nalContainer) {\n      var nalStart, // :uint\n      nalLength; // :uint\n      // Rewind to the marker and write the size\n\n      if (this.length === adHoc + 4) {\n        // we started a nal unit, but didnt write one, so roll back the 4 byte size value\n        this.length -= 4;\n      } else if (adHoc > 0) {\n        nalStart = adHoc + 4;\n        nalLength = this.length - nalStart;\n        this.position = adHoc;\n        this.view.setUint32(this.position, nalLength);\n        this.position = this.length;\n\n        if (nalContainer) {\n          // Add the tag to the NAL unit\n          nalContainer.push(this.bytes.subarray(nalStart, nalStart + nalLength));\n        }\n      }\n\n      adHoc = 0;\n    };\n    /**\n     * Write out a 64-bit floating point valued metadata property. This method is\n     * called frequently during a typical parse and needs to be fast.\n     */\n    // (key:String, val:Number):void\n\n\n    this.writeMetaDataDouble = function (key, val) {\n      var i;\n      prepareWrite(this, 2 + key.length + 9); // write size of property name\n\n      this.view.setUint16(this.position, key.length);\n      this.position += 2; // this next part looks terrible but it improves parser throughput by\n      // 10kB/s in my testing\n      // write property name\n\n      if (key === 'width') {\n        this.bytes.set(widthBytes, this.position);\n        this.position += 5;\n      } else if (key === 'height') {\n        this.bytes.set(heightBytes, this.position);\n        this.position += 6;\n      } else if (key === 'videocodecid') {\n        this.bytes.set(videocodecidBytes, this.position);\n        this.position += 12;\n      } else {\n        for (i = 0; i < key.length; i++) {\n          this.bytes[this.position] = key.charCodeAt(i);\n          this.position++;\n        }\n      } // skip null byte\n\n\n      this.position++; // write property value\n\n      this.view.setFloat64(this.position, val);\n      this.position += 8; // update flv tag length\n\n      this.length = Math.max(this.length, this.position);\n      ++adHoc;\n    }; // (key:String, val:Boolean):void\n\n\n    this.writeMetaDataBoolean = function (key, val) {\n      var i;\n      prepareWrite(this, 2);\n      this.view.setUint16(this.position, key.length);\n      this.position += 2;\n\n      for (i = 0; i < key.length; i++) {\n        // if key.charCodeAt(i) >= 255, handle error\n        prepareWrite(this, 1);\n        this.bytes[this.position] = key.charCodeAt(i);\n        this.position++;\n      }\n\n      prepareWrite(this, 2);\n      this.view.setUint8(this.position, 0x01);\n      this.position++;\n      this.view.setUint8(this.position, val ? 0x01 : 0x00);\n      this.position++;\n      this.length = Math.max(this.length, this.position);\n      ++adHoc;\n    }; // ():ByteArray\n\n\n    this.finalize = function () {\n      var dtsDelta, // :int\n      len; // :int\n\n      switch (this.bytes[0]) {\n        // Video Data\n        case _FlvTag.VIDEO_TAG:\n          // We only support AVC, 1 = key frame (for AVC, a seekable\n          // frame), 2 = inter frame (for AVC, a non-seekable frame)\n          this.bytes[11] = (this.keyFrame || extraData ? 0x10 : 0x20) | 0x07;\n          this.bytes[12] = extraData ? 0x00 : 0x01;\n          dtsDelta = this.pts - this.dts;\n          this.bytes[13] = (dtsDelta & 0x00FF0000) >>> 16;\n          this.bytes[14] = (dtsDelta & 0x0000FF00) >>> 8;\n          this.bytes[15] = (dtsDelta & 0x000000FF) >>> 0;\n          break;\n\n        case _FlvTag.AUDIO_TAG:\n          this.bytes[11] = 0xAF; // 44 kHz, 16-bit stereo\n\n          this.bytes[12] = extraData ? 0x00 : 0x01;\n          break;\n\n        case _FlvTag.METADATA_TAG:\n          this.position = 11;\n          this.view.setUint8(this.position, 0x02); // String type\n\n          this.position++;\n          this.view.setUint16(this.position, 0x0A); // 10 Bytes\n\n          this.position += 2; // set \"onMetaData\"\n\n          this.bytes.set([0x6f, 0x6e, 0x4d, 0x65, 0x74, 0x61, 0x44, 0x61, 0x74, 0x61], this.position);\n          this.position += 10;\n          this.bytes[this.position] = 0x08; // Array type\n\n          this.position++;\n          this.view.setUint32(this.position, adHoc);\n          this.position = this.length;\n          this.bytes.set([0, 0, 9], this.position);\n          this.position += 3; // End Data Tag\n\n          this.length = this.position;\n          break;\n      }\n\n      len = this.length - 11; // write the DataSize field\n\n      this.bytes[1] = (len & 0x00FF0000) >>> 16;\n      this.bytes[2] = (len & 0x0000FF00) >>> 8;\n      this.bytes[3] = (len & 0x000000FF) >>> 0; // write the Timestamp\n\n      this.bytes[4] = (this.dts & 0x00FF0000) >>> 16;\n      this.bytes[5] = (this.dts & 0x0000FF00) >>> 8;\n      this.bytes[6] = (this.dts & 0x000000FF) >>> 0;\n      this.bytes[7] = (this.dts & 0xFF000000) >>> 24; // write the StreamID\n\n      this.bytes[8] = 0;\n      this.bytes[9] = 0;\n      this.bytes[10] = 0; // Sometimes we're at the end of the view and have one slot to write a\n      // uint32, so, prepareWrite of count 4, since, view is uint8\n\n      prepareWrite(this, 4);\n      this.view.setUint32(this.length, this.length);\n      this.length += 4;\n      this.position += 4; // trim down the byte buffer to what is actually being used\n\n      this.bytes = this.bytes.subarray(0, this.length);\n      this.frameTime = _FlvTag.frameTime(this.bytes); // if bytes.bytelength isn't equal to this.length, handle error\n\n      return this;\n    };\n  };\n\n  _FlvTag.AUDIO_TAG = 0x08; // == 8, :uint\n\n  _FlvTag.VIDEO_TAG = 0x09; // == 9, :uint\n\n  _FlvTag.METADATA_TAG = 0x12; // == 18, :uint\n  // (tag:ByteArray):Boolean {\n\n  _FlvTag.isAudioFrame = function (tag) {\n    return _FlvTag.AUDIO_TAG === tag[0];\n  }; // (tag:ByteArray):Boolean {\n\n\n  _FlvTag.isVideoFrame = function (tag) {\n    return _FlvTag.VIDEO_TAG === tag[0];\n  }; // (tag:ByteArray):Boolean {\n\n\n  _FlvTag.isMetaData = function (tag) {\n    return _FlvTag.METADATA_TAG === tag[0];\n  }; // (tag:ByteArray):Boolean {\n\n\n  _FlvTag.isKeyFrame = function (tag) {\n    if (_FlvTag.isVideoFrame(tag)) {\n      return tag[11] === 0x17;\n    }\n\n    if (_FlvTag.isAudioFrame(tag)) {\n      return true;\n    }\n\n    if (_FlvTag.isMetaData(tag)) {\n      return true;\n    }\n\n    return false;\n  }; // (tag:ByteArray):uint {\n\n\n  _FlvTag.frameTime = function (tag) {\n    var pts = tag[4] << 16; // :uint\n\n    pts |= tag[5] << 8;\n    pts |= tag[6] << 0;\n    pts |= tag[7] << 24;\n    return pts;\n  };\n\n  var flvTag = _FlvTag;\n\n  /**\n   * The final stage of the transmuxer that emits the flv tags\n   * for audio, video, and metadata. Also tranlates in time and\n   * outputs caption data and id3 cues.\n   */\n\n\n  var CoalesceStream = function CoalesceStream(options) {\n    // Number of Tracks per output segment\n    // If greater than 1, we combine multiple\n    // tracks into a single segment\n    this.numberOfTracks = 0;\n    this.metadataStream = options.metadataStream;\n    this.videoTags = [];\n    this.audioTags = [];\n    this.videoTrack = null;\n    this.audioTrack = null;\n    this.pendingCaptions = [];\n    this.pendingMetadata = [];\n    this.pendingTracks = 0;\n    this.processedTracks = 0;\n    CoalesceStream.prototype.init.call(this); // Take output from multiple\n\n    this.push = function (output) {\n      // buffer incoming captions until the associated video segment\n      // finishes\n      if (output.text) {\n        return this.pendingCaptions.push(output);\n      } // buffer incoming id3 tags until the final flush\n\n\n      if (output.frames) {\n        return this.pendingMetadata.push(output);\n      }\n\n      if (output.track.type === 'video') {\n        this.videoTrack = output.track;\n        this.videoTags = output.tags;\n        this.pendingTracks++;\n      }\n\n      if (output.track.type === 'audio') {\n        this.audioTrack = output.track;\n        this.audioTags = output.tags;\n        this.pendingTracks++;\n      }\n    };\n  };\n\n  CoalesceStream.prototype = new stream();\n\n  CoalesceStream.prototype.flush = function (flushSource) {\n    var id3,\n        caption,\n        i,\n        timelineStartPts,\n        event = {\n      tags: {},\n      captions: [],\n      captionStreams: {},\n      metadata: []\n    };\n\n    if (this.pendingTracks < this.numberOfTracks) {\n      if (flushSource !== 'VideoSegmentStream' && flushSource !== 'AudioSegmentStream') {\n        // Return because we haven't received a flush from a data-generating\n        // portion of the segment (meaning that we have only recieved meta-data\n        // or captions.)\n        return;\n      } else if (this.pendingTracks === 0) {\n        // In the case where we receive a flush without any data having been\n        // received we consider it an emitted track for the purposes of coalescing\n        // `done` events.\n        // We do this for the case where there is an audio and video track in the\n        // segment but no audio data. (seen in several playlists with alternate\n        // audio tracks and no audio present in the main TS segments.)\n        this.processedTracks++;\n\n        if (this.processedTracks < this.numberOfTracks) {\n          return;\n        }\n      }\n    }\n\n    this.processedTracks += this.pendingTracks;\n    this.pendingTracks = 0;\n\n    if (this.processedTracks < this.numberOfTracks) {\n      return;\n    }\n\n    if (this.videoTrack) {\n      timelineStartPts = this.videoTrack.timelineStartInfo.pts;\n    } else if (this.audioTrack) {\n      timelineStartPts = this.audioTrack.timelineStartInfo.pts;\n    }\n\n    event.tags.videoTags = this.videoTags;\n    event.tags.audioTags = this.audioTags; // Translate caption PTS times into second offsets into the\n    // video timeline for the segment, and add track info\n\n    for (i = 0; i < this.pendingCaptions.length; i++) {\n      caption = this.pendingCaptions[i];\n      caption.startTime = caption.startPts - timelineStartPts;\n      caption.startTime /= 90e3;\n      caption.endTime = caption.endPts - timelineStartPts;\n      caption.endTime /= 90e3;\n      event.captionStreams[caption.stream] = true;\n      event.captions.push(caption);\n    } // Translate ID3 frame PTS times into second offsets into the\n    // video timeline for the segment\n\n\n    for (i = 0; i < this.pendingMetadata.length; i++) {\n      id3 = this.pendingMetadata[i];\n      id3.cueTime = id3.pts - timelineStartPts;\n      id3.cueTime /= 90e3;\n      event.metadata.push(id3);\n    } // We add this to every single emitted segment even though we only need\n    // it for the first\n\n\n    event.metadata.dispatchType = this.metadataStream.dispatchType; // Reset stream state\n\n    this.videoTrack = null;\n    this.audioTrack = null;\n    this.videoTags = [];\n    this.audioTags = [];\n    this.pendingCaptions.length = 0;\n    this.pendingMetadata.length = 0;\n    this.pendingTracks = 0;\n    this.processedTracks = 0; // Emit the final segment\n\n    this.trigger('data', event);\n    this.trigger('done');\n  };\n\n  var coalesceStream = CoalesceStream;\n\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n\n  var TagList = function TagList() {\n    var self = this;\n    this.list = [];\n\n    this.push = function (tag) {\n      this.list.push({\n        bytes: tag.bytes,\n        dts: tag.dts,\n        pts: tag.pts,\n        keyFrame: tag.keyFrame,\n        metaDataTag: tag.metaDataTag\n      });\n    };\n\n    Object.defineProperty(this, 'length', {\n      get: function get() {\n        return self.list.length;\n      }\n    });\n  };\n\n  var tagList = TagList;\n\n  var H264Stream = h264.H264Stream;\n\n  var _Transmuxer, _VideoSegmentStream, _AudioSegmentStream, collectTimelineInfo, metaDataTag, extraDataTag;\n  /**\n   * Store information about the start and end of the tracka and the\n   * duration for each frame/sample we process in order to calculate\n   * the baseMediaDecodeTime\n   */\n\n\n  collectTimelineInfo = function collectTimelineInfo(track, data) {\n    if (typeof data.pts === 'number') {\n      if (track.timelineStartInfo.pts === undefined) {\n        track.timelineStartInfo.pts = data.pts;\n      } else {\n        track.timelineStartInfo.pts = Math.min(track.timelineStartInfo.pts, data.pts);\n      }\n    }\n\n    if (typeof data.dts === 'number') {\n      if (track.timelineStartInfo.dts === undefined) {\n        track.timelineStartInfo.dts = data.dts;\n      } else {\n        track.timelineStartInfo.dts = Math.min(track.timelineStartInfo.dts, data.dts);\n      }\n    }\n  };\n\n  metaDataTag = function metaDataTag(track, pts) {\n    var tag = new flvTag(flvTag.METADATA_TAG); // :FlvTag\n\n    tag.dts = pts;\n    tag.pts = pts;\n    tag.writeMetaDataDouble('videocodecid', 7);\n    tag.writeMetaDataDouble('width', track.width);\n    tag.writeMetaDataDouble('height', track.height);\n    return tag;\n  };\n\n  extraDataTag = function extraDataTag(track, pts) {\n    var i,\n        tag = new flvTag(flvTag.VIDEO_TAG, true);\n    tag.dts = pts;\n    tag.pts = pts;\n    tag.writeByte(0x01); // version\n\n    tag.writeByte(track.profileIdc); // profile\n\n    tag.writeByte(track.profileCompatibility); // compatibility\n\n    tag.writeByte(track.levelIdc); // level\n\n    tag.writeByte(0xFC | 0x03); // reserved (6 bits), NULA length size - 1 (2 bits)\n\n    tag.writeByte(0xE0 | 0x01); // reserved (3 bits), num of SPS (5 bits)\n\n    tag.writeShort(track.sps[0].length); // data of SPS\n\n    tag.writeBytes(track.sps[0]); // SPS\n\n    tag.writeByte(track.pps.length); // num of PPS (will there ever be more that 1 PPS?)\n\n    for (i = 0; i < track.pps.length; ++i) {\n      tag.writeShort(track.pps[i].length); // 2 bytes for length of PPS\n\n      tag.writeBytes(track.pps[i]); // data of PPS\n    }\n\n    return tag;\n  };\n  /**\n   * Constructs a single-track, media segment from AAC data\n   * events. The output of this stream can be fed to flash.\n   */\n\n\n  _AudioSegmentStream = function AudioSegmentStream(track) {\n    var adtsFrames = [],\n        videoKeyFrames = [],\n        oldExtraData;\n\n    _AudioSegmentStream.prototype.init.call(this);\n\n    this.push = function (data) {\n      collectTimelineInfo(track, data);\n\n      if (track) {\n        track.audioobjecttype = data.audioobjecttype;\n        track.channelcount = data.channelcount;\n        track.samplerate = data.samplerate;\n        track.samplingfrequencyindex = data.samplingfrequencyindex;\n        track.samplesize = data.samplesize;\n        track.extraData = track.audioobjecttype << 11 | track.samplingfrequencyindex << 7 | track.channelcount << 3;\n      }\n\n      data.pts = Math.round(data.pts / 90);\n      data.dts = Math.round(data.dts / 90); // buffer audio data until end() is called\n\n      adtsFrames.push(data);\n    };\n\n    this.flush = function () {\n      var currentFrame,\n          adtsFrame,\n          lastMetaPts,\n          tags = new tagList(); // return early if no audio data has been observed\n\n      if (adtsFrames.length === 0) {\n        this.trigger('done', 'AudioSegmentStream');\n        return;\n      }\n\n      lastMetaPts = -Infinity;\n\n      while (adtsFrames.length) {\n        currentFrame = adtsFrames.shift(); // write out a metadata frame at every video key frame\n\n        if (videoKeyFrames.length && currentFrame.pts >= videoKeyFrames[0]) {\n          lastMetaPts = videoKeyFrames.shift();\n          this.writeMetaDataTags(tags, lastMetaPts);\n        } // also write out metadata tags every 1 second so that the decoder\n        // is re-initialized quickly after seeking into a different\n        // audio configuration.\n\n\n        if (track.extraData !== oldExtraData || currentFrame.pts - lastMetaPts >= 1000) {\n          this.writeMetaDataTags(tags, currentFrame.pts);\n          oldExtraData = track.extraData;\n          lastMetaPts = currentFrame.pts;\n        }\n\n        adtsFrame = new flvTag(flvTag.AUDIO_TAG);\n        adtsFrame.pts = currentFrame.pts;\n        adtsFrame.dts = currentFrame.dts;\n        adtsFrame.writeBytes(currentFrame.data);\n        tags.push(adtsFrame.finalize());\n      }\n\n      videoKeyFrames.length = 0;\n      oldExtraData = null;\n      this.trigger('data', {\n        track: track,\n        tags: tags.list\n      });\n      this.trigger('done', 'AudioSegmentStream');\n    };\n\n    this.writeMetaDataTags = function (tags, pts) {\n      var adtsFrame;\n      adtsFrame = new flvTag(flvTag.METADATA_TAG); // For audio, DTS is always the same as PTS. We want to set the DTS\n      // however so we can compare with video DTS to determine approximate\n      // packet order\n\n      adtsFrame.pts = pts;\n      adtsFrame.dts = pts; // AAC is always 10\n\n      adtsFrame.writeMetaDataDouble('audiocodecid', 10);\n      adtsFrame.writeMetaDataBoolean('stereo', track.channelcount === 2);\n      adtsFrame.writeMetaDataDouble('audiosamplerate', track.samplerate); // Is AAC always 16 bit?\n\n      adtsFrame.writeMetaDataDouble('audiosamplesize', 16);\n      tags.push(adtsFrame.finalize());\n      adtsFrame = new flvTag(flvTag.AUDIO_TAG, true); // For audio, DTS is always the same as PTS. We want to set the DTS\n      // however so we can compare with video DTS to determine approximate\n      // packet order\n\n      adtsFrame.pts = pts;\n      adtsFrame.dts = pts;\n      adtsFrame.view.setUint16(adtsFrame.position, track.extraData);\n      adtsFrame.position += 2;\n      adtsFrame.length = Math.max(adtsFrame.length, adtsFrame.position);\n      tags.push(adtsFrame.finalize());\n    };\n\n    this.onVideoKeyFrame = function (pts) {\n      videoKeyFrames.push(pts);\n    };\n  };\n\n  _AudioSegmentStream.prototype = new stream();\n  /**\n   * Store FlvTags for the h264 stream\n   * @param track {object} track metadata configuration\n   */\n\n  _VideoSegmentStream = function VideoSegmentStream(track) {\n    var nalUnits = [],\n        config,\n        h264Frame;\n\n    _VideoSegmentStream.prototype.init.call(this);\n\n    this.finishFrame = function (tags, frame) {\n      if (!frame) {\n        return;\n      } // Check if keyframe and the length of tags.\n      // This makes sure we write metadata on the first frame of a segment.\n\n\n      if (config && track && track.newMetadata && (frame.keyFrame || tags.length === 0)) {\n        // Push extra data on every IDR frame in case we did a stream change + seek\n        var metaTag = metaDataTag(config, frame.dts).finalize();\n        var extraTag = extraDataTag(track, frame.dts).finalize();\n        metaTag.metaDataTag = extraTag.metaDataTag = true;\n        tags.push(metaTag);\n        tags.push(extraTag);\n        track.newMetadata = false;\n        this.trigger('keyframe', frame.dts);\n      }\n\n      frame.endNalUnit();\n      tags.push(frame.finalize());\n      h264Frame = null;\n    };\n\n    this.push = function (data) {\n      collectTimelineInfo(track, data);\n      data.pts = Math.round(data.pts / 90);\n      data.dts = Math.round(data.dts / 90); // buffer video until flush() is called\n\n      nalUnits.push(data);\n    };\n\n    this.flush = function () {\n      var currentNal,\n          tags = new tagList(); // Throw away nalUnits at the start of the byte stream until we find\n      // the first AUD\n\n      while (nalUnits.length) {\n        if (nalUnits[0].nalUnitType === 'access_unit_delimiter_rbsp') {\n          break;\n        }\n\n        nalUnits.shift();\n      } // return early if no video data has been observed\n\n\n      if (nalUnits.length === 0) {\n        this.trigger('done', 'VideoSegmentStream');\n        return;\n      }\n\n      while (nalUnits.length) {\n        currentNal = nalUnits.shift(); // record the track config\n\n        if (currentNal.nalUnitType === 'seq_parameter_set_rbsp') {\n          track.newMetadata = true;\n          config = currentNal.config;\n          track.width = config.width;\n          track.height = config.height;\n          track.sps = [currentNal.data];\n          track.profileIdc = config.profileIdc;\n          track.levelIdc = config.levelIdc;\n          track.profileCompatibility = config.profileCompatibility;\n          h264Frame.endNalUnit();\n        } else if (currentNal.nalUnitType === 'pic_parameter_set_rbsp') {\n          track.newMetadata = true;\n          track.pps = [currentNal.data];\n          h264Frame.endNalUnit();\n        } else if (currentNal.nalUnitType === 'access_unit_delimiter_rbsp') {\n          if (h264Frame) {\n            this.finishFrame(tags, h264Frame);\n          }\n\n          h264Frame = new flvTag(flvTag.VIDEO_TAG);\n          h264Frame.pts = currentNal.pts;\n          h264Frame.dts = currentNal.dts;\n        } else {\n          if (currentNal.nalUnitType === 'slice_layer_without_partitioning_rbsp_idr') {\n            // the current sample is a key frame\n            h264Frame.keyFrame = true;\n          }\n\n          h264Frame.endNalUnit();\n        }\n\n        h264Frame.startNalUnit();\n        h264Frame.writeBytes(currentNal.data);\n      }\n\n      if (h264Frame) {\n        this.finishFrame(tags, h264Frame);\n      }\n\n      this.trigger('data', {\n        track: track,\n        tags: tags.list\n      }); // Continue with the flush process now\n\n      this.trigger('done', 'VideoSegmentStream');\n    };\n  };\n\n  _VideoSegmentStream.prototype = new stream();\n  /**\n   * An object that incrementally transmuxes MPEG2 Trasport Stream\n   * chunks into an FLV.\n   */\n\n  _Transmuxer = function Transmuxer(options) {\n    var self = this,\n        packetStream,\n        parseStream,\n        elementaryStream,\n        videoTimestampRolloverStream,\n        audioTimestampRolloverStream,\n        timedMetadataTimestampRolloverStream,\n        adtsStream,\n        h264Stream,\n        videoSegmentStream,\n        audioSegmentStream,\n        captionStream,\n        coalesceStream$1;\n\n    _Transmuxer.prototype.init.call(this);\n\n    options = options || {}; // expose the metadata stream\n\n    this.metadataStream = new m2ts_1.MetadataStream();\n    options.metadataStream = this.metadataStream; // set up the parsing pipeline\n\n    packetStream = new m2ts_1.TransportPacketStream();\n    parseStream = new m2ts_1.TransportParseStream();\n    elementaryStream = new m2ts_1.ElementaryStream();\n    videoTimestampRolloverStream = new m2ts_1.TimestampRolloverStream('video');\n    audioTimestampRolloverStream = new m2ts_1.TimestampRolloverStream('audio');\n    timedMetadataTimestampRolloverStream = new m2ts_1.TimestampRolloverStream('timed-metadata');\n    adtsStream = new adts();\n    h264Stream = new H264Stream();\n    coalesceStream$1 = new coalesceStream(options); // disassemble MPEG2-TS packets into elementary streams\n\n    packetStream.pipe(parseStream).pipe(elementaryStream); // !!THIS ORDER IS IMPORTANT!!\n    // demux the streams\n\n    elementaryStream.pipe(videoTimestampRolloverStream).pipe(h264Stream);\n    elementaryStream.pipe(audioTimestampRolloverStream).pipe(adtsStream);\n    elementaryStream.pipe(timedMetadataTimestampRolloverStream).pipe(this.metadataStream).pipe(coalesceStream$1); // if CEA-708 parsing is available, hook up a caption stream\n\n    captionStream = new m2ts_1.CaptionStream(options);\n    h264Stream.pipe(captionStream).pipe(coalesceStream$1); // hook up the segment streams once track metadata is delivered\n\n    elementaryStream.on('data', function (data) {\n      var i, videoTrack, audioTrack;\n\n      if (data.type === 'metadata') {\n        i = data.tracks.length; // scan the tracks listed in the metadata\n\n        while (i--) {\n          if (data.tracks[i].type === 'video') {\n            videoTrack = data.tracks[i];\n          } else if (data.tracks[i].type === 'audio') {\n            audioTrack = data.tracks[i];\n          }\n        } // hook up the video segment stream to the first track with h264 data\n\n\n        if (videoTrack && !videoSegmentStream) {\n          coalesceStream$1.numberOfTracks++;\n          videoSegmentStream = new _VideoSegmentStream(videoTrack); // Set up the final part of the video pipeline\n\n          h264Stream.pipe(videoSegmentStream).pipe(coalesceStream$1);\n        }\n\n        if (audioTrack && !audioSegmentStream) {\n          // hook up the audio segment stream to the first track with aac data\n          coalesceStream$1.numberOfTracks++;\n          audioSegmentStream = new _AudioSegmentStream(audioTrack); // Set up the final part of the audio pipeline\n\n          adtsStream.pipe(audioSegmentStream).pipe(coalesceStream$1);\n\n          if (videoSegmentStream) {\n            videoSegmentStream.on('keyframe', audioSegmentStream.onVideoKeyFrame);\n          }\n        }\n      }\n    }); // feed incoming data to the front of the parsing pipeline\n\n    this.push = function (data) {\n      packetStream.push(data);\n    }; // flush any buffered data\n\n\n    this.flush = function () {\n      // Start at the top of the pipeline and flush all pending work\n      packetStream.flush();\n    }; // Caption data has to be reset when seeking outside buffered range\n\n\n    this.resetCaptions = function () {\n      captionStream.reset();\n    }; // Re-emit any data coming from the coalesce stream to the outside world\n\n\n    coalesceStream$1.on('data', function (event) {\n      self.trigger('data', event);\n    }); // Let the consumer know we have finished flushing the entire pipeline\n\n    coalesceStream$1.on('done', function () {\n      self.trigger('done');\n    });\n  };\n\n  _Transmuxer.prototype = new stream(); // forward compatibility\n\n  var transmuxer$1 = _Transmuxer;\n\n  // http://download.macromedia.com/f4v/video_file_format_spec_v10_1.pdf.\n  // Technically, this function returns the header and a metadata FLV tag\n  // if duration is greater than zero\n  // duration in seconds\n  // @return {object} the bytes of the FLV header as a Uint8Array\n\n\n  var getFlvHeader = function getFlvHeader(duration, audio, video) {\n    // :ByteArray {\n    var headBytes = new Uint8Array(3 + 1 + 1 + 4),\n        head = new DataView(headBytes.buffer),\n        metadata,\n        result,\n        metadataLength; // default arguments\n\n    duration = duration || 0;\n    audio = audio === undefined ? true : audio;\n    video = video === undefined ? true : video; // signature\n\n    head.setUint8(0, 0x46); // 'F'\n\n    head.setUint8(1, 0x4c); // 'L'\n\n    head.setUint8(2, 0x56); // 'V'\n    // version\n\n    head.setUint8(3, 0x01); // flags\n\n    head.setUint8(4, (audio ? 0x04 : 0x00) | (video ? 0x01 : 0x00)); // data offset, should be 9 for FLV v1\n\n    head.setUint32(5, headBytes.byteLength); // init the first FLV tag\n\n    if (duration <= 0) {\n      // no duration available so just write the first field of the first\n      // FLV tag\n      result = new Uint8Array(headBytes.byteLength + 4);\n      result.set(headBytes);\n      result.set([0, 0, 0, 0], headBytes.byteLength);\n      return result;\n    } // write out the duration metadata tag\n\n\n    metadata = new flvTag(flvTag.METADATA_TAG);\n    metadata.pts = metadata.dts = 0;\n    metadata.writeMetaDataDouble('duration', duration);\n    metadataLength = metadata.finalize().length;\n    result = new Uint8Array(headBytes.byteLength + metadataLength);\n    result.set(headBytes);\n    result.set(head.byteLength, metadataLength);\n    return result;\n  };\n\n  var flvHeader = getFlvHeader;\n\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n\n  var flv = {\n    tag: flvTag,\n    Transmuxer: transmuxer$1,\n    getFlvHeader: flvHeader\n  };\n\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n\n  var m2ts = m2ts_1;\n\n  var ONE_SECOND_IN_TS$1 = clock.ONE_SECOND_IN_TS;\n  /**\n   * Constructs a single-track, ISO BMFF media segment from AAC data\n   * events. The output of this stream can be fed to a SourceBuffer\n   * configured with a suitable initialization segment.\n   */\n\n  var AudioSegmentStream = function AudioSegmentStream(track, options) {\n    var adtsFrames = [],\n        sequenceNumber = 0,\n        earliestAllowedDts = 0,\n        audioAppendStartTs = 0,\n        videoBaseMediaDecodeTime = Infinity,\n        segmentStartPts = null,\n        segmentEndPts = null;\n    options = options || {};\n    AudioSegmentStream.prototype.init.call(this);\n\n    this.push = function (data) {\n      trackDecodeInfo.collectDtsInfo(track, data);\n\n      if (track) {\n        audioProperties.forEach(function (prop) {\n          track[prop] = data[prop];\n        });\n      } // buffer audio data until end() is called\n\n\n      adtsFrames.push(data);\n    };\n\n    this.setEarliestDts = function (earliestDts) {\n      earliestAllowedDts = earliestDts;\n    };\n\n    this.setVideoBaseMediaDecodeTime = function (baseMediaDecodeTime) {\n      videoBaseMediaDecodeTime = baseMediaDecodeTime;\n    };\n\n    this.setAudioAppendStart = function (timestamp) {\n      audioAppendStartTs = timestamp;\n    };\n\n    this.processFrames_ = function () {\n      var frames, moof, mdat, boxes, timingInfo; // return early if no audio data has been observed\n\n      if (adtsFrames.length === 0) {\n        return;\n      }\n\n      frames = audioFrameUtils.trimAdtsFramesByEarliestDts(adtsFrames, track, earliestAllowedDts);\n\n      if (frames.length === 0) {\n        // return early if the frames are all after the earliest allowed DTS\n        // TODO should we clear the adtsFrames?\n        return;\n      }\n\n      track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);\n      audioFrameUtils.prefixWithSilence(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime); // we have to build the index from byte locations to\n      // samples (that is, adts frames) in the audio data\n\n      track.samples = audioFrameUtils.generateSampleTable(frames); // concatenate the audio data to constuct the mdat\n\n      mdat = mp4Generator.mdat(audioFrameUtils.concatenateFrameData(frames));\n      adtsFrames = [];\n      moof = mp4Generator.moof(sequenceNumber, [track]); // bump the sequence number for next time\n\n      sequenceNumber++;\n      track.initSegment = mp4Generator.initSegment([track]); // it would be great to allocate this array up front instead of\n      // throwing away hundreds of media segment fragments\n\n      boxes = new Uint8Array(moof.byteLength + mdat.byteLength);\n      boxes.set(moof);\n      boxes.set(mdat, moof.byteLength);\n      trackDecodeInfo.clearDtsInfo(track);\n\n      if (segmentStartPts === null) {\n        segmentEndPts = segmentStartPts = frames[0].pts;\n      }\n\n      segmentEndPts += frames.length * (ONE_SECOND_IN_TS$1 * 1024 / track.samplerate);\n      timingInfo = {\n        start: segmentStartPts\n      };\n      this.trigger('timingInfo', timingInfo);\n      this.trigger('data', {\n        track: track,\n        boxes: boxes\n      });\n    };\n\n    this.flush = function () {\n      this.processFrames_(); // trigger final timing info\n\n      this.trigger('timingInfo', {\n        start: segmentStartPts,\n        end: segmentEndPts\n      });\n      this.resetTiming_();\n      this.trigger('done', 'AudioSegmentStream');\n    };\n\n    this.partialFlush = function () {\n      this.processFrames_();\n      this.trigger('partialdone', 'AudioSegmentStream');\n    };\n\n    this.endTimeline = function () {\n      this.flush();\n      this.trigger('endedtimeline', 'AudioSegmentStream');\n    };\n\n    this.resetTiming_ = function () {\n      trackDecodeInfo.clearDtsInfo(track);\n      segmentStartPts = null;\n      segmentEndPts = null;\n    };\n\n    this.reset = function () {\n      this.resetTiming_();\n      adtsFrames = [];\n      this.trigger('reset');\n    };\n  };\n\n  AudioSegmentStream.prototype = new stream();\n  var audioSegmentStream = AudioSegmentStream;\n\n  var VideoSegmentStream = function VideoSegmentStream(track, options) {\n    var sequenceNumber = 0,\n        nalUnits = [],\n        frameCache = [],\n        // gopsToAlignWith = [],\n    config,\n        pps,\n        segmentStartPts = null,\n        segmentEndPts = null,\n        gops,\n        ensureNextFrameIsKeyFrame = true;\n    options = options || {};\n    VideoSegmentStream.prototype.init.call(this);\n\n    this.push = function (nalUnit) {\n      trackDecodeInfo.collectDtsInfo(track, nalUnit);\n\n      if (typeof track.timelineStartInfo.dts === 'undefined') {\n        track.timelineStartInfo.dts = nalUnit.dts;\n      } // record the track config\n\n\n      if (nalUnit.nalUnitType === 'seq_parameter_set_rbsp' && !config) {\n        config = nalUnit.config;\n        track.sps = [nalUnit.data];\n        videoProperties.forEach(function (prop) {\n          track[prop] = config[prop];\n        }, this);\n      }\n\n      if (nalUnit.nalUnitType === 'pic_parameter_set_rbsp' && !pps) {\n        pps = nalUnit.data;\n        track.pps = [nalUnit.data];\n      } // buffer video until flush() is called\n\n\n      nalUnits.push(nalUnit);\n    };\n\n    this.processNals_ = function (cacheLastFrame) {\n      var i;\n      nalUnits = frameCache.concat(nalUnits); // Throw away nalUnits at the start of the byte stream until\n      // we find the first AUD\n\n      while (nalUnits.length) {\n        if (nalUnits[0].nalUnitType === 'access_unit_delimiter_rbsp') {\n          break;\n        }\n\n        nalUnits.shift();\n      } // Return early if no video data has been observed\n\n\n      if (nalUnits.length === 0) {\n        return;\n      }\n\n      var frames = frameUtils.groupNalsIntoFrames(nalUnits);\n\n      if (!frames.length) {\n        return;\n      } // note that the frame cache may also protect us from cases where we haven't\n      // pushed data for the entire first or last frame yet\n\n\n      frameCache = frames[frames.length - 1];\n\n      if (cacheLastFrame) {\n        frames.pop();\n        frames.duration -= frameCache.duration;\n        frames.nalCount -= frameCache.length;\n        frames.byteLength -= frameCache.byteLength;\n      }\n\n      if (!frames.length) {\n        nalUnits = [];\n        return;\n      }\n\n      this.trigger('timelineStartInfo', track.timelineStartInfo);\n\n      if (ensureNextFrameIsKeyFrame) {\n        gops = frameUtils.groupFramesIntoGops(frames);\n\n        if (!gops[0][0].keyFrame) {\n          gops = frameUtils.extendFirstKeyFrame(gops);\n\n          if (!gops[0][0].keyFrame) {\n            // we haven't yet gotten a key frame, so reset nal units to wait for more nal\n            // units\n            nalUnits = [].concat.apply([], frames).concat(frameCache);\n            frameCache = [];\n            return;\n          }\n\n          frames = [].concat.apply([], gops);\n          frames.duration = gops.duration;\n        }\n\n        ensureNextFrameIsKeyFrame = false;\n      }\n\n      if (segmentStartPts === null) {\n        segmentStartPts = frames[0].pts;\n        segmentEndPts = segmentStartPts;\n      }\n\n      segmentEndPts += frames.duration;\n      this.trigger('timingInfo', {\n        start: segmentStartPts,\n        end: segmentEndPts\n      });\n\n      for (i = 0; i < frames.length; i++) {\n        var frame = frames[i];\n        track.samples = frameUtils.generateSampleTableForFrame(frame);\n        var mdat = mp4Generator.mdat(frameUtils.concatenateNalDataForFrame(frame));\n        trackDecodeInfo.clearDtsInfo(track);\n        trackDecodeInfo.collectDtsInfo(track, frame);\n        track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);\n        var moof = mp4Generator.moof(sequenceNumber, [track]);\n        sequenceNumber++;\n        track.initSegment = mp4Generator.initSegment([track]);\n        var boxes = new Uint8Array(moof.byteLength + mdat.byteLength);\n        boxes.set(moof);\n        boxes.set(mdat, moof.byteLength);\n        this.trigger('data', {\n          track: track,\n          boxes: boxes,\n          sequence: sequenceNumber,\n          videoFrameDts: frame.dts,\n          videoFramePts: frame.pts\n        });\n      }\n\n      nalUnits = [];\n    };\n\n    this.resetTimingAndConfig_ = function () {\n      config = undefined;\n      pps = undefined;\n      segmentStartPts = null;\n      segmentEndPts = null;\n    };\n\n    this.partialFlush = function () {\n      this.processNals_(true);\n      this.trigger('partialdone', 'VideoSegmentStream');\n    };\n\n    this.flush = function () {\n      this.processNals_(false); // reset config and pps because they may differ across segments\n      // for instance, when we are rendition switching\n\n      this.resetTimingAndConfig_();\n      this.trigger('done', 'VideoSegmentStream');\n    };\n\n    this.endTimeline = function () {\n      this.flush();\n      this.trigger('endedtimeline', 'VideoSegmentStream');\n    };\n\n    this.reset = function () {\n      this.resetTimingAndConfig_();\n      frameCache = [];\n      nalUnits = [];\n      ensureNextFrameIsKeyFrame = true;\n      this.trigger('reset');\n    };\n  };\n\n  VideoSegmentStream.prototype = new stream();\n  var videoSegmentStream = VideoSegmentStream;\n\n  var isLikelyAacData = utils.isLikelyAacData;\n\n  var createPipeline = function createPipeline(object) {\n    object.prototype = new stream();\n    object.prototype.init.call(object);\n    return object;\n  };\n\n  var tsPipeline = function tsPipeline(options) {\n    var pipeline = {\n      type: 'ts',\n      tracks: {\n        audio: null,\n        video: null\n      },\n      packet: new m2ts_1.TransportPacketStream(),\n      parse: new m2ts_1.TransportParseStream(),\n      elementary: new m2ts_1.ElementaryStream(),\n      timestampRollover: new m2ts_1.TimestampRolloverStream(),\n      adts: new codecs.Adts(),\n      h264: new codecs.h264.H264Stream(),\n      captionStream: new m2ts_1.CaptionStream(options),\n      metadataStream: new m2ts_1.MetadataStream()\n    };\n    pipeline.headOfPipeline = pipeline.packet; // Transport Stream\n\n    pipeline.packet.pipe(pipeline.parse).pipe(pipeline.elementary).pipe(pipeline.timestampRollover); // H264\n\n    pipeline.timestampRollover.pipe(pipeline.h264); // Hook up CEA-608/708 caption stream\n\n    pipeline.h264.pipe(pipeline.captionStream);\n    pipeline.timestampRollover.pipe(pipeline.metadataStream); // ADTS\n\n    pipeline.timestampRollover.pipe(pipeline.adts);\n    pipeline.elementary.on('data', function (data) {\n      if (data.type !== 'metadata') {\n        return;\n      }\n\n      for (var i = 0; i < data.tracks.length; i++) {\n        if (!pipeline.tracks[data.tracks[i].type]) {\n          pipeline.tracks[data.tracks[i].type] = data.tracks[i];\n          pipeline.tracks[data.tracks[i].type].timelineStartInfo.baseMediaDecodeTime = options.baseMediaDecodeTime;\n        }\n      }\n\n      if (pipeline.tracks.video && !pipeline.videoSegmentStream) {\n        pipeline.videoSegmentStream = new videoSegmentStream(pipeline.tracks.video, options);\n        pipeline.videoSegmentStream.on('timelineStartInfo', function (timelineStartInfo) {\n          if (pipeline.tracks.audio && !options.keepOriginalTimestamps) {\n            pipeline.audioSegmentStream.setEarliestDts(timelineStartInfo.dts - options.baseMediaDecodeTime);\n          }\n        });\n        pipeline.videoSegmentStream.on('timingInfo', pipeline.trigger.bind(pipeline, 'videoTimingInfo'));\n        pipeline.videoSegmentStream.on('data', function (data) {\n          pipeline.trigger('data', {\n            type: 'video',\n            data: data\n          });\n        });\n        pipeline.videoSegmentStream.on('done', pipeline.trigger.bind(pipeline, 'done'));\n        pipeline.videoSegmentStream.on('partialdone', pipeline.trigger.bind(pipeline, 'partialdone'));\n        pipeline.videoSegmentStream.on('endedtimeline', pipeline.trigger.bind(pipeline, 'endedtimeline'));\n        pipeline.h264.pipe(pipeline.videoSegmentStream);\n      }\n\n      if (pipeline.tracks.audio && !pipeline.audioSegmentStream) {\n        pipeline.audioSegmentStream = new audioSegmentStream(pipeline.tracks.audio, options);\n        pipeline.audioSegmentStream.on('data', function (data) {\n          pipeline.trigger('data', {\n            type: 'audio',\n            data: data\n          });\n        });\n        pipeline.audioSegmentStream.on('done', pipeline.trigger.bind(pipeline, 'done'));\n        pipeline.audioSegmentStream.on('partialdone', pipeline.trigger.bind(pipeline, 'partialdone'));\n        pipeline.audioSegmentStream.on('endedtimeline', pipeline.trigger.bind(pipeline, 'endedtimeline'));\n        pipeline.audioSegmentStream.on('timingInfo', pipeline.trigger.bind(pipeline, 'audioTimingInfo'));\n        pipeline.adts.pipe(pipeline.audioSegmentStream);\n      } // emit pmt info\n\n\n      pipeline.trigger('trackinfo', {\n        hasAudio: !!pipeline.tracks.audio,\n        hasVideo: !!pipeline.tracks.video\n      });\n    });\n    pipeline.captionStream.on('data', function (caption) {\n      var timelineStartPts;\n\n      if (pipeline.tracks.video) {\n        timelineStartPts = pipeline.tracks.video.timelineStartInfo.pts || 0;\n      } else {\n        // This will only happen if we encounter caption packets before\n        // video data in a segment. This is an unusual/unlikely scenario,\n        // so we assume the timeline starts at zero for now.\n        timelineStartPts = 0;\n      } // Translate caption PTS times into second offsets into the\n      // video timeline for the segment\n\n\n      caption.startTime = clock.metadataTsToSeconds(caption.startPts, timelineStartPts, options.keepOriginalTimestamps);\n      caption.endTime = clock.metadataTsToSeconds(caption.endPts, timelineStartPts, options.keepOriginalTimestamps);\n      pipeline.trigger('caption', caption);\n    });\n    pipeline = createPipeline(pipeline);\n    pipeline.metadataStream.on('data', pipeline.trigger.bind(pipeline, 'id3Frame'));\n    return pipeline;\n  };\n\n  var aacPipeline = function aacPipeline(options) {\n    var pipeline = {\n      type: 'aac',\n      tracks: {\n        audio: null\n      },\n      metadataStream: new m2ts_1.MetadataStream(),\n      aacStream: new aac(),\n      audioRollover: new m2ts_1.TimestampRolloverStream('audio'),\n      timedMetadataRollover: new m2ts_1.TimestampRolloverStream('timed-metadata'),\n      adtsStream: new adts(true)\n    }; // set up the parsing pipeline\n\n    pipeline.headOfPipeline = pipeline.aacStream;\n    pipeline.aacStream.pipe(pipeline.audioRollover).pipe(pipeline.adtsStream);\n    pipeline.aacStream.pipe(pipeline.timedMetadataRollover).pipe(pipeline.metadataStream);\n    pipeline.metadataStream.on('timestamp', function (frame) {\n      pipeline.aacStream.setTimestamp(frame.timeStamp);\n    });\n    pipeline.aacStream.on('data', function (data) {\n      if (data.type !== 'timed-metadata' && data.type !== 'audio' || pipeline.audioSegmentStream) {\n        return;\n      }\n\n      pipeline.tracks.audio = pipeline.tracks.audio || {\n        timelineStartInfo: {\n          baseMediaDecodeTime: options.baseMediaDecodeTime\n        },\n        codec: 'adts',\n        type: 'audio'\n      }; // hook up the audio segment stream to the first track with aac data\n\n      pipeline.audioSegmentStream = new audioSegmentStream(pipeline.tracks.audio, options);\n      pipeline.audioSegmentStream.on('data', function (data) {\n        pipeline.trigger('data', {\n          type: 'audio',\n          data: data\n        });\n      });\n      pipeline.audioSegmentStream.on('partialdone', pipeline.trigger.bind(pipeline, 'partialdone'));\n      pipeline.audioSegmentStream.on('done', pipeline.trigger.bind(pipeline, 'done'));\n      pipeline.audioSegmentStream.on('endedtimeline', pipeline.trigger.bind(pipeline, 'endedtimeline'));\n      pipeline.audioSegmentStream.on('timingInfo', pipeline.trigger.bind(pipeline, 'audioTimingInfo')); // Set up the final part of the audio pipeline\n\n      pipeline.adtsStream.pipe(pipeline.audioSegmentStream);\n      pipeline.trigger('trackinfo', {\n        hasAudio: !!pipeline.tracks.audio,\n        hasVideo: !!pipeline.tracks.video\n      });\n    }); // set the pipeline up as a stream before binding to get access to the trigger function\n\n    pipeline = createPipeline(pipeline);\n    pipeline.metadataStream.on('data', pipeline.trigger.bind(pipeline, 'id3Frame'));\n    return pipeline;\n  };\n\n  var setupPipelineListeners = function setupPipelineListeners(pipeline, transmuxer) {\n    pipeline.on('data', transmuxer.trigger.bind(transmuxer, 'data'));\n    pipeline.on('done', transmuxer.trigger.bind(transmuxer, 'done'));\n    pipeline.on('partialdone', transmuxer.trigger.bind(transmuxer, 'partialdone'));\n    pipeline.on('endedtimeline', transmuxer.trigger.bind(transmuxer, 'endedtimeline'));\n    pipeline.on('audioTimingInfo', transmuxer.trigger.bind(transmuxer, 'audioTimingInfo'));\n    pipeline.on('videoTimingInfo', transmuxer.trigger.bind(transmuxer, 'videoTimingInfo'));\n    pipeline.on('trackinfo', transmuxer.trigger.bind(transmuxer, 'trackinfo'));\n    pipeline.on('id3Frame', function (event) {\n      // add this to every single emitted segment even though it's only needed for the first\n      event.dispatchType = pipeline.metadataStream.dispatchType; // keep original time, can be adjusted if needed at a higher level\n\n      event.cueTime = clock.videoTsToSeconds(event.pts);\n      transmuxer.trigger('id3Frame', event);\n    });\n    pipeline.on('caption', function (event) {\n      transmuxer.trigger('caption', event);\n    });\n  };\n\n  var Transmuxer = function Transmuxer(options) {\n    var pipeline = null,\n        hasFlushed = true;\n    options = options || {};\n    Transmuxer.prototype.init.call(this);\n    options.baseMediaDecodeTime = options.baseMediaDecodeTime || 0;\n\n    this.push = function (bytes) {\n      if (hasFlushed) {\n        var isAac = isLikelyAacData(bytes);\n\n        if (isAac && (!pipeline || pipeline.type !== 'aac')) {\n          pipeline = aacPipeline(options);\n          setupPipelineListeners(pipeline, this);\n        } else if (!isAac && (!pipeline || pipeline.type !== 'ts')) {\n          pipeline = tsPipeline(options);\n          setupPipelineListeners(pipeline, this);\n        }\n\n        hasFlushed = false;\n      }\n\n      pipeline.headOfPipeline.push(bytes);\n    };\n\n    this.flush = function () {\n      if (!pipeline) {\n        return;\n      }\n\n      hasFlushed = true;\n      pipeline.headOfPipeline.flush();\n    };\n\n    this.partialFlush = function () {\n      if (!pipeline) {\n        return;\n      }\n\n      pipeline.headOfPipeline.partialFlush();\n    };\n\n    this.endTimeline = function () {\n      if (!pipeline) {\n        return;\n      }\n\n      pipeline.headOfPipeline.endTimeline();\n    };\n\n    this.reset = function () {\n      if (!pipeline) {\n        return;\n      }\n\n      pipeline.headOfPipeline.reset();\n    };\n\n    this.setBaseMediaDecodeTime = function (baseMediaDecodeTime) {\n      if (!options.keepOriginalTimestamps) {\n        options.baseMediaDecodeTime = baseMediaDecodeTime;\n      }\n\n      if (!pipeline) {\n        return;\n      }\n\n      if (pipeline.tracks.audio) {\n        pipeline.tracks.audio.timelineStartInfo.dts = undefined;\n        pipeline.tracks.audio.timelineStartInfo.pts = undefined;\n        trackDecodeInfo.clearDtsInfo(pipeline.tracks.audio);\n\n        if (pipeline.audioRollover) {\n          pipeline.audioRollover.discontinuity();\n        }\n      }\n\n      if (pipeline.tracks.video) {\n        if (pipeline.videoSegmentStream) {\n          pipeline.videoSegmentStream.gopCache_ = [];\n        }\n\n        pipeline.tracks.video.timelineStartInfo.dts = undefined;\n        pipeline.tracks.video.timelineStartInfo.pts = undefined;\n        trackDecodeInfo.clearDtsInfo(pipeline.tracks.video); // pipeline.captionStream.reset();\n      }\n\n      if (pipeline.timestampRollover) {\n        pipeline.timestampRollover.discontinuity();\n      }\n    };\n\n    this.setRemux = function (val) {\n      options.remux = val;\n\n      if (pipeline && pipeline.coalesceStream) {\n        pipeline.coalesceStream.setRemux(val);\n      }\n    };\n\n    this.setAudioAppendStart = function (audioAppendStart) {\n      if (!pipeline || !pipeline.tracks.audio || !pipeline.audioSegmentStream) {\n        return;\n      }\n\n      pipeline.audioSegmentStream.setAudioAppendStart(audioAppendStart);\n    }; // TODO GOP alignment support\n    // Support may be a bit trickier than with full segment appends, as GOPs may be split\n    // and processed in a more granular fashion\n\n\n    this.alignGopsWith = function (gopsToAlignWith) {\n      return;\n    };\n  };\n\n  Transmuxer.prototype = new stream();\n  var transmuxer = Transmuxer;\n\n  var partial = {\n    Transmuxer: transmuxer\n  };\n\n  var getUint64$1 = numbers.getUint64;\n\n  var parseSidx = function parseSidx(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4)),\n      references: [],\n      referenceId: view.getUint32(4),\n      timescale: view.getUint32(8)\n    },\n        i = 12;\n\n    if (result.version === 0) {\n      result.earliestPresentationTime = view.getUint32(i);\n      result.firstOffset = view.getUint32(i + 4);\n      i += 8;\n    } else {\n      // read 64 bits\n      result.earliestPresentationTime = getUint64$1(data.subarray(i));\n      result.firstOffset = getUint64$1(data.subarray(i + 8));\n      i += 16;\n    }\n\n    i += 2; // reserved\n\n    var referenceCount = view.getUint16(i);\n    i += 2; // start of references\n\n    for (; referenceCount > 0; i += 12, referenceCount--) {\n      result.references.push({\n        referenceType: (data[i] & 0x80) >>> 7,\n        referencedSize: view.getUint32(i) & 0x7FFFFFFF,\n        subsegmentDuration: view.getUint32(i + 4),\n        startsWithSap: !!(data[i + 8] & 0x80),\n        sapType: (data[i + 8] & 0x70) >>> 4,\n        sapDeltaTime: view.getUint32(i + 8) & 0x0FFFFFFF\n      });\n    }\n\n    return result;\n  };\n\n  var parseSidx_1 = parseSidx;\n\n  var getUint64 = numbers.getUint64;\n\n  var inspectMp4,\n      _textifyMp,\n      parseMp4Date = function parseMp4Date(seconds) {\n    return new Date(seconds * 1000 - 2082844800000);\n  },\n      nalParse = function nalParse(avcStream) {\n    var avcView = new DataView(avcStream.buffer, avcStream.byteOffset, avcStream.byteLength),\n        result = [],\n        i,\n        length;\n\n    for (i = 0; i + 4 < avcStream.length; i += length) {\n      length = avcView.getUint32(i);\n      i += 4; // bail if this doesn't appear to be an H264 stream\n\n      if (length <= 0) {\n        result.push('<span style=\\'color:red;\\'>MALFORMED DATA</span>');\n        continue;\n      }\n\n      switch (avcStream[i] & 0x1F) {\n        case 0x01:\n          result.push('slice_layer_without_partitioning_rbsp');\n          break;\n\n        case 0x05:\n          result.push('slice_layer_without_partitioning_rbsp_idr');\n          break;\n\n        case 0x06:\n          result.push('sei_rbsp');\n          break;\n\n        case 0x07:\n          result.push('seq_parameter_set_rbsp');\n          break;\n\n        case 0x08:\n          result.push('pic_parameter_set_rbsp');\n          break;\n\n        case 0x09:\n          result.push('access_unit_delimiter_rbsp');\n          break;\n\n        default:\n          result.push('UNKNOWN NAL - ' + avcStream[i] & 0x1F);\n          break;\n      }\n    }\n\n    return result;\n  },\n      // registry of handlers for individual mp4 box types\n  parse = {\n    // codingname, not a first-class box type. stsd entries share the\n    // same format as real boxes so the parsing infrastructure can be\n    // shared\n    avc1: function avc1(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n      return {\n        dataReferenceIndex: view.getUint16(6),\n        width: view.getUint16(24),\n        height: view.getUint16(26),\n        horizresolution: view.getUint16(28) + view.getUint16(30) / 16,\n        vertresolution: view.getUint16(32) + view.getUint16(34) / 16,\n        frameCount: view.getUint16(40),\n        depth: view.getUint16(74),\n        config: inspectMp4(data.subarray(78, data.byteLength))\n      };\n    },\n    avcC: function avcC(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          result = {\n        configurationVersion: data[0],\n        avcProfileIndication: data[1],\n        profileCompatibility: data[2],\n        avcLevelIndication: data[3],\n        lengthSizeMinusOne: data[4] & 0x03,\n        sps: [],\n        pps: []\n      },\n          numOfSequenceParameterSets = data[5] & 0x1f,\n          numOfPictureParameterSets,\n          nalSize,\n          offset,\n          i; // iterate past any SPSs\n\n      offset = 6;\n\n      for (i = 0; i < numOfSequenceParameterSets; i++) {\n        nalSize = view.getUint16(offset);\n        offset += 2;\n        result.sps.push(new Uint8Array(data.subarray(offset, offset + nalSize)));\n        offset += nalSize;\n      } // iterate past any PPSs\n\n\n      numOfPictureParameterSets = data[offset];\n      offset++;\n\n      for (i = 0; i < numOfPictureParameterSets; i++) {\n        nalSize = view.getUint16(offset);\n        offset += 2;\n        result.pps.push(new Uint8Array(data.subarray(offset, offset + nalSize)));\n        offset += nalSize;\n      }\n\n      return result;\n    },\n    btrt: function btrt(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n      return {\n        bufferSizeDB: view.getUint32(0),\n        maxBitrate: view.getUint32(4),\n        avgBitrate: view.getUint32(8)\n      };\n    },\n    edts: function edts(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    elst: function elst(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          result = {\n        version: view.getUint8(0),\n        flags: new Uint8Array(data.subarray(1, 4)),\n        edits: []\n      },\n          entryCount = view.getUint32(4),\n          i;\n\n      for (i = 8; entryCount; entryCount--) {\n        if (result.version === 0) {\n          result.edits.push({\n            segmentDuration: view.getUint32(i),\n            mediaTime: view.getInt32(i + 4),\n            mediaRate: view.getUint16(i + 8) + view.getUint16(i + 10) / (256 * 256)\n          });\n          i += 12;\n        } else {\n          result.edits.push({\n            segmentDuration: getUint64(data.subarray(i)),\n            mediaTime: getUint64(data.subarray(i + 8)),\n            mediaRate: view.getUint16(i + 16) + view.getUint16(i + 18) / (256 * 256)\n          });\n          i += 20;\n        }\n      }\n\n      return result;\n    },\n    esds: function esds(data) {\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        esId: data[6] << 8 | data[7],\n        streamPriority: data[8] & 0x1f,\n        decoderConfig: {\n          objectProfileIndication: data[11],\n          streamType: data[12] >>> 2 & 0x3f,\n          bufferSize: data[13] << 16 | data[14] << 8 | data[15],\n          maxBitrate: data[16] << 24 | data[17] << 16 | data[18] << 8 | data[19],\n          avgBitrate: data[20] << 24 | data[21] << 16 | data[22] << 8 | data[23],\n          decoderConfigDescriptor: {\n            tag: data[24],\n            length: data[25],\n            audioObjectType: data[26] >>> 3 & 0x1f,\n            samplingFrequencyIndex: (data[26] & 0x07) << 1 | data[27] >>> 7 & 0x01,\n            channelConfiguration: data[27] >>> 3 & 0x0f\n          }\n        }\n      };\n    },\n    ftyp: function ftyp(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          result = {\n        majorBrand: parseType_1(data.subarray(0, 4)),\n        minorVersion: view.getUint32(4),\n        compatibleBrands: []\n      },\n          i = 8;\n\n      while (i < data.byteLength) {\n        result.compatibleBrands.push(parseType_1(data.subarray(i, i + 4)));\n        i += 4;\n      }\n\n      return result;\n    },\n    dinf: function dinf(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    dref: function dref(data) {\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        dataReferences: inspectMp4(data.subarray(8))\n      };\n    },\n    hdlr: function hdlr(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          result = {\n        version: view.getUint8(0),\n        flags: new Uint8Array(data.subarray(1, 4)),\n        handlerType: parseType_1(data.subarray(8, 12)),\n        name: ''\n      },\n          i = 8; // parse out the name field\n\n      for (i = 24; i < data.byteLength; i++) {\n        if (data[i] === 0x00) {\n          // the name field is null-terminated\n          i++;\n          break;\n        }\n\n        result.name += String.fromCharCode(data[i]);\n      } // decode UTF-8 to javascript's internal representation\n      // see http://ecmanaut.blogspot.com/2006/07/encoding-decoding-utf8-in-javascript.html\n\n\n      result.name = decodeURIComponent(escape(result.name));\n      return result;\n    },\n    mdat: function mdat(data) {\n      return {\n        byteLength: data.byteLength,\n        nals: nalParse(data)\n      };\n    },\n    mdhd: function mdhd(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          i = 4,\n          language,\n          result = {\n        version: view.getUint8(0),\n        flags: new Uint8Array(data.subarray(1, 4)),\n        language: ''\n      };\n\n      if (result.version === 1) {\n        i += 4;\n        result.creationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n\n        i += 8;\n        result.modificationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n\n        i += 4;\n        result.timescale = view.getUint32(i);\n        i += 8;\n        result.duration = view.getUint32(i); // truncating top 4 bytes\n      } else {\n        result.creationTime = parseMp4Date(view.getUint32(i));\n        i += 4;\n        result.modificationTime = parseMp4Date(view.getUint32(i));\n        i += 4;\n        result.timescale = view.getUint32(i);\n        i += 4;\n        result.duration = view.getUint32(i);\n      }\n\n      i += 4; // language is stored as an ISO-639-2/T code in an array of three 5-bit fields\n      // each field is the packed difference between its ASCII value and 0x60\n\n      language = view.getUint16(i);\n      result.language += String.fromCharCode((language >> 10) + 0x60);\n      result.language += String.fromCharCode(((language & 0x03e0) >> 5) + 0x60);\n      result.language += String.fromCharCode((language & 0x1f) + 0x60);\n      return result;\n    },\n    mdia: function mdia(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    mfhd: function mfhd(data) {\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        sequenceNumber: data[4] << 24 | data[5] << 16 | data[6] << 8 | data[7]\n      };\n    },\n    minf: function minf(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    // codingname, not a first-class box type. stsd entries share the\n    // same format as real boxes so the parsing infrastructure can be\n    // shared\n    mp4a: function mp4a(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          result = {\n        // 6 bytes reserved\n        dataReferenceIndex: view.getUint16(6),\n        // 4 + 4 bytes reserved\n        channelcount: view.getUint16(16),\n        samplesize: view.getUint16(18),\n        // 2 bytes pre_defined\n        // 2 bytes reserved\n        samplerate: view.getUint16(24) + view.getUint16(26) / 65536\n      }; // if there are more bytes to process, assume this is an ISO/IEC\n      // 14496-14 MP4AudioSampleEntry and parse the ESDBox\n\n      if (data.byteLength > 28) {\n        result.streamDescriptor = inspectMp4(data.subarray(28))[0];\n      }\n\n      return result;\n    },\n    moof: function moof(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    moov: function moov(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    mvex: function mvex(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    mvhd: function mvhd(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          i = 4,\n          result = {\n        version: view.getUint8(0),\n        flags: new Uint8Array(data.subarray(1, 4))\n      };\n\n      if (result.version === 1) {\n        i += 4;\n        result.creationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n\n        i += 8;\n        result.modificationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n\n        i += 4;\n        result.timescale = view.getUint32(i);\n        i += 8;\n        result.duration = view.getUint32(i); // truncating top 4 bytes\n      } else {\n        result.creationTime = parseMp4Date(view.getUint32(i));\n        i += 4;\n        result.modificationTime = parseMp4Date(view.getUint32(i));\n        i += 4;\n        result.timescale = view.getUint32(i);\n        i += 4;\n        result.duration = view.getUint32(i);\n      }\n\n      i += 4; // convert fixed-point, base 16 back to a number\n\n      result.rate = view.getUint16(i) + view.getUint16(i + 2) / 16;\n      i += 4;\n      result.volume = view.getUint8(i) + view.getUint8(i + 1) / 8;\n      i += 2;\n      i += 2;\n      i += 2 * 4;\n      result.matrix = new Uint32Array(data.subarray(i, i + 9 * 4));\n      i += 9 * 4;\n      i += 6 * 4;\n      result.nextTrackId = view.getUint32(i);\n      return result;\n    },\n    pdin: function pdin(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n      return {\n        version: view.getUint8(0),\n        flags: new Uint8Array(data.subarray(1, 4)),\n        rate: view.getUint32(4),\n        initialDelay: view.getUint32(8)\n      };\n    },\n    sdtp: function sdtp(data) {\n      var result = {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        samples: []\n      },\n          i;\n\n      for (i = 4; i < data.byteLength; i++) {\n        result.samples.push({\n          dependsOn: (data[i] & 0x30) >> 4,\n          isDependedOn: (data[i] & 0x0c) >> 2,\n          hasRedundancy: data[i] & 0x03\n        });\n      }\n\n      return result;\n    },\n    sidx: parseSidx_1,\n    smhd: function smhd(data) {\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        balance: data[4] + data[5] / 256\n      };\n    },\n    stbl: function stbl(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    ctts: function ctts(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          result = {\n        version: view.getUint8(0),\n        flags: new Uint8Array(data.subarray(1, 4)),\n        compositionOffsets: []\n      },\n          entryCount = view.getUint32(4),\n          i;\n\n      for (i = 8; entryCount; i += 8, entryCount--) {\n        result.compositionOffsets.push({\n          sampleCount: view.getUint32(i),\n          sampleOffset: view[result.version === 0 ? 'getUint32' : 'getInt32'](i + 4)\n        });\n      }\n\n      return result;\n    },\n    stss: function stss(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          result = {\n        version: view.getUint8(0),\n        flags: new Uint8Array(data.subarray(1, 4)),\n        syncSamples: []\n      },\n          entryCount = view.getUint32(4),\n          i;\n\n      for (i = 8; entryCount; i += 4, entryCount--) {\n        result.syncSamples.push(view.getUint32(i));\n      }\n\n      return result;\n    },\n    stco: function stco(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          result = {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        chunkOffsets: []\n      },\n          entryCount = view.getUint32(4),\n          i;\n\n      for (i = 8; entryCount; i += 4, entryCount--) {\n        result.chunkOffsets.push(view.getUint32(i));\n      }\n\n      return result;\n    },\n    stsc: function stsc(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          entryCount = view.getUint32(4),\n          result = {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        sampleToChunks: []\n      },\n          i;\n\n      for (i = 8; entryCount; i += 12, entryCount--) {\n        result.sampleToChunks.push({\n          firstChunk: view.getUint32(i),\n          samplesPerChunk: view.getUint32(i + 4),\n          sampleDescriptionIndex: view.getUint32(i + 8)\n        });\n      }\n\n      return result;\n    },\n    stsd: function stsd(data) {\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        sampleDescriptions: inspectMp4(data.subarray(8))\n      };\n    },\n    stsz: function stsz(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          result = {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        sampleSize: view.getUint32(4),\n        entries: []\n      },\n          i;\n\n      for (i = 12; i < data.byteLength; i += 4) {\n        result.entries.push(view.getUint32(i));\n      }\n\n      return result;\n    },\n    stts: function stts(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          result = {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        timeToSamples: []\n      },\n          entryCount = view.getUint32(4),\n          i;\n\n      for (i = 8; entryCount; i += 8, entryCount--) {\n        result.timeToSamples.push({\n          sampleCount: view.getUint32(i),\n          sampleDelta: view.getUint32(i + 4)\n        });\n      }\n\n      return result;\n    },\n    styp: function styp(data) {\n      return parse.ftyp(data);\n    },\n    tfdt: parseTfdt,\n    tfhd: parseTfhd,\n    tkhd: function tkhd(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          i = 4,\n          result = {\n        version: view.getUint8(0),\n        flags: new Uint8Array(data.subarray(1, 4))\n      };\n\n      if (result.version === 1) {\n        i += 4;\n        result.creationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n\n        i += 8;\n        result.modificationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n\n        i += 4;\n        result.trackId = view.getUint32(i);\n        i += 4;\n        i += 8;\n        result.duration = view.getUint32(i); // truncating top 4 bytes\n      } else {\n        result.creationTime = parseMp4Date(view.getUint32(i));\n        i += 4;\n        result.modificationTime = parseMp4Date(view.getUint32(i));\n        i += 4;\n        result.trackId = view.getUint32(i);\n        i += 4;\n        i += 4;\n        result.duration = view.getUint32(i);\n      }\n\n      i += 4;\n      i += 2 * 4;\n      result.layer = view.getUint16(i);\n      i += 2;\n      result.alternateGroup = view.getUint16(i);\n      i += 2; // convert fixed-point, base 16 back to a number\n\n      result.volume = view.getUint8(i) + view.getUint8(i + 1) / 8;\n      i += 2;\n      i += 2;\n      result.matrix = new Uint32Array(data.subarray(i, i + 9 * 4));\n      i += 9 * 4;\n      result.width = view.getUint16(i) + view.getUint16(i + 2) / 65536;\n      i += 4;\n      result.height = view.getUint16(i) + view.getUint16(i + 2) / 65536;\n      return result;\n    },\n    traf: function traf(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    trak: function trak(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    trex: function trex(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        trackId: view.getUint32(4),\n        defaultSampleDescriptionIndex: view.getUint32(8),\n        defaultSampleDuration: view.getUint32(12),\n        defaultSampleSize: view.getUint32(16),\n        sampleDependsOn: data[20] & 0x03,\n        sampleIsDependedOn: (data[21] & 0xc0) >> 6,\n        sampleHasRedundancy: (data[21] & 0x30) >> 4,\n        samplePaddingValue: (data[21] & 0x0e) >> 1,\n        sampleIsDifferenceSample: !!(data[21] & 0x01),\n        sampleDegradationPriority: view.getUint16(22)\n      };\n    },\n    trun: parseTrun,\n    'url ': function url(data) {\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4))\n      };\n    },\n    vmhd: function vmhd(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        graphicsmode: view.getUint16(4),\n        opcolor: new Uint16Array([view.getUint16(6), view.getUint16(8), view.getUint16(10)])\n      };\n    }\n  };\n  /**\n   * Return a javascript array of box objects parsed from an ISO base\n   * media file.\n   * @param data {Uint8Array} the binary data of the media to be inspected\n   * @return {array} a javascript array of potentially nested box objects\n   */\n\n\n  inspectMp4 = function inspectMp4(data) {\n    var i = 0,\n        result = [],\n        view,\n        size,\n        type,\n        end,\n        box; // Convert data from Uint8Array to ArrayBuffer, to follow Dataview API\n\n    var ab = new ArrayBuffer(data.length);\n    var v = new Uint8Array(ab);\n\n    for (var z = 0; z < data.length; ++z) {\n      v[z] = data[z];\n    }\n\n    view = new DataView(ab);\n\n    while (i < data.byteLength) {\n      // parse box data\n      size = view.getUint32(i);\n      type = parseType_1(data.subarray(i + 4, i + 8));\n      end = size > 1 ? i + size : data.byteLength; // parse type-specific data\n\n      box = (parse[type] || function (data) {\n        return {\n          data: data\n        };\n      })(data.subarray(i + 8, end));\n\n      box.size = size;\n      box.type = type; // store this box and move to the next\n\n      result.push(box);\n      i = end;\n    }\n\n    return result;\n  };\n  /**\n   * Returns a textual representation of the javascript represtentation\n   * of an MP4 file. You can use it as an alternative to\n   * JSON.stringify() to compare inspected MP4s.\n   * @param inspectedMp4 {array} the parsed array of boxes in an MP4\n   * file\n   * @param depth {number} (optional) the number of ancestor boxes of\n   * the elements of inspectedMp4. Assumed to be zero if unspecified.\n   * @return {string} a text representation of the parsed MP4\n   */\n\n\n  _textifyMp = function textifyMp4(inspectedMp4, depth) {\n    var indent;\n    depth = depth || 0;\n    indent = new Array(depth * 2 + 1).join(' '); // iterate over all the boxes\n\n    return inspectedMp4.map(function (box, index) {\n      // list the box type first at the current indentation level\n      return indent + box.type + '\\n' + // the type is already included and handle child boxes separately\n      Object.keys(box).filter(function (key) {\n        return key !== 'type' && key !== 'boxes'; // output all the box properties\n      }).map(function (key) {\n        var prefix = indent + '  ' + key + ': ',\n            value = box[key]; // print out raw bytes as hexademical\n\n        if (value instanceof Uint8Array || value instanceof Uint32Array) {\n          var bytes = Array.prototype.slice.call(new Uint8Array(value.buffer, value.byteOffset, value.byteLength)).map(function (byte) {\n            return ' ' + ('00' + byte.toString(16)).slice(-2);\n          }).join('').match(/.{1,24}/g);\n\n          if (!bytes) {\n            return prefix + '<>';\n          }\n\n          if (bytes.length === 1) {\n            return prefix + '<' + bytes.join('').slice(1) + '>';\n          }\n\n          return prefix + '<\\n' + bytes.map(function (line) {\n            return indent + '  ' + line;\n          }).join('\\n') + '\\n' + indent + '  >';\n        } // stringify generic objects\n\n\n        return prefix + JSON.stringify(value, null, 2).split('\\n').map(function (line, index) {\n          if (index === 0) {\n            return line;\n          }\n\n          return indent + '  ' + line;\n        }).join('\\n');\n      }).join('\\n') + ( // recursively textify the child boxes\n      box.boxes ? '\\n' + _textifyMp(box.boxes, depth + 1) : '');\n    }).join('\\n');\n  };\n\n  var mp4Inspector = {\n    inspect: inspectMp4,\n    textify: _textifyMp,\n    parseType: parseType_1,\n    findBox: findBox_1,\n    parseTraf: parse.traf,\n    parseTfdt: parse.tfdt,\n    parseHdlr: parse.hdlr,\n    parseTfhd: parse.tfhd,\n    parseTrun: parse.trun,\n    parseSidx: parse.sidx\n  };\n\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n\n  var tagTypes = {\n    0x08: 'audio',\n    0x09: 'video',\n    0x12: 'metadata'\n  },\n      hex = function hex(val) {\n    return '0x' + ('00' + val.toString(16)).slice(-2).toUpperCase();\n  },\n      hexStringList = function hexStringList(data) {\n    var arr = [],\n        i;\n\n    while (data.byteLength > 0) {\n      i = 0;\n      arr.push(hex(data[i++]));\n      data = data.subarray(i);\n    }\n\n    return arr.join(' ');\n  },\n      parseAVCTag = function parseAVCTag(tag, obj) {\n    var avcPacketTypes = ['AVC Sequence Header', 'AVC NALU', 'AVC End-of-Sequence'],\n        compositionTime = tag[1] & parseInt('01111111', 2) << 16 | tag[2] << 8 | tag[3];\n    obj = obj || {};\n    obj.avcPacketType = avcPacketTypes[tag[0]];\n    obj.CompositionTime = tag[1] & parseInt('10000000', 2) ? -compositionTime : compositionTime;\n\n    if (tag[0] === 1) {\n      obj.nalUnitTypeRaw = hexStringList(tag.subarray(4, 100));\n    } else {\n      obj.data = hexStringList(tag.subarray(4));\n    }\n\n    return obj;\n  },\n      parseVideoTag = function parseVideoTag(tag, obj) {\n    var frameTypes = ['Unknown', 'Keyframe (for AVC, a seekable frame)', 'Inter frame (for AVC, a nonseekable frame)', 'Disposable inter frame (H.263 only)', 'Generated keyframe (reserved for server use only)', 'Video info/command frame'],\n        codecID = tag[0] & parseInt('00001111', 2);\n    obj = obj || {};\n    obj.frameType = frameTypes[(tag[0] & parseInt('11110000', 2)) >>> 4];\n    obj.codecID = codecID;\n\n    if (codecID === 7) {\n      return parseAVCTag(tag.subarray(1), obj);\n    }\n\n    return obj;\n  },\n      parseAACTag = function parseAACTag(tag, obj) {\n    var packetTypes = ['AAC Sequence Header', 'AAC Raw'];\n    obj = obj || {};\n    obj.aacPacketType = packetTypes[tag[0]];\n    obj.data = hexStringList(tag.subarray(1));\n    return obj;\n  },\n      parseAudioTag = function parseAudioTag(tag, obj) {\n    var formatTable = ['Linear PCM, platform endian', 'ADPCM', 'MP3', 'Linear PCM, little endian', 'Nellymoser 16-kHz mono', 'Nellymoser 8-kHz mono', 'Nellymoser', 'G.711 A-law logarithmic PCM', 'G.711 mu-law logarithmic PCM', 'reserved', 'AAC', 'Speex', 'MP3 8-Khz', 'Device-specific sound'],\n        samplingRateTable = ['5.5-kHz', '11-kHz', '22-kHz', '44-kHz'],\n        soundFormat = (tag[0] & parseInt('11110000', 2)) >>> 4;\n    obj = obj || {};\n    obj.soundFormat = formatTable[soundFormat];\n    obj.soundRate = samplingRateTable[(tag[0] & parseInt('00001100', 2)) >>> 2];\n    obj.soundSize = (tag[0] & parseInt('00000010', 2)) >>> 1 ? '16-bit' : '8-bit';\n    obj.soundType = tag[0] & parseInt('00000001', 2) ? 'Stereo' : 'Mono';\n\n    if (soundFormat === 10) {\n      return parseAACTag(tag.subarray(1), obj);\n    }\n\n    return obj;\n  },\n      parseGenericTag = function parseGenericTag(tag) {\n    return {\n      tagType: tagTypes[tag[0]],\n      dataSize: tag[1] << 16 | tag[2] << 8 | tag[3],\n      timestamp: tag[7] << 24 | tag[4] << 16 | tag[5] << 8 | tag[6],\n      streamID: tag[8] << 16 | tag[9] << 8 | tag[10]\n    };\n  },\n      inspectFlvTag = function inspectFlvTag(tag) {\n    var header = parseGenericTag(tag);\n\n    switch (tag[0]) {\n      case 0x08:\n        parseAudioTag(tag.subarray(11), header);\n        break;\n\n      case 0x09:\n        parseVideoTag(tag.subarray(11), header);\n        break;\n    }\n\n    return header;\n  },\n      inspectFlv = function inspectFlv(bytes) {\n    var i = 9,\n        // header\n    dataSize,\n        parsedResults = [],\n        tag; // traverse the tags\n\n    i += 4; // skip previous tag size\n\n    while (i < bytes.byteLength) {\n      dataSize = bytes[i + 1] << 16;\n      dataSize |= bytes[i + 2] << 8;\n      dataSize |= bytes[i + 3];\n      dataSize += 11;\n      tag = bytes.subarray(i, i + dataSize);\n      parsedResults.push(inspectFlvTag(tag));\n      i += dataSize + 4;\n    }\n\n    return parsedResults;\n  },\n      textifyFlv = function textifyFlv(flvTagArray) {\n    return JSON.stringify(flvTagArray, null, 2);\n  };\n\n  var flvInspector = {\n    inspectTag: inspectFlvTag,\n    inspect: inspectFlv,\n    textify: textifyFlv\n  };\n\n  var parsePid = function parsePid(packet) {\n    var pid = packet[1] & 0x1f;\n    pid <<= 8;\n    pid |= packet[2];\n    return pid;\n  };\n\n  var parsePayloadUnitStartIndicator = function parsePayloadUnitStartIndicator(packet) {\n    return !!(packet[1] & 0x40);\n  };\n\n  var parseAdaptionField = function parseAdaptionField(packet) {\n    var offset = 0; // if an adaption field is present, its length is specified by the\n    // fifth byte of the TS packet header. The adaptation field is\n    // used to add stuffing to PES packets that don't fill a complete\n    // TS packet, and to specify some forms of timing and control data\n    // that we do not currently use.\n\n    if ((packet[3] & 0x30) >>> 4 > 0x01) {\n      offset += packet[4] + 1;\n    }\n\n    return offset;\n  };\n\n  var parseType = function parseType(packet, pmtPid) {\n    var pid = parsePid(packet);\n\n    if (pid === 0) {\n      return 'pat';\n    } else if (pid === pmtPid) {\n      return 'pmt';\n    } else if (pmtPid) {\n      return 'pes';\n    }\n\n    return null;\n  };\n\n  var parsePat = function parsePat(packet) {\n    var pusi = parsePayloadUnitStartIndicator(packet);\n    var offset = 4 + parseAdaptionField(packet);\n\n    if (pusi) {\n      offset += packet[offset] + 1;\n    }\n\n    return (packet[offset + 10] & 0x1f) << 8 | packet[offset + 11];\n  };\n\n  var parsePmt = function parsePmt(packet) {\n    var programMapTable = {};\n    var pusi = parsePayloadUnitStartIndicator(packet);\n    var payloadOffset = 4 + parseAdaptionField(packet);\n\n    if (pusi) {\n      payloadOffset += packet[payloadOffset] + 1;\n    } // PMTs can be sent ahead of the time when they should actually\n    // take effect. We don't believe this should ever be the case\n    // for HLS but we'll ignore \"forward\" PMT declarations if we see\n    // them. Future PMT declarations have the current_next_indicator\n    // set to zero.\n\n\n    if (!(packet[payloadOffset + 5] & 0x01)) {\n      return;\n    }\n\n    var sectionLength, tableEnd, programInfoLength; // the mapping table ends at the end of the current section\n\n    sectionLength = (packet[payloadOffset + 1] & 0x0f) << 8 | packet[payloadOffset + 2];\n    tableEnd = 3 + sectionLength - 4; // to determine where the table is, we have to figure out how\n    // long the program info descriptors are\n\n    programInfoLength = (packet[payloadOffset + 10] & 0x0f) << 8 | packet[payloadOffset + 11]; // advance the offset to the first entry in the mapping table\n\n    var offset = 12 + programInfoLength;\n\n    while (offset < tableEnd) {\n      var i = payloadOffset + offset; // add an entry that maps the elementary_pid to the stream_type\n\n      programMapTable[(packet[i + 1] & 0x1F) << 8 | packet[i + 2]] = packet[i]; // move to the next table entry\n      // skip past the elementary stream descriptors, if present\n\n      offset += ((packet[i + 3] & 0x0F) << 8 | packet[i + 4]) + 5;\n    }\n\n    return programMapTable;\n  };\n\n  var parsePesType = function parsePesType(packet, programMapTable) {\n    var pid = parsePid(packet);\n    var type = programMapTable[pid];\n\n    switch (type) {\n      case streamTypes.H264_STREAM_TYPE:\n        return 'video';\n\n      case streamTypes.ADTS_STREAM_TYPE:\n        return 'audio';\n\n      case streamTypes.METADATA_STREAM_TYPE:\n        return 'timed-metadata';\n\n      default:\n        return null;\n    }\n  };\n\n  var parsePesTime = function parsePesTime(packet) {\n    var pusi = parsePayloadUnitStartIndicator(packet);\n\n    if (!pusi) {\n      return null;\n    }\n\n    var offset = 4 + parseAdaptionField(packet);\n\n    if (offset >= packet.byteLength) {\n      // From the H 222.0 MPEG-TS spec\n      // \"For transport stream packets carrying PES packets, stuffing is needed when there\n      //  is insufficient PES packet data to completely fill the transport stream packet\n      //  payload bytes. Stuffing is accomplished by defining an adaptation field longer than\n      //  the sum of the lengths of the data elements in it, so that the payload bytes\n      //  remaining after the adaptation field exactly accommodates the available PES packet\n      //  data.\"\n      //\n      // If the offset is >= the length of the packet, then the packet contains no data\n      // and instead is just adaption field stuffing bytes\n      return null;\n    }\n\n    var pes = null;\n    var ptsDtsFlags; // PES packets may be annotated with a PTS value, or a PTS value\n    // and a DTS value. Determine what combination of values is\n    // available to work with.\n\n    ptsDtsFlags = packet[offset + 7]; // PTS and DTS are normally stored as a 33-bit number.  Javascript\n    // performs all bitwise operations on 32-bit integers but javascript\n    // supports a much greater range (52-bits) of integer using standard\n    // mathematical operations.\n    // We construct a 31-bit value using bitwise operators over the 31\n    // most significant bits and then multiply by 4 (equal to a left-shift\n    // of 2) before we add the final 2 least significant bits of the\n    // timestamp (equal to an OR.)\n\n    if (ptsDtsFlags & 0xC0) {\n      pes = {}; // the PTS and DTS are not written out directly. For information\n      // on how they are encoded, see\n      // http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n\n      pes.pts = (packet[offset + 9] & 0x0E) << 27 | (packet[offset + 10] & 0xFF) << 20 | (packet[offset + 11] & 0xFE) << 12 | (packet[offset + 12] & 0xFF) << 5 | (packet[offset + 13] & 0xFE) >>> 3;\n      pes.pts *= 4; // Left shift by 2\n\n      pes.pts += (packet[offset + 13] & 0x06) >>> 1; // OR by the two LSBs\n\n      pes.dts = pes.pts;\n\n      if (ptsDtsFlags & 0x40) {\n        pes.dts = (packet[offset + 14] & 0x0E) << 27 | (packet[offset + 15] & 0xFF) << 20 | (packet[offset + 16] & 0xFE) << 12 | (packet[offset + 17] & 0xFF) << 5 | (packet[offset + 18] & 0xFE) >>> 3;\n        pes.dts *= 4; // Left shift by 2\n\n        pes.dts += (packet[offset + 18] & 0x06) >>> 1; // OR by the two LSBs\n      }\n    }\n\n    return pes;\n  };\n\n  var parseNalUnitType = function parseNalUnitType(type) {\n    switch (type) {\n      case 0x05:\n        return 'slice_layer_without_partitioning_rbsp_idr';\n\n      case 0x06:\n        return 'sei_rbsp';\n\n      case 0x07:\n        return 'seq_parameter_set_rbsp';\n\n      case 0x08:\n        return 'pic_parameter_set_rbsp';\n\n      case 0x09:\n        return 'access_unit_delimiter_rbsp';\n\n      default:\n        return null;\n    }\n  };\n\n  var videoPacketContainsKeyFrame = function videoPacketContainsKeyFrame(packet) {\n    var offset = 4 + parseAdaptionField(packet);\n    var frameBuffer = packet.subarray(offset);\n    var frameI = 0;\n    var frameSyncPoint = 0;\n    var foundKeyFrame = false;\n    var nalType; // advance the sync point to a NAL start, if necessary\n\n    for (; frameSyncPoint < frameBuffer.byteLength - 3; frameSyncPoint++) {\n      if (frameBuffer[frameSyncPoint + 2] === 1) {\n        // the sync point is properly aligned\n        frameI = frameSyncPoint + 5;\n        break;\n      }\n    }\n\n    while (frameI < frameBuffer.byteLength) {\n      // look at the current byte to determine if we've hit the end of\n      // a NAL unit boundary\n      switch (frameBuffer[frameI]) {\n        case 0:\n          // skip past non-sync sequences\n          if (frameBuffer[frameI - 1] !== 0) {\n            frameI += 2;\n            break;\n          } else if (frameBuffer[frameI - 2] !== 0) {\n            frameI++;\n            break;\n          }\n\n          if (frameSyncPoint + 3 !== frameI - 2) {\n            nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);\n\n            if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {\n              foundKeyFrame = true;\n            }\n          } // drop trailing zeroes\n\n\n          do {\n            frameI++;\n          } while (frameBuffer[frameI] !== 1 && frameI < frameBuffer.length);\n\n          frameSyncPoint = frameI - 2;\n          frameI += 3;\n          break;\n\n        case 1:\n          // skip past non-sync sequences\n          if (frameBuffer[frameI - 1] !== 0 || frameBuffer[frameI - 2] !== 0) {\n            frameI += 3;\n            break;\n          }\n\n          nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);\n\n          if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {\n            foundKeyFrame = true;\n          }\n\n          frameSyncPoint = frameI - 2;\n          frameI += 3;\n          break;\n\n        default:\n          // the current byte isn't a one or zero, so it cannot be part\n          // of a sync sequence\n          frameI += 3;\n          break;\n      }\n    }\n\n    frameBuffer = frameBuffer.subarray(frameSyncPoint);\n    frameI -= frameSyncPoint;\n    frameSyncPoint = 0; // parse the final nal\n\n    if (frameBuffer && frameBuffer.byteLength > 3) {\n      nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);\n\n      if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {\n        foundKeyFrame = true;\n      }\n    }\n\n    return foundKeyFrame;\n  };\n\n  var probe$1 = {\n    parseType: parseType,\n    parsePat: parsePat,\n    parsePmt: parsePmt,\n    parsePayloadUnitStartIndicator: parsePayloadUnitStartIndicator,\n    parsePesType: parsePesType,\n    parsePesTime: parsePesTime,\n    videoPacketContainsKeyFrame: videoPacketContainsKeyFrame\n  };\n\n  var handleRollover = timestampRolloverStream.handleRollover;\n  var probe = {};\n  probe.ts = probe$1;\n  probe.aac = utils;\n  var ONE_SECOND_IN_TS = clock.ONE_SECOND_IN_TS;\n  var MP2T_PACKET_LENGTH = 188,\n      // bytes\n  SYNC_BYTE = 0x47;\n  /**\n   * walks through segment data looking for pat and pmt packets to parse out\n   * program map table information\n   */\n\n  var parsePsi_ = function parsePsi_(bytes, pmt) {\n    var startIndex = 0,\n        endIndex = MP2T_PACKET_LENGTH,\n        packet,\n        type;\n\n    while (endIndex < bytes.byteLength) {\n      // Look for a pair of start and end sync bytes in the data..\n      if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n        // We found a packet\n        packet = bytes.subarray(startIndex, endIndex);\n        type = probe.ts.parseType(packet, pmt.pid);\n\n        switch (type) {\n          case 'pat':\n            pmt.pid = probe.ts.parsePat(packet);\n            break;\n\n          case 'pmt':\n            var table = probe.ts.parsePmt(packet);\n            pmt.table = pmt.table || {};\n            Object.keys(table).forEach(function (key) {\n              pmt.table[key] = table[key];\n            });\n            break;\n        }\n\n        startIndex += MP2T_PACKET_LENGTH;\n        endIndex += MP2T_PACKET_LENGTH;\n        continue;\n      } // If we get here, we have somehow become de-synchronized and we need to step\n      // forward one byte at a time until we find a pair of sync bytes that denote\n      // a packet\n\n\n      startIndex++;\n      endIndex++;\n    }\n  };\n  /**\n   * walks through the segment data from the start and end to get timing information\n   * for the first and last audio pes packets\n   */\n\n\n  var parseAudioPes_ = function parseAudioPes_(bytes, pmt, result) {\n    var startIndex = 0,\n        endIndex = MP2T_PACKET_LENGTH,\n        packet,\n        type,\n        pesType,\n        pusi,\n        parsed;\n    var endLoop = false; // Start walking from start of segment to get first audio packet\n\n    while (endIndex <= bytes.byteLength) {\n      // Look for a pair of start and end sync bytes in the data..\n      if (bytes[startIndex] === SYNC_BYTE && (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {\n        // We found a packet\n        packet = bytes.subarray(startIndex, endIndex);\n        type = probe.ts.parseType(packet, pmt.pid);\n\n        switch (type) {\n          case 'pes':\n            pesType = probe.ts.parsePesType(packet, pmt.table);\n            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n\n            if (pesType === 'audio' && pusi) {\n              parsed = probe.ts.parsePesTime(packet);\n\n              if (parsed) {\n                parsed.type = 'audio';\n                result.audio.push(parsed);\n                endLoop = true;\n              }\n            }\n\n            break;\n        }\n\n        if (endLoop) {\n          break;\n        }\n\n        startIndex += MP2T_PACKET_LENGTH;\n        endIndex += MP2T_PACKET_LENGTH;\n        continue;\n      } // If we get here, we have somehow become de-synchronized and we need to step\n      // forward one byte at a time until we find a pair of sync bytes that denote\n      // a packet\n\n\n      startIndex++;\n      endIndex++;\n    } // Start walking from end of segment to get last audio packet\n\n\n    endIndex = bytes.byteLength;\n    startIndex = endIndex - MP2T_PACKET_LENGTH;\n    endLoop = false;\n\n    while (startIndex >= 0) {\n      // Look for a pair of start and end sync bytes in the data..\n      if (bytes[startIndex] === SYNC_BYTE && (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {\n        // We found a packet\n        packet = bytes.subarray(startIndex, endIndex);\n        type = probe.ts.parseType(packet, pmt.pid);\n\n        switch (type) {\n          case 'pes':\n            pesType = probe.ts.parsePesType(packet, pmt.table);\n            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n\n            if (pesType === 'audio' && pusi) {\n              parsed = probe.ts.parsePesTime(packet);\n\n              if (parsed) {\n                parsed.type = 'audio';\n                result.audio.push(parsed);\n                endLoop = true;\n              }\n            }\n\n            break;\n        }\n\n        if (endLoop) {\n          break;\n        }\n\n        startIndex -= MP2T_PACKET_LENGTH;\n        endIndex -= MP2T_PACKET_LENGTH;\n        continue;\n      } // If we get here, we have somehow become de-synchronized and we need to step\n      // forward one byte at a time until we find a pair of sync bytes that denote\n      // a packet\n\n\n      startIndex--;\n      endIndex--;\n    }\n  };\n  /**\n   * walks through the segment data from the start and end to get timing information\n   * for the first and last video pes packets as well as timing information for the first\n   * key frame.\n   */\n\n\n  var parseVideoPes_ = function parseVideoPes_(bytes, pmt, result) {\n    var startIndex = 0,\n        endIndex = MP2T_PACKET_LENGTH,\n        packet,\n        type,\n        pesType,\n        pusi,\n        parsed,\n        frame,\n        i,\n        pes;\n    var endLoop = false;\n    var currentFrame = {\n      data: [],\n      size: 0\n    }; // Start walking from start of segment to get first video packet\n\n    while (endIndex < bytes.byteLength) {\n      // Look for a pair of start and end sync bytes in the data..\n      if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n        // We found a packet\n        packet = bytes.subarray(startIndex, endIndex);\n        type = probe.ts.parseType(packet, pmt.pid);\n\n        switch (type) {\n          case 'pes':\n            pesType = probe.ts.parsePesType(packet, pmt.table);\n            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n\n            if (pesType === 'video') {\n              if (pusi && !endLoop) {\n                parsed = probe.ts.parsePesTime(packet);\n\n                if (parsed) {\n                  parsed.type = 'video';\n                  result.video.push(parsed);\n                  endLoop = true;\n                }\n              }\n\n              if (!result.firstKeyFrame) {\n                if (pusi) {\n                  if (currentFrame.size !== 0) {\n                    frame = new Uint8Array(currentFrame.size);\n                    i = 0;\n\n                    while (currentFrame.data.length) {\n                      pes = currentFrame.data.shift();\n                      frame.set(pes, i);\n                      i += pes.byteLength;\n                    }\n\n                    if (probe.ts.videoPacketContainsKeyFrame(frame)) {\n                      var firstKeyFrame = probe.ts.parsePesTime(frame); // PTS/DTS may not be available. Simply *not* setting\n                      // the keyframe seems to work fine with HLS playback\n                      // and definitely preferable to a crash with TypeError...\n\n                      if (firstKeyFrame) {\n                        result.firstKeyFrame = firstKeyFrame;\n                        result.firstKeyFrame.type = 'video';\n                      } else {\n                        // eslint-disable-next-line\n                        console.warn('Failed to extract PTS/DTS from PES at first keyframe. ' + 'This could be an unusual TS segment, or else mux.js did not ' + 'parse your TS segment correctly. If you know your TS ' + 'segments do contain PTS/DTS on keyframes please file a bug ' + 'report! You can try ffprobe to double check for yourself.');\n                      }\n                    }\n\n                    currentFrame.size = 0;\n                  }\n                }\n\n                currentFrame.data.push(packet);\n                currentFrame.size += packet.byteLength;\n              }\n            }\n\n            break;\n        }\n\n        if (endLoop && result.firstKeyFrame) {\n          break;\n        }\n\n        startIndex += MP2T_PACKET_LENGTH;\n        endIndex += MP2T_PACKET_LENGTH;\n        continue;\n      } // If we get here, we have somehow become de-synchronized and we need to step\n      // forward one byte at a time until we find a pair of sync bytes that denote\n      // a packet\n\n\n      startIndex++;\n      endIndex++;\n    } // Start walking from end of segment to get last video packet\n\n\n    endIndex = bytes.byteLength;\n    startIndex = endIndex - MP2T_PACKET_LENGTH;\n    endLoop = false;\n\n    while (startIndex >= 0) {\n      // Look for a pair of start and end sync bytes in the data..\n      if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n        // We found a packet\n        packet = bytes.subarray(startIndex, endIndex);\n        type = probe.ts.parseType(packet, pmt.pid);\n\n        switch (type) {\n          case 'pes':\n            pesType = probe.ts.parsePesType(packet, pmt.table);\n            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n\n            if (pesType === 'video' && pusi) {\n              parsed = probe.ts.parsePesTime(packet);\n\n              if (parsed) {\n                parsed.type = 'video';\n                result.video.push(parsed);\n                endLoop = true;\n              }\n            }\n\n            break;\n        }\n\n        if (endLoop) {\n          break;\n        }\n\n        startIndex -= MP2T_PACKET_LENGTH;\n        endIndex -= MP2T_PACKET_LENGTH;\n        continue;\n      } // If we get here, we have somehow become de-synchronized and we need to step\n      // forward one byte at a time until we find a pair of sync bytes that denote\n      // a packet\n\n\n      startIndex--;\n      endIndex--;\n    }\n  };\n  /**\n   * Adjusts the timestamp information for the segment to account for\n   * rollover and convert to seconds based on pes packet timescale (90khz clock)\n   */\n\n\n  var adjustTimestamp_ = function adjustTimestamp_(segmentInfo, baseTimestamp) {\n    if (segmentInfo.audio && segmentInfo.audio.length) {\n      var audioBaseTimestamp = baseTimestamp;\n\n      if (typeof audioBaseTimestamp === 'undefined' || isNaN(audioBaseTimestamp)) {\n        audioBaseTimestamp = segmentInfo.audio[0].dts;\n      }\n\n      segmentInfo.audio.forEach(function (info) {\n        info.dts = handleRollover(info.dts, audioBaseTimestamp);\n        info.pts = handleRollover(info.pts, audioBaseTimestamp); // time in seconds\n\n        info.dtsTime = info.dts / ONE_SECOND_IN_TS;\n        info.ptsTime = info.pts / ONE_SECOND_IN_TS;\n      });\n    }\n\n    if (segmentInfo.video && segmentInfo.video.length) {\n      var videoBaseTimestamp = baseTimestamp;\n\n      if (typeof videoBaseTimestamp === 'undefined' || isNaN(videoBaseTimestamp)) {\n        videoBaseTimestamp = segmentInfo.video[0].dts;\n      }\n\n      segmentInfo.video.forEach(function (info) {\n        info.dts = handleRollover(info.dts, videoBaseTimestamp);\n        info.pts = handleRollover(info.pts, videoBaseTimestamp); // time in seconds\n\n        info.dtsTime = info.dts / ONE_SECOND_IN_TS;\n        info.ptsTime = info.pts / ONE_SECOND_IN_TS;\n      });\n\n      if (segmentInfo.firstKeyFrame) {\n        var frame = segmentInfo.firstKeyFrame;\n        frame.dts = handleRollover(frame.dts, videoBaseTimestamp);\n        frame.pts = handleRollover(frame.pts, videoBaseTimestamp); // time in seconds\n\n        frame.dtsTime = frame.dts / ONE_SECOND_IN_TS;\n        frame.ptsTime = frame.pts / ONE_SECOND_IN_TS;\n      }\n    }\n  };\n  /**\n   * inspects the aac data stream for start and end time information\n   */\n\n\n  var inspectAac_ = function inspectAac_(bytes) {\n    var endLoop = false,\n        audioCount = 0,\n        sampleRate = null,\n        timestamp = null,\n        frameSize = 0,\n        byteIndex = 0,\n        packet;\n\n    while (bytes.length - byteIndex >= 3) {\n      var type = probe.aac.parseType(bytes, byteIndex);\n\n      switch (type) {\n        case 'timed-metadata':\n          // Exit early because we don't have enough to parse\n          // the ID3 tag header\n          if (bytes.length - byteIndex < 10) {\n            endLoop = true;\n            break;\n          }\n\n          frameSize = probe.aac.parseId3TagSize(bytes, byteIndex); // Exit early if we don't have enough in the buffer\n          // to emit a full packet\n\n          if (frameSize > bytes.length) {\n            endLoop = true;\n            break;\n          }\n\n          if (timestamp === null) {\n            packet = bytes.subarray(byteIndex, byteIndex + frameSize);\n            timestamp = probe.aac.parseAacTimestamp(packet);\n          }\n\n          byteIndex += frameSize;\n          break;\n\n        case 'audio':\n          // Exit early because we don't have enough to parse\n          // the ADTS frame header\n          if (bytes.length - byteIndex < 7) {\n            endLoop = true;\n            break;\n          }\n\n          frameSize = probe.aac.parseAdtsSize(bytes, byteIndex); // Exit early if we don't have enough in the buffer\n          // to emit a full packet\n\n          if (frameSize > bytes.length) {\n            endLoop = true;\n            break;\n          }\n\n          if (sampleRate === null) {\n            packet = bytes.subarray(byteIndex, byteIndex + frameSize);\n            sampleRate = probe.aac.parseSampleRate(packet);\n          }\n\n          audioCount++;\n          byteIndex += frameSize;\n          break;\n\n        default:\n          byteIndex++;\n          break;\n      }\n\n      if (endLoop) {\n        return null;\n      }\n    }\n\n    if (sampleRate === null || timestamp === null) {\n      return null;\n    }\n\n    var audioTimescale = ONE_SECOND_IN_TS / sampleRate;\n    var result = {\n      audio: [{\n        type: 'audio',\n        dts: timestamp,\n        pts: timestamp\n      }, {\n        type: 'audio',\n        dts: timestamp + audioCount * 1024 * audioTimescale,\n        pts: timestamp + audioCount * 1024 * audioTimescale\n      }]\n    };\n    return result;\n  };\n  /**\n   * inspects the transport stream segment data for start and end time information\n   * of the audio and video tracks (when present) as well as the first key frame's\n   * start time.\n   */\n\n\n  var inspectTs_ = function inspectTs_(bytes) {\n    var pmt = {\n      pid: null,\n      table: null\n    };\n    var result = {};\n    parsePsi_(bytes, pmt);\n\n    for (var pid in pmt.table) {\n      if (pmt.table.hasOwnProperty(pid)) {\n        var type = pmt.table[pid];\n\n        switch (type) {\n          case streamTypes.H264_STREAM_TYPE:\n            result.video = [];\n            parseVideoPes_(bytes, pmt, result);\n\n            if (result.video.length === 0) {\n              delete result.video;\n            }\n\n            break;\n\n          case streamTypes.ADTS_STREAM_TYPE:\n            result.audio = [];\n            parseAudioPes_(bytes, pmt, result);\n\n            if (result.audio.length === 0) {\n              delete result.audio;\n            }\n\n            break;\n        }\n      }\n    }\n\n    return result;\n  };\n  /**\n   * Inspects segment byte data and returns an object with start and end timing information\n   *\n   * @param {Uint8Array} bytes The segment byte data\n   * @param {Number} baseTimestamp Relative reference timestamp used when adjusting frame\n   *  timestamps for rollover. This value must be in 90khz clock.\n   * @return {Object} Object containing start and end frame timing info of segment.\n   */\n\n\n  var inspect = function inspect(bytes, baseTimestamp) {\n    var isAacData = probe.aac.isLikelyAacData(bytes);\n    var result;\n\n    if (isAacData) {\n      result = inspectAac_(bytes);\n    } else {\n      result = inspectTs_(bytes);\n    }\n\n    if (!result || !result.audio && !result.video) {\n      return null;\n    }\n\n    adjustTimestamp_(result, baseTimestamp);\n    return result;\n  };\n\n  var tsInspector = {\n    inspect: inspect,\n    parseAudioPes_: parseAudioPes_\n  };\n\n  var muxjs = {\n    codecs: codecs,\n    mp4: mp4,\n    flv: flv,\n    mp2t: m2ts,\n    partial: partial\n  }; // include all the tools when the full library is required\n\n  muxjs.mp4.tools = mp4Inspector;\n  muxjs.flv.tools = flvInspector;\n  muxjs.mp2t.tools = tsInspector;\n  var lib = muxjs;\n\n  return lib;\n\n})));\n"]},"metadata":{},"sourceType":"script"}