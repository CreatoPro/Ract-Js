{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _core = require(\"./utils/core\");\n\nconst ELEMENT_NODE = 1;\nconst TEXT_NODE = 3;\nconst COMMENT_NODE = 8;\nconst DOCUMENT_NODE = 9;\n/**\n\t* Parsing and creation of EpubCFIs: http://www.idpf.org/epub/linking/cfi/epub-cfi.html\n\n\t* Implements:\n\t* - Character Offset: epubcfi(/6/4[chap01ref]!/4[body01]/10[para05]/2/1:3)\n\t* - Simple Ranges : epubcfi(/6/4[chap01ref]!/4[body01]/10[para05],/2/1:1,/3:4)\n\n\t* Does Not Implement:\n\t* - Temporal Offset (~)\n\t* - Spatial Offset (@)\n\t* - Temporal-Spatial Offset (~ + @)\n\t* - Text Location Assertion ([)\n\t* @class\n\t@param {string | Range | Node } [cfiFrom]\n\t@param {string | object} [base]\n\t@param {string} [ignoreClass] class to ignore when parsing DOM\n*/\n\nclass EpubCFI {\n  constructor(cfiFrom, base, ignoreClass) {\n    var type;\n    this.str = \"\";\n    this.base = {};\n    this.spinePos = 0; // For compatibility\n\n    this.range = false; // true || false;\n\n    this.path = {};\n    this.start = null;\n    this.end = null; // Allow instantiation without the \"new\" keyword\n\n    if (!(this instanceof EpubCFI)) {\n      return new EpubCFI(cfiFrom, base, ignoreClass);\n    }\n\n    if (typeof base === \"string\") {\n      this.base = this.parseComponent(base);\n    } else if (typeof base === \"object\" && base.steps) {\n      this.base = base;\n    }\n\n    type = this.checkType(cfiFrom);\n\n    if (type === \"string\") {\n      this.str = cfiFrom;\n      return (0, _core.extend)(this, this.parse(cfiFrom));\n    } else if (type === \"range\") {\n      return (0, _core.extend)(this, this.fromRange(cfiFrom, this.base, ignoreClass));\n    } else if (type === \"node\") {\n      return (0, _core.extend)(this, this.fromNode(cfiFrom, this.base, ignoreClass));\n    } else if (type === \"EpubCFI\" && cfiFrom.path) {\n      return cfiFrom;\n    } else if (!cfiFrom) {\n      return this;\n    } else {\n      throw new TypeError(\"not a valid argument for EpubCFI\");\n    }\n  }\n  /**\n   * Check the type of constructor input\n   * @private\n   */\n\n\n  checkType(cfi) {\n    if (this.isCfiString(cfi)) {\n      return \"string\"; // Is a range object\n    } else if (cfi && typeof cfi === \"object\" && ((0, _core.type)(cfi) === \"Range\" || typeof cfi.startContainer != \"undefined\")) {\n      return \"range\";\n    } else if (cfi && typeof cfi === \"object\" && typeof cfi.nodeType != \"undefined\") {\n      // || typeof cfi === \"function\"\n      return \"node\";\n    } else if (cfi && typeof cfi === \"object\" && cfi instanceof EpubCFI) {\n      return \"EpubCFI\";\n    } else {\n      return false;\n    }\n  }\n  /**\n   * Parse a cfi string to a CFI object representation\n   * @param {string} cfiStr\n   * @returns {object} cfi\n   */\n\n\n  parse(cfiStr) {\n    var cfi = {\n      spinePos: -1,\n      range: false,\n      base: {},\n      path: {},\n      start: null,\n      end: null\n    };\n    var baseComponent, pathComponent, range;\n\n    if (typeof cfiStr !== \"string\") {\n      return {\n        spinePos: -1\n      };\n    }\n\n    if (cfiStr.indexOf(\"epubcfi(\") === 0 && cfiStr[cfiStr.length - 1] === \")\") {\n      // Remove initial epubcfi( and ending )\n      cfiStr = cfiStr.slice(8, cfiStr.length - 1);\n    }\n\n    baseComponent = this.getChapterComponent(cfiStr); // Make sure this is a valid cfi or return\n\n    if (!baseComponent) {\n      return {\n        spinePos: -1\n      };\n    }\n\n    cfi.base = this.parseComponent(baseComponent);\n    pathComponent = this.getPathComponent(cfiStr);\n    cfi.path = this.parseComponent(pathComponent);\n    range = this.getRange(cfiStr);\n\n    if (range) {\n      cfi.range = true;\n      cfi.start = this.parseComponent(range[0]);\n      cfi.end = this.parseComponent(range[1]);\n    } // Get spine node position\n    // cfi.spineSegment = cfi.base.steps[1];\n    // Chapter segment is always the second step\n\n\n    cfi.spinePos = cfi.base.steps[1].index;\n    return cfi;\n  }\n\n  parseComponent(componentStr) {\n    var component = {\n      steps: [],\n      terminal: {\n        offset: null,\n        assertion: null\n      }\n    };\n    var parts = componentStr.split(\":\");\n    var steps = parts[0].split(\"/\");\n    var terminal;\n\n    if (parts.length > 1) {\n      terminal = parts[1];\n      component.terminal = this.parseTerminal(terminal);\n    }\n\n    if (steps[0] === \"\") {\n      steps.shift(); // Ignore the first slash\n    }\n\n    component.steps = steps.map(function (step) {\n      return this.parseStep(step);\n    }.bind(this));\n    return component;\n  }\n\n  parseStep(stepStr) {\n    var type, num, index, has_brackets, id;\n    has_brackets = stepStr.match(/\\[(.*)\\]/);\n\n    if (has_brackets && has_brackets[1]) {\n      id = has_brackets[1];\n    } //-- Check if step is a text node or element\n\n\n    num = parseInt(stepStr);\n\n    if (isNaN(num)) {\n      return;\n    }\n\n    if (num % 2 === 0) {\n      // Even = is an element\n      type = \"element\";\n      index = num / 2 - 1;\n    } else {\n      type = \"text\";\n      index = (num - 1) / 2;\n    }\n\n    return {\n      \"type\": type,\n      \"index\": index,\n      \"id\": id || null\n    };\n  }\n\n  parseTerminal(termialStr) {\n    var characterOffset, textLocationAssertion;\n    var assertion = termialStr.match(/\\[(.*)\\]/);\n\n    if (assertion && assertion[1]) {\n      characterOffset = parseInt(termialStr.split(\"[\")[0]);\n      textLocationAssertion = assertion[1];\n    } else {\n      characterOffset = parseInt(termialStr);\n    }\n\n    if (!(0, _core.isNumber)(characterOffset)) {\n      characterOffset = null;\n    }\n\n    return {\n      \"offset\": characterOffset,\n      \"assertion\": textLocationAssertion\n    };\n  }\n\n  getChapterComponent(cfiStr) {\n    var indirection = cfiStr.split(\"!\");\n    return indirection[0];\n  }\n\n  getPathComponent(cfiStr) {\n    var indirection = cfiStr.split(\"!\");\n\n    if (indirection[1]) {\n      let ranges = indirection[1].split(\",\");\n      return ranges[0];\n    }\n  }\n\n  getRange(cfiStr) {\n    var ranges = cfiStr.split(\",\");\n\n    if (ranges.length === 3) {\n      return [ranges[1], ranges[2]];\n    }\n\n    return false;\n  }\n\n  getCharecterOffsetComponent(cfiStr) {\n    var splitStr = cfiStr.split(\":\");\n    return splitStr[1] || \"\";\n  }\n\n  joinSteps(steps) {\n    if (!steps) {\n      return \"\";\n    }\n\n    return steps.map(function (part) {\n      var segment = \"\";\n\n      if (part.type === \"element\") {\n        segment += (part.index + 1) * 2;\n      }\n\n      if (part.type === \"text\") {\n        segment += 1 + 2 * part.index; // TODO: double check that this is odd\n      }\n\n      if (part.id) {\n        segment += \"[\" + part.id + \"]\";\n      }\n\n      return segment;\n    }).join(\"/\");\n  }\n\n  segmentString(segment) {\n    var segmentString = \"/\";\n    segmentString += this.joinSteps(segment.steps);\n\n    if (segment.terminal && segment.terminal.offset != null) {\n      segmentString += \":\" + segment.terminal.offset;\n    }\n\n    if (segment.terminal && segment.terminal.assertion != null) {\n      segmentString += \"[\" + segment.terminal.assertion + \"]\";\n    }\n\n    return segmentString;\n  }\n  /**\n   * Convert CFI to a epubcfi(...) string\n   * @returns {string} epubcfi\n   */\n\n\n  toString() {\n    var cfiString = \"epubcfi(\";\n    cfiString += this.segmentString(this.base);\n    cfiString += \"!\";\n    cfiString += this.segmentString(this.path); // Add Range, if present\n\n    if (this.range && this.start) {\n      cfiString += \",\";\n      cfiString += this.segmentString(this.start);\n    }\n\n    if (this.range && this.end) {\n      cfiString += \",\";\n      cfiString += this.segmentString(this.end);\n    }\n\n    cfiString += \")\";\n    return cfiString;\n  }\n  /**\n   * Compare which of two CFIs is earlier in the text\n   * @returns {number} First is earlier = -1, Second is earlier = 1, They are equal = 0\n   */\n\n\n  compare(cfiOne, cfiTwo) {\n    var stepsA, stepsB;\n    var terminalA, terminalB;\n    var rangeAStartSteps, rangeAEndSteps;\n    var rangeBEndSteps, rangeBEndSteps;\n    var rangeAStartTerminal, rangeAEndTerminal;\n    var rangeBStartTerminal, rangeBEndTerminal;\n\n    if (typeof cfiOne === \"string\") {\n      cfiOne = new EpubCFI(cfiOne);\n    }\n\n    if (typeof cfiTwo === \"string\") {\n      cfiTwo = new EpubCFI(cfiTwo);\n    } // Compare Spine Positions\n\n\n    if (cfiOne.spinePos > cfiTwo.spinePos) {\n      return 1;\n    }\n\n    if (cfiOne.spinePos < cfiTwo.spinePos) {\n      return -1;\n    }\n\n    if (cfiOne.range) {\n      stepsA = cfiOne.path.steps.concat(cfiOne.start.steps);\n      terminalA = cfiOne.start.terminal;\n    } else {\n      stepsA = cfiOne.path.steps;\n      terminalA = cfiOne.path.terminal;\n    }\n\n    if (cfiTwo.range) {\n      stepsB = cfiTwo.path.steps.concat(cfiTwo.start.steps);\n      terminalB = cfiTwo.start.terminal;\n    } else {\n      stepsB = cfiTwo.path.steps;\n      terminalB = cfiTwo.path.terminal;\n    } // Compare Each Step in the First item\n\n\n    for (var i = 0; i < stepsA.length; i++) {\n      if (!stepsA[i]) {\n        return -1;\n      }\n\n      if (!stepsB[i]) {\n        return 1;\n      }\n\n      if (stepsA[i].index > stepsB[i].index) {\n        return 1;\n      }\n\n      if (stepsA[i].index < stepsB[i].index) {\n        return -1;\n      } // Otherwise continue checking\n\n    } // All steps in First equal to Second and First is Less Specific\n\n\n    if (stepsA.length < stepsB.length) {\n      return -1;\n    } // Compare the character offset of the text node\n\n\n    if (terminalA.offset > terminalB.offset) {\n      return 1;\n    }\n\n    if (terminalA.offset < terminalB.offset) {\n      return -1;\n    } // CFI's are equal\n\n\n    return 0;\n  }\n\n  step(node) {\n    var nodeType = node.nodeType === TEXT_NODE ? \"text\" : \"element\";\n    return {\n      \"id\": node.id,\n      \"tagName\": node.tagName,\n      \"type\": nodeType,\n      \"index\": this.position(node)\n    };\n  }\n\n  filteredStep(node, ignoreClass) {\n    var filteredNode = this.filter(node, ignoreClass);\n    var nodeType; // Node filtered, so ignore\n\n    if (!filteredNode) {\n      return;\n    } // Otherwise add the filter node in\n\n\n    nodeType = filteredNode.nodeType === TEXT_NODE ? \"text\" : \"element\";\n    return {\n      \"id\": filteredNode.id,\n      \"tagName\": filteredNode.tagName,\n      \"type\": nodeType,\n      \"index\": this.filteredPosition(filteredNode, ignoreClass)\n    };\n  }\n\n  pathTo(node, offset, ignoreClass) {\n    var segment = {\n      steps: [],\n      terminal: {\n        offset: null,\n        assertion: null\n      }\n    };\n    var currentNode = node;\n    var step;\n\n    while (currentNode && currentNode.parentNode && currentNode.parentNode.nodeType != DOCUMENT_NODE) {\n      if (ignoreClass) {\n        step = this.filteredStep(currentNode, ignoreClass);\n      } else {\n        step = this.step(currentNode);\n      }\n\n      if (step) {\n        segment.steps.unshift(step);\n      }\n\n      currentNode = currentNode.parentNode;\n    }\n\n    if (offset != null && offset >= 0) {\n      segment.terminal.offset = offset; // Make sure we are getting to a textNode if there is an offset\n\n      if (segment.steps[segment.steps.length - 1].type != \"text\") {\n        segment.steps.push({\n          \"type\": \"text\",\n          \"index\": 0\n        });\n      }\n    }\n\n    return segment;\n  }\n\n  equalStep(stepA, stepB) {\n    if (!stepA || !stepB) {\n      return false;\n    }\n\n    if (stepA.index === stepB.index && stepA.id === stepB.id && stepA.type === stepB.type) {\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Create a CFI object from a Range\n   * @param {Range} range\n   * @param {string | object} base\n   * @param {string} [ignoreClass]\n   * @returns {object} cfi\n   */\n\n\n  fromRange(range, base, ignoreClass) {\n    var cfi = {\n      range: false,\n      base: {},\n      path: {},\n      start: null,\n      end: null\n    };\n    var start = range.startContainer;\n    var end = range.endContainer;\n    var startOffset = range.startOffset;\n    var endOffset = range.endOffset;\n    var needsIgnoring = false;\n\n    if (ignoreClass) {\n      // Tell pathTo if / what to ignore\n      needsIgnoring = start.ownerDocument.querySelector(\".\" + ignoreClass) != null;\n    }\n\n    if (typeof base === \"string\") {\n      cfi.base = this.parseComponent(base);\n      cfi.spinePos = cfi.base.steps[1].index;\n    } else if (typeof base === \"object\") {\n      cfi.base = base;\n    }\n\n    if (range.collapsed) {\n      if (needsIgnoring) {\n        startOffset = this.patchOffset(start, startOffset, ignoreClass);\n      }\n\n      cfi.path = this.pathTo(start, startOffset, ignoreClass);\n    } else {\n      cfi.range = true;\n\n      if (needsIgnoring) {\n        startOffset = this.patchOffset(start, startOffset, ignoreClass);\n      }\n\n      cfi.start = this.pathTo(start, startOffset, ignoreClass);\n\n      if (needsIgnoring) {\n        endOffset = this.patchOffset(end, endOffset, ignoreClass);\n      }\n\n      cfi.end = this.pathTo(end, endOffset, ignoreClass); // Create a new empty path\n\n      cfi.path = {\n        steps: [],\n        terminal: null\n      }; // Push steps that are shared between start and end to the common path\n\n      var len = cfi.start.steps.length;\n      var i;\n\n      for (i = 0; i < len; i++) {\n        if (this.equalStep(cfi.start.steps[i], cfi.end.steps[i])) {\n          if (i === len - 1) {\n            // Last step is equal, check terminals\n            if (cfi.start.terminal === cfi.end.terminal) {\n              // CFI's are equal\n              cfi.path.steps.push(cfi.start.steps[i]); // Not a range\n\n              cfi.range = false;\n            }\n          } else {\n            cfi.path.steps.push(cfi.start.steps[i]);\n          }\n        } else {\n          break;\n        }\n      }\n\n      cfi.start.steps = cfi.start.steps.slice(cfi.path.steps.length);\n      cfi.end.steps = cfi.end.steps.slice(cfi.path.steps.length); // TODO: Add Sanity check to make sure that the end if greater than the start\n    }\n\n    return cfi;\n  }\n  /**\n   * Create a CFI object from a Node\n   * @param {Node} anchor\n   * @param {string | object} base\n   * @param {string} [ignoreClass]\n   * @returns {object} cfi\n   */\n\n\n  fromNode(anchor, base, ignoreClass) {\n    var cfi = {\n      range: false,\n      base: {},\n      path: {},\n      start: null,\n      end: null\n    };\n\n    if (typeof base === \"string\") {\n      cfi.base = this.parseComponent(base);\n      cfi.spinePos = cfi.base.steps[1].index;\n    } else if (typeof base === \"object\") {\n      cfi.base = base;\n    }\n\n    cfi.path = this.pathTo(anchor, null, ignoreClass);\n    return cfi;\n  }\n\n  filter(anchor, ignoreClass) {\n    var needsIgnoring;\n    var sibling; // to join with\n\n    var parent, previousSibling, nextSibling;\n    var isText = false;\n\n    if (anchor.nodeType === TEXT_NODE) {\n      isText = true;\n      parent = anchor.parentNode;\n      needsIgnoring = anchor.parentNode.classList.contains(ignoreClass);\n    } else {\n      isText = false;\n      needsIgnoring = anchor.classList.contains(ignoreClass);\n    }\n\n    if (needsIgnoring && isText) {\n      previousSibling = parent.previousSibling;\n      nextSibling = parent.nextSibling; // If the sibling is a text node, join the nodes\n\n      if (previousSibling && previousSibling.nodeType === TEXT_NODE) {\n        sibling = previousSibling;\n      } else if (nextSibling && nextSibling.nodeType === TEXT_NODE) {\n        sibling = nextSibling;\n      }\n\n      if (sibling) {\n        return sibling;\n      } else {\n        // Parent will be ignored on next step\n        return anchor;\n      }\n    } else if (needsIgnoring && !isText) {\n      // Otherwise just skip the element node\n      return false;\n    } else {\n      // No need to filter\n      return anchor;\n    }\n  }\n\n  patchOffset(anchor, offset, ignoreClass) {\n    if (anchor.nodeType != TEXT_NODE) {\n      throw new Error(\"Anchor must be a text node\");\n    }\n\n    var curr = anchor;\n    var totalOffset = offset; // If the parent is a ignored node, get offset from it's start\n\n    if (anchor.parentNode.classList.contains(ignoreClass)) {\n      curr = anchor.parentNode;\n    }\n\n    while (curr.previousSibling) {\n      if (curr.previousSibling.nodeType === ELEMENT_NODE) {\n        // Originally a text node, so join\n        if (curr.previousSibling.classList.contains(ignoreClass)) {\n          totalOffset += curr.previousSibling.textContent.length;\n        } else {\n          break; // Normal node, dont join\n        }\n      } else {\n        // If the previous sibling is a text node, join the nodes\n        totalOffset += curr.previousSibling.textContent.length;\n      }\n\n      curr = curr.previousSibling;\n    }\n\n    return totalOffset;\n  }\n\n  normalizedMap(children, nodeType, ignoreClass) {\n    var output = {};\n    var prevIndex = -1;\n    var i,\n        len = children.length;\n    var currNodeType;\n    var prevNodeType;\n\n    for (i = 0; i < len; i++) {\n      currNodeType = children[i].nodeType; // Check if needs ignoring\n\n      if (currNodeType === ELEMENT_NODE && children[i].classList.contains(ignoreClass)) {\n        currNodeType = TEXT_NODE;\n      }\n\n      if (i > 0 && currNodeType === TEXT_NODE && prevNodeType === TEXT_NODE) {\n        // join text nodes\n        output[i] = prevIndex;\n      } else if (nodeType === currNodeType) {\n        prevIndex = prevIndex + 1;\n        output[i] = prevIndex;\n      }\n\n      prevNodeType = currNodeType;\n    }\n\n    return output;\n  }\n\n  position(anchor) {\n    var children, index;\n\n    if (anchor.nodeType === ELEMENT_NODE) {\n      children = anchor.parentNode.children;\n\n      if (!children) {\n        children = (0, _core.findChildren)(anchor.parentNode);\n      }\n\n      index = Array.prototype.indexOf.call(children, anchor);\n    } else {\n      children = this.textNodes(anchor.parentNode);\n      index = children.indexOf(anchor);\n    }\n\n    return index;\n  }\n\n  filteredPosition(anchor, ignoreClass) {\n    var children, index, map;\n\n    if (anchor.nodeType === ELEMENT_NODE) {\n      children = anchor.parentNode.children;\n      map = this.normalizedMap(children, ELEMENT_NODE, ignoreClass);\n    } else {\n      children = anchor.parentNode.childNodes; // Inside an ignored node\n\n      if (anchor.parentNode.classList.contains(ignoreClass)) {\n        anchor = anchor.parentNode;\n        children = anchor.parentNode.childNodes;\n      }\n\n      map = this.normalizedMap(children, TEXT_NODE, ignoreClass);\n    }\n\n    index = Array.prototype.indexOf.call(children, anchor);\n    return map[index];\n  }\n\n  stepsToXpath(steps) {\n    var xpath = [\".\", \"*\"];\n    steps.forEach(function (step) {\n      var position = step.index + 1;\n\n      if (step.id) {\n        xpath.push(\"*[position()=\" + position + \" and @id='\" + step.id + \"']\");\n      } else if (step.type === \"text\") {\n        xpath.push(\"text()[\" + position + \"]\");\n      } else {\n        xpath.push(\"*[\" + position + \"]\");\n      }\n    });\n    return xpath.join(\"/\");\n  }\n  /*\n  \tTo get the last step if needed:\n  \t// Get the terminal step\n  lastStep = steps[steps.length-1];\n  // Get the query string\n  query = this.stepsToQuery(steps);\n  // Find the containing element\n  startContainerParent = doc.querySelector(query);\n  // Find the text node within that element\n  if(startContainerParent && lastStep.type == \"text\") {\n  \tcontainer = startContainerParent.childNodes[lastStep.index];\n  }\n  */\n\n\n  stepsToQuerySelector(steps) {\n    var query = [\"html\"];\n    steps.forEach(function (step) {\n      var position = step.index + 1;\n\n      if (step.id) {\n        query.push(\"#\" + step.id);\n      } else if (step.type === \"text\") {// unsupported in querySelector\n        // query.push(\"text()[\" + position + \"]\");\n      } else {\n        query.push(\"*:nth-child(\" + position + \")\");\n      }\n    });\n    return query.join(\">\");\n  }\n\n  textNodes(container, ignoreClass) {\n    return Array.prototype.slice.call(container.childNodes).filter(function (node) {\n      if (node.nodeType === TEXT_NODE) {\n        return true;\n      } else if (ignoreClass && node.classList.contains(ignoreClass)) {\n        return true;\n      }\n\n      return false;\n    });\n  }\n\n  walkToNode(steps, _doc, ignoreClass) {\n    var doc = _doc || document;\n    var container = doc.documentElement;\n    var children;\n    var step;\n    var len = steps.length;\n    var i;\n\n    for (i = 0; i < len; i++) {\n      step = steps[i];\n\n      if (step.type === \"element\") {\n        //better to get a container using id as some times step.index may not be correct\n        //For ex.https://github.com/futurepress/epub.js/issues/561\n        if (step.id) {\n          container = doc.getElementById(step.id);\n        } else {\n          children = container.children || (0, _core.findChildren)(container);\n          container = children[step.index];\n        }\n      } else if (step.type === \"text\") {\n        container = this.textNodes(container, ignoreClass)[step.index];\n      }\n\n      if (!container) {\n        //Break the for loop as due to incorrect index we can get error if\n        //container is undefined so that other functionailties works fine\n        //like navigation\n        break;\n      }\n    }\n\n    return container;\n  }\n\n  findNode(steps, _doc, ignoreClass) {\n    var doc = _doc || document;\n    var container;\n    var xpath;\n\n    if (!ignoreClass && typeof doc.evaluate != \"undefined\") {\n      xpath = this.stepsToXpath(steps);\n      container = doc.evaluate(xpath, doc, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;\n    } else if (ignoreClass) {\n      container = this.walkToNode(steps, doc, ignoreClass);\n    } else {\n      container = this.walkToNode(steps, doc);\n    }\n\n    return container;\n  }\n\n  fixMiss(steps, offset, _doc, ignoreClass) {\n    var container = this.findNode(steps.slice(0, -1), _doc, ignoreClass);\n    var children = container.childNodes;\n    var map = this.normalizedMap(children, TEXT_NODE, ignoreClass);\n    var child;\n    var len;\n    var lastStepIndex = steps[steps.length - 1].index;\n\n    for (let childIndex in map) {\n      if (!map.hasOwnProperty(childIndex)) return;\n\n      if (map[childIndex] === lastStepIndex) {\n        child = children[childIndex];\n        len = child.textContent.length;\n\n        if (offset > len) {\n          offset = offset - len;\n        } else {\n          if (child.nodeType === ELEMENT_NODE) {\n            container = child.childNodes[0];\n          } else {\n            container = child;\n          }\n\n          break;\n        }\n      }\n    }\n\n    return {\n      container: container,\n      offset: offset\n    };\n  }\n  /**\n   * Creates a DOM range representing a CFI\n   * @param {document} _doc document referenced in the base\n   * @param {string} [ignoreClass]\n   * @return {Range}\n   */\n\n\n  toRange(_doc, ignoreClass) {\n    var doc = _doc || document;\n    var range;\n    var start, end, startContainer, endContainer;\n    var cfi = this;\n    var startSteps, endSteps;\n    var needsIgnoring = ignoreClass ? doc.querySelector(\".\" + ignoreClass) != null : false;\n    var missed;\n\n    if (typeof doc.createRange !== \"undefined\") {\n      range = doc.createRange();\n    } else {\n      range = new _core.RangeObject();\n    }\n\n    if (cfi.range) {\n      start = cfi.start;\n      startSteps = cfi.path.steps.concat(start.steps);\n      startContainer = this.findNode(startSteps, doc, needsIgnoring ? ignoreClass : null);\n      end = cfi.end;\n      endSteps = cfi.path.steps.concat(end.steps);\n      endContainer = this.findNode(endSteps, doc, needsIgnoring ? ignoreClass : null);\n    } else {\n      start = cfi.path;\n      startSteps = cfi.path.steps;\n      startContainer = this.findNode(cfi.path.steps, doc, needsIgnoring ? ignoreClass : null);\n    }\n\n    if (startContainer) {\n      try {\n        if (start.terminal.offset != null) {\n          range.setStart(startContainer, start.terminal.offset);\n        } else {\n          range.setStart(startContainer, 0);\n        }\n      } catch (e) {\n        missed = this.fixMiss(startSteps, start.terminal.offset, doc, needsIgnoring ? ignoreClass : null);\n        range.setStart(missed.container, missed.offset);\n      }\n    } else {\n      console.log(\"No startContainer found for\", this.toString()); // No start found\n\n      return null;\n    }\n\n    if (endContainer) {\n      try {\n        if (end.terminal.offset != null) {\n          range.setEnd(endContainer, end.terminal.offset);\n        } else {\n          range.setEnd(endContainer, 0);\n        }\n      } catch (e) {\n        missed = this.fixMiss(endSteps, cfi.end.terminal.offset, doc, needsIgnoring ? ignoreClass : null);\n        range.setEnd(missed.container, missed.offset);\n      }\n    } // doc.defaultView.getSelection().addRange(range);\n\n\n    return range;\n  }\n  /**\n   * Check if a string is wrapped with \"epubcfi()\"\n   * @param {string} str\n   * @returns {boolean}\n   */\n\n\n  isCfiString(str) {\n    if (typeof str === \"string\" && str.indexOf(\"epubcfi(\") === 0 && str[str.length - 1] === \")\") {\n      return true;\n    }\n\n    return false;\n  }\n\n  generateChapterComponent(_spineNodeIndex, _pos, id) {\n    var pos = parseInt(_pos),\n        spineNodeIndex = (_spineNodeIndex + 1) * 2,\n        cfi = \"/\" + spineNodeIndex + \"/\";\n    cfi += (pos + 1) * 2;\n\n    if (id) {\n      cfi += \"[\" + id + \"]\";\n    }\n\n    return cfi;\n  }\n  /**\n   * Collapse a CFI Range to a single CFI Position\n   * @param {boolean} [toStart=false]\n   */\n\n\n  collapse(toStart) {\n    if (!this.range) {\n      return;\n    }\n\n    this.range = false;\n\n    if (toStart) {\n      this.path.steps = this.path.steps.concat(this.start.steps);\n      this.path.terminal = this.start.terminal;\n    } else {\n      this.path.steps = this.path.steps.concat(this.end.steps);\n      this.path.terminal = this.end.terminal;\n    }\n  }\n\n}\n\nvar _default = EpubCFI;\nexports.default = _default;","map":{"version":3,"sources":["S:/REACT/Ract-Js/Frlnce/node_modules/epubjs/lib/epubcfi.js"],"names":["Object","defineProperty","exports","value","default","_core","require","ELEMENT_NODE","TEXT_NODE","COMMENT_NODE","DOCUMENT_NODE","EpubCFI","constructor","cfiFrom","base","ignoreClass","type","str","spinePos","range","path","start","end","parseComponent","steps","checkType","extend","parse","fromRange","fromNode","TypeError","cfi","isCfiString","startContainer","nodeType","cfiStr","baseComponent","pathComponent","indexOf","length","slice","getChapterComponent","getPathComponent","getRange","index","componentStr","component","terminal","offset","assertion","parts","split","parseTerminal","shift","map","step","parseStep","bind","stepStr","num","has_brackets","id","match","parseInt","isNaN","termialStr","characterOffset","textLocationAssertion","isNumber","indirection","ranges","getCharecterOffsetComponent","splitStr","joinSteps","part","segment","join","segmentString","toString","cfiString","compare","cfiOne","cfiTwo","stepsA","stepsB","terminalA","terminalB","rangeAStartSteps","rangeAEndSteps","rangeBEndSteps","rangeAStartTerminal","rangeAEndTerminal","rangeBStartTerminal","rangeBEndTerminal","concat","i","node","tagName","position","filteredStep","filteredNode","filter","filteredPosition","pathTo","currentNode","parentNode","unshift","push","equalStep","stepA","stepB","endContainer","startOffset","endOffset","needsIgnoring","ownerDocument","querySelector","collapsed","patchOffset","len","anchor","sibling","parent","previousSibling","nextSibling","isText","classList","contains","Error","curr","totalOffset","textContent","normalizedMap","children","output","prevIndex","currNodeType","prevNodeType","findChildren","Array","prototype","call","textNodes","childNodes","stepsToXpath","xpath","forEach","stepsToQuerySelector","query","container","walkToNode","_doc","doc","document","documentElement","getElementById","findNode","evaluate","XPathResult","FIRST_ORDERED_NODE_TYPE","singleNodeValue","fixMiss","child","lastStepIndex","childIndex","hasOwnProperty","toRange","startSteps","endSteps","missed","createRange","RangeObject","setStart","e","console","log","setEnd","generateChapterComponent","_spineNodeIndex","_pos","pos","spineNodeIndex","collapse","toStart","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _core = require(\"./utils/core\");\n\nconst ELEMENT_NODE = 1;\nconst TEXT_NODE = 3;\nconst COMMENT_NODE = 8;\nconst DOCUMENT_NODE = 9;\n/**\n\t* Parsing and creation of EpubCFIs: http://www.idpf.org/epub/linking/cfi/epub-cfi.html\n\n\t* Implements:\n\t* - Character Offset: epubcfi(/6/4[chap01ref]!/4[body01]/10[para05]/2/1:3)\n\t* - Simple Ranges : epubcfi(/6/4[chap01ref]!/4[body01]/10[para05],/2/1:1,/3:4)\n\n\t* Does Not Implement:\n\t* - Temporal Offset (~)\n\t* - Spatial Offset (@)\n\t* - Temporal-Spatial Offset (~ + @)\n\t* - Text Location Assertion ([)\n\t* @class\n\t@param {string | Range | Node } [cfiFrom]\n\t@param {string | object} [base]\n\t@param {string} [ignoreClass] class to ignore when parsing DOM\n*/\n\nclass EpubCFI {\n  constructor(cfiFrom, base, ignoreClass) {\n    var type;\n    this.str = \"\";\n    this.base = {};\n    this.spinePos = 0; // For compatibility\n\n    this.range = false; // true || false;\n\n    this.path = {};\n    this.start = null;\n    this.end = null; // Allow instantiation without the \"new\" keyword\n\n    if (!(this instanceof EpubCFI)) {\n      return new EpubCFI(cfiFrom, base, ignoreClass);\n    }\n\n    if (typeof base === \"string\") {\n      this.base = this.parseComponent(base);\n    } else if (typeof base === \"object\" && base.steps) {\n      this.base = base;\n    }\n\n    type = this.checkType(cfiFrom);\n\n    if (type === \"string\") {\n      this.str = cfiFrom;\n      return (0, _core.extend)(this, this.parse(cfiFrom));\n    } else if (type === \"range\") {\n      return (0, _core.extend)(this, this.fromRange(cfiFrom, this.base, ignoreClass));\n    } else if (type === \"node\") {\n      return (0, _core.extend)(this, this.fromNode(cfiFrom, this.base, ignoreClass));\n    } else if (type === \"EpubCFI\" && cfiFrom.path) {\n      return cfiFrom;\n    } else if (!cfiFrom) {\n      return this;\n    } else {\n      throw new TypeError(\"not a valid argument for EpubCFI\");\n    }\n  }\n  /**\n   * Check the type of constructor input\n   * @private\n   */\n\n\n  checkType(cfi) {\n    if (this.isCfiString(cfi)) {\n      return \"string\"; // Is a range object\n    } else if (cfi && typeof cfi === \"object\" && ((0, _core.type)(cfi) === \"Range\" || typeof cfi.startContainer != \"undefined\")) {\n      return \"range\";\n    } else if (cfi && typeof cfi === \"object\" && typeof cfi.nodeType != \"undefined\") {\n      // || typeof cfi === \"function\"\n      return \"node\";\n    } else if (cfi && typeof cfi === \"object\" && cfi instanceof EpubCFI) {\n      return \"EpubCFI\";\n    } else {\n      return false;\n    }\n  }\n  /**\n   * Parse a cfi string to a CFI object representation\n   * @param {string} cfiStr\n   * @returns {object} cfi\n   */\n\n\n  parse(cfiStr) {\n    var cfi = {\n      spinePos: -1,\n      range: false,\n      base: {},\n      path: {},\n      start: null,\n      end: null\n    };\n    var baseComponent, pathComponent, range;\n\n    if (typeof cfiStr !== \"string\") {\n      return {\n        spinePos: -1\n      };\n    }\n\n    if (cfiStr.indexOf(\"epubcfi(\") === 0 && cfiStr[cfiStr.length - 1] === \")\") {\n      // Remove initial epubcfi( and ending )\n      cfiStr = cfiStr.slice(8, cfiStr.length - 1);\n    }\n\n    baseComponent = this.getChapterComponent(cfiStr); // Make sure this is a valid cfi or return\n\n    if (!baseComponent) {\n      return {\n        spinePos: -1\n      };\n    }\n\n    cfi.base = this.parseComponent(baseComponent);\n    pathComponent = this.getPathComponent(cfiStr);\n    cfi.path = this.parseComponent(pathComponent);\n    range = this.getRange(cfiStr);\n\n    if (range) {\n      cfi.range = true;\n      cfi.start = this.parseComponent(range[0]);\n      cfi.end = this.parseComponent(range[1]);\n    } // Get spine node position\n    // cfi.spineSegment = cfi.base.steps[1];\n    // Chapter segment is always the second step\n\n\n    cfi.spinePos = cfi.base.steps[1].index;\n    return cfi;\n  }\n\n  parseComponent(componentStr) {\n    var component = {\n      steps: [],\n      terminal: {\n        offset: null,\n        assertion: null\n      }\n    };\n    var parts = componentStr.split(\":\");\n    var steps = parts[0].split(\"/\");\n    var terminal;\n\n    if (parts.length > 1) {\n      terminal = parts[1];\n      component.terminal = this.parseTerminal(terminal);\n    }\n\n    if (steps[0] === \"\") {\n      steps.shift(); // Ignore the first slash\n    }\n\n    component.steps = steps.map(function (step) {\n      return this.parseStep(step);\n    }.bind(this));\n    return component;\n  }\n\n  parseStep(stepStr) {\n    var type, num, index, has_brackets, id;\n    has_brackets = stepStr.match(/\\[(.*)\\]/);\n\n    if (has_brackets && has_brackets[1]) {\n      id = has_brackets[1];\n    } //-- Check if step is a text node or element\n\n\n    num = parseInt(stepStr);\n\n    if (isNaN(num)) {\n      return;\n    }\n\n    if (num % 2 === 0) {\n      // Even = is an element\n      type = \"element\";\n      index = num / 2 - 1;\n    } else {\n      type = \"text\";\n      index = (num - 1) / 2;\n    }\n\n    return {\n      \"type\": type,\n      \"index\": index,\n      \"id\": id || null\n    };\n  }\n\n  parseTerminal(termialStr) {\n    var characterOffset, textLocationAssertion;\n    var assertion = termialStr.match(/\\[(.*)\\]/);\n\n    if (assertion && assertion[1]) {\n      characterOffset = parseInt(termialStr.split(\"[\")[0]);\n      textLocationAssertion = assertion[1];\n    } else {\n      characterOffset = parseInt(termialStr);\n    }\n\n    if (!(0, _core.isNumber)(characterOffset)) {\n      characterOffset = null;\n    }\n\n    return {\n      \"offset\": characterOffset,\n      \"assertion\": textLocationAssertion\n    };\n  }\n\n  getChapterComponent(cfiStr) {\n    var indirection = cfiStr.split(\"!\");\n    return indirection[0];\n  }\n\n  getPathComponent(cfiStr) {\n    var indirection = cfiStr.split(\"!\");\n\n    if (indirection[1]) {\n      let ranges = indirection[1].split(\",\");\n      return ranges[0];\n    }\n  }\n\n  getRange(cfiStr) {\n    var ranges = cfiStr.split(\",\");\n\n    if (ranges.length === 3) {\n      return [ranges[1], ranges[2]];\n    }\n\n    return false;\n  }\n\n  getCharecterOffsetComponent(cfiStr) {\n    var splitStr = cfiStr.split(\":\");\n    return splitStr[1] || \"\";\n  }\n\n  joinSteps(steps) {\n    if (!steps) {\n      return \"\";\n    }\n\n    return steps.map(function (part) {\n      var segment = \"\";\n\n      if (part.type === \"element\") {\n        segment += (part.index + 1) * 2;\n      }\n\n      if (part.type === \"text\") {\n        segment += 1 + 2 * part.index; // TODO: double check that this is odd\n      }\n\n      if (part.id) {\n        segment += \"[\" + part.id + \"]\";\n      }\n\n      return segment;\n    }).join(\"/\");\n  }\n\n  segmentString(segment) {\n    var segmentString = \"/\";\n    segmentString += this.joinSteps(segment.steps);\n\n    if (segment.terminal && segment.terminal.offset != null) {\n      segmentString += \":\" + segment.terminal.offset;\n    }\n\n    if (segment.terminal && segment.terminal.assertion != null) {\n      segmentString += \"[\" + segment.terminal.assertion + \"]\";\n    }\n\n    return segmentString;\n  }\n  /**\n   * Convert CFI to a epubcfi(...) string\n   * @returns {string} epubcfi\n   */\n\n\n  toString() {\n    var cfiString = \"epubcfi(\";\n    cfiString += this.segmentString(this.base);\n    cfiString += \"!\";\n    cfiString += this.segmentString(this.path); // Add Range, if present\n\n    if (this.range && this.start) {\n      cfiString += \",\";\n      cfiString += this.segmentString(this.start);\n    }\n\n    if (this.range && this.end) {\n      cfiString += \",\";\n      cfiString += this.segmentString(this.end);\n    }\n\n    cfiString += \")\";\n    return cfiString;\n  }\n  /**\n   * Compare which of two CFIs is earlier in the text\n   * @returns {number} First is earlier = -1, Second is earlier = 1, They are equal = 0\n   */\n\n\n  compare(cfiOne, cfiTwo) {\n    var stepsA, stepsB;\n    var terminalA, terminalB;\n    var rangeAStartSteps, rangeAEndSteps;\n    var rangeBEndSteps, rangeBEndSteps;\n    var rangeAStartTerminal, rangeAEndTerminal;\n    var rangeBStartTerminal, rangeBEndTerminal;\n\n    if (typeof cfiOne === \"string\") {\n      cfiOne = new EpubCFI(cfiOne);\n    }\n\n    if (typeof cfiTwo === \"string\") {\n      cfiTwo = new EpubCFI(cfiTwo);\n    } // Compare Spine Positions\n\n\n    if (cfiOne.spinePos > cfiTwo.spinePos) {\n      return 1;\n    }\n\n    if (cfiOne.spinePos < cfiTwo.spinePos) {\n      return -1;\n    }\n\n    if (cfiOne.range) {\n      stepsA = cfiOne.path.steps.concat(cfiOne.start.steps);\n      terminalA = cfiOne.start.terminal;\n    } else {\n      stepsA = cfiOne.path.steps;\n      terminalA = cfiOne.path.terminal;\n    }\n\n    if (cfiTwo.range) {\n      stepsB = cfiTwo.path.steps.concat(cfiTwo.start.steps);\n      terminalB = cfiTwo.start.terminal;\n    } else {\n      stepsB = cfiTwo.path.steps;\n      terminalB = cfiTwo.path.terminal;\n    } // Compare Each Step in the First item\n\n\n    for (var i = 0; i < stepsA.length; i++) {\n      if (!stepsA[i]) {\n        return -1;\n      }\n\n      if (!stepsB[i]) {\n        return 1;\n      }\n\n      if (stepsA[i].index > stepsB[i].index) {\n        return 1;\n      }\n\n      if (stepsA[i].index < stepsB[i].index) {\n        return -1;\n      } // Otherwise continue checking\n\n    } // All steps in First equal to Second and First is Less Specific\n\n\n    if (stepsA.length < stepsB.length) {\n      return -1;\n    } // Compare the character offset of the text node\n\n\n    if (terminalA.offset > terminalB.offset) {\n      return 1;\n    }\n\n    if (terminalA.offset < terminalB.offset) {\n      return -1;\n    } // CFI's are equal\n\n\n    return 0;\n  }\n\n  step(node) {\n    var nodeType = node.nodeType === TEXT_NODE ? \"text\" : \"element\";\n    return {\n      \"id\": node.id,\n      \"tagName\": node.tagName,\n      \"type\": nodeType,\n      \"index\": this.position(node)\n    };\n  }\n\n  filteredStep(node, ignoreClass) {\n    var filteredNode = this.filter(node, ignoreClass);\n    var nodeType; // Node filtered, so ignore\n\n    if (!filteredNode) {\n      return;\n    } // Otherwise add the filter node in\n\n\n    nodeType = filteredNode.nodeType === TEXT_NODE ? \"text\" : \"element\";\n    return {\n      \"id\": filteredNode.id,\n      \"tagName\": filteredNode.tagName,\n      \"type\": nodeType,\n      \"index\": this.filteredPosition(filteredNode, ignoreClass)\n    };\n  }\n\n  pathTo(node, offset, ignoreClass) {\n    var segment = {\n      steps: [],\n      terminal: {\n        offset: null,\n        assertion: null\n      }\n    };\n    var currentNode = node;\n    var step;\n\n    while (currentNode && currentNode.parentNode && currentNode.parentNode.nodeType != DOCUMENT_NODE) {\n      if (ignoreClass) {\n        step = this.filteredStep(currentNode, ignoreClass);\n      } else {\n        step = this.step(currentNode);\n      }\n\n      if (step) {\n        segment.steps.unshift(step);\n      }\n\n      currentNode = currentNode.parentNode;\n    }\n\n    if (offset != null && offset >= 0) {\n      segment.terminal.offset = offset; // Make sure we are getting to a textNode if there is an offset\n\n      if (segment.steps[segment.steps.length - 1].type != \"text\") {\n        segment.steps.push({\n          \"type\": \"text\",\n          \"index\": 0\n        });\n      }\n    }\n\n    return segment;\n  }\n\n  equalStep(stepA, stepB) {\n    if (!stepA || !stepB) {\n      return false;\n    }\n\n    if (stepA.index === stepB.index && stepA.id === stepB.id && stepA.type === stepB.type) {\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Create a CFI object from a Range\n   * @param {Range} range\n   * @param {string | object} base\n   * @param {string} [ignoreClass]\n   * @returns {object} cfi\n   */\n\n\n  fromRange(range, base, ignoreClass) {\n    var cfi = {\n      range: false,\n      base: {},\n      path: {},\n      start: null,\n      end: null\n    };\n    var start = range.startContainer;\n    var end = range.endContainer;\n    var startOffset = range.startOffset;\n    var endOffset = range.endOffset;\n    var needsIgnoring = false;\n\n    if (ignoreClass) {\n      // Tell pathTo if / what to ignore\n      needsIgnoring = start.ownerDocument.querySelector(\".\" + ignoreClass) != null;\n    }\n\n    if (typeof base === \"string\") {\n      cfi.base = this.parseComponent(base);\n      cfi.spinePos = cfi.base.steps[1].index;\n    } else if (typeof base === \"object\") {\n      cfi.base = base;\n    }\n\n    if (range.collapsed) {\n      if (needsIgnoring) {\n        startOffset = this.patchOffset(start, startOffset, ignoreClass);\n      }\n\n      cfi.path = this.pathTo(start, startOffset, ignoreClass);\n    } else {\n      cfi.range = true;\n\n      if (needsIgnoring) {\n        startOffset = this.patchOffset(start, startOffset, ignoreClass);\n      }\n\n      cfi.start = this.pathTo(start, startOffset, ignoreClass);\n\n      if (needsIgnoring) {\n        endOffset = this.patchOffset(end, endOffset, ignoreClass);\n      }\n\n      cfi.end = this.pathTo(end, endOffset, ignoreClass); // Create a new empty path\n\n      cfi.path = {\n        steps: [],\n        terminal: null\n      }; // Push steps that are shared between start and end to the common path\n\n      var len = cfi.start.steps.length;\n      var i;\n\n      for (i = 0; i < len; i++) {\n        if (this.equalStep(cfi.start.steps[i], cfi.end.steps[i])) {\n          if (i === len - 1) {\n            // Last step is equal, check terminals\n            if (cfi.start.terminal === cfi.end.terminal) {\n              // CFI's are equal\n              cfi.path.steps.push(cfi.start.steps[i]); // Not a range\n\n              cfi.range = false;\n            }\n          } else {\n            cfi.path.steps.push(cfi.start.steps[i]);\n          }\n        } else {\n          break;\n        }\n      }\n\n      cfi.start.steps = cfi.start.steps.slice(cfi.path.steps.length);\n      cfi.end.steps = cfi.end.steps.slice(cfi.path.steps.length); // TODO: Add Sanity check to make sure that the end if greater than the start\n    }\n\n    return cfi;\n  }\n  /**\n   * Create a CFI object from a Node\n   * @param {Node} anchor\n   * @param {string | object} base\n   * @param {string} [ignoreClass]\n   * @returns {object} cfi\n   */\n\n\n  fromNode(anchor, base, ignoreClass) {\n    var cfi = {\n      range: false,\n      base: {},\n      path: {},\n      start: null,\n      end: null\n    };\n\n    if (typeof base === \"string\") {\n      cfi.base = this.parseComponent(base);\n      cfi.spinePos = cfi.base.steps[1].index;\n    } else if (typeof base === \"object\") {\n      cfi.base = base;\n    }\n\n    cfi.path = this.pathTo(anchor, null, ignoreClass);\n    return cfi;\n  }\n\n  filter(anchor, ignoreClass) {\n    var needsIgnoring;\n    var sibling; // to join with\n\n    var parent, previousSibling, nextSibling;\n    var isText = false;\n\n    if (anchor.nodeType === TEXT_NODE) {\n      isText = true;\n      parent = anchor.parentNode;\n      needsIgnoring = anchor.parentNode.classList.contains(ignoreClass);\n    } else {\n      isText = false;\n      needsIgnoring = anchor.classList.contains(ignoreClass);\n    }\n\n    if (needsIgnoring && isText) {\n      previousSibling = parent.previousSibling;\n      nextSibling = parent.nextSibling; // If the sibling is a text node, join the nodes\n\n      if (previousSibling && previousSibling.nodeType === TEXT_NODE) {\n        sibling = previousSibling;\n      } else if (nextSibling && nextSibling.nodeType === TEXT_NODE) {\n        sibling = nextSibling;\n      }\n\n      if (sibling) {\n        return sibling;\n      } else {\n        // Parent will be ignored on next step\n        return anchor;\n      }\n    } else if (needsIgnoring && !isText) {\n      // Otherwise just skip the element node\n      return false;\n    } else {\n      // No need to filter\n      return anchor;\n    }\n  }\n\n  patchOffset(anchor, offset, ignoreClass) {\n    if (anchor.nodeType != TEXT_NODE) {\n      throw new Error(\"Anchor must be a text node\");\n    }\n\n    var curr = anchor;\n    var totalOffset = offset; // If the parent is a ignored node, get offset from it's start\n\n    if (anchor.parentNode.classList.contains(ignoreClass)) {\n      curr = anchor.parentNode;\n    }\n\n    while (curr.previousSibling) {\n      if (curr.previousSibling.nodeType === ELEMENT_NODE) {\n        // Originally a text node, so join\n        if (curr.previousSibling.classList.contains(ignoreClass)) {\n          totalOffset += curr.previousSibling.textContent.length;\n        } else {\n          break; // Normal node, dont join\n        }\n      } else {\n        // If the previous sibling is a text node, join the nodes\n        totalOffset += curr.previousSibling.textContent.length;\n      }\n\n      curr = curr.previousSibling;\n    }\n\n    return totalOffset;\n  }\n\n  normalizedMap(children, nodeType, ignoreClass) {\n    var output = {};\n    var prevIndex = -1;\n    var i,\n        len = children.length;\n    var currNodeType;\n    var prevNodeType;\n\n    for (i = 0; i < len; i++) {\n      currNodeType = children[i].nodeType; // Check if needs ignoring\n\n      if (currNodeType === ELEMENT_NODE && children[i].classList.contains(ignoreClass)) {\n        currNodeType = TEXT_NODE;\n      }\n\n      if (i > 0 && currNodeType === TEXT_NODE && prevNodeType === TEXT_NODE) {\n        // join text nodes\n        output[i] = prevIndex;\n      } else if (nodeType === currNodeType) {\n        prevIndex = prevIndex + 1;\n        output[i] = prevIndex;\n      }\n\n      prevNodeType = currNodeType;\n    }\n\n    return output;\n  }\n\n  position(anchor) {\n    var children, index;\n\n    if (anchor.nodeType === ELEMENT_NODE) {\n      children = anchor.parentNode.children;\n\n      if (!children) {\n        children = (0, _core.findChildren)(anchor.parentNode);\n      }\n\n      index = Array.prototype.indexOf.call(children, anchor);\n    } else {\n      children = this.textNodes(anchor.parentNode);\n      index = children.indexOf(anchor);\n    }\n\n    return index;\n  }\n\n  filteredPosition(anchor, ignoreClass) {\n    var children, index, map;\n\n    if (anchor.nodeType === ELEMENT_NODE) {\n      children = anchor.parentNode.children;\n      map = this.normalizedMap(children, ELEMENT_NODE, ignoreClass);\n    } else {\n      children = anchor.parentNode.childNodes; // Inside an ignored node\n\n      if (anchor.parentNode.classList.contains(ignoreClass)) {\n        anchor = anchor.parentNode;\n        children = anchor.parentNode.childNodes;\n      }\n\n      map = this.normalizedMap(children, TEXT_NODE, ignoreClass);\n    }\n\n    index = Array.prototype.indexOf.call(children, anchor);\n    return map[index];\n  }\n\n  stepsToXpath(steps) {\n    var xpath = [\".\", \"*\"];\n    steps.forEach(function (step) {\n      var position = step.index + 1;\n\n      if (step.id) {\n        xpath.push(\"*[position()=\" + position + \" and @id='\" + step.id + \"']\");\n      } else if (step.type === \"text\") {\n        xpath.push(\"text()[\" + position + \"]\");\n      } else {\n        xpath.push(\"*[\" + position + \"]\");\n      }\n    });\n    return xpath.join(\"/\");\n  }\n  /*\n  \tTo get the last step if needed:\n  \t// Get the terminal step\n  lastStep = steps[steps.length-1];\n  // Get the query string\n  query = this.stepsToQuery(steps);\n  // Find the containing element\n  startContainerParent = doc.querySelector(query);\n  // Find the text node within that element\n  if(startContainerParent && lastStep.type == \"text\") {\n  \tcontainer = startContainerParent.childNodes[lastStep.index];\n  }\n  */\n\n\n  stepsToQuerySelector(steps) {\n    var query = [\"html\"];\n    steps.forEach(function (step) {\n      var position = step.index + 1;\n\n      if (step.id) {\n        query.push(\"#\" + step.id);\n      } else if (step.type === \"text\") {// unsupported in querySelector\n        // query.push(\"text()[\" + position + \"]\");\n      } else {\n        query.push(\"*:nth-child(\" + position + \")\");\n      }\n    });\n    return query.join(\">\");\n  }\n\n  textNodes(container, ignoreClass) {\n    return Array.prototype.slice.call(container.childNodes).filter(function (node) {\n      if (node.nodeType === TEXT_NODE) {\n        return true;\n      } else if (ignoreClass && node.classList.contains(ignoreClass)) {\n        return true;\n      }\n\n      return false;\n    });\n  }\n\n  walkToNode(steps, _doc, ignoreClass) {\n    var doc = _doc || document;\n    var container = doc.documentElement;\n    var children;\n    var step;\n    var len = steps.length;\n    var i;\n\n    for (i = 0; i < len; i++) {\n      step = steps[i];\n\n      if (step.type === \"element\") {\n        //better to get a container using id as some times step.index may not be correct\n        //For ex.https://github.com/futurepress/epub.js/issues/561\n        if (step.id) {\n          container = doc.getElementById(step.id);\n        } else {\n          children = container.children || (0, _core.findChildren)(container);\n          container = children[step.index];\n        }\n      } else if (step.type === \"text\") {\n        container = this.textNodes(container, ignoreClass)[step.index];\n      }\n\n      if (!container) {\n        //Break the for loop as due to incorrect index we can get error if\n        //container is undefined so that other functionailties works fine\n        //like navigation\n        break;\n      }\n    }\n\n    return container;\n  }\n\n  findNode(steps, _doc, ignoreClass) {\n    var doc = _doc || document;\n    var container;\n    var xpath;\n\n    if (!ignoreClass && typeof doc.evaluate != \"undefined\") {\n      xpath = this.stepsToXpath(steps);\n      container = doc.evaluate(xpath, doc, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;\n    } else if (ignoreClass) {\n      container = this.walkToNode(steps, doc, ignoreClass);\n    } else {\n      container = this.walkToNode(steps, doc);\n    }\n\n    return container;\n  }\n\n  fixMiss(steps, offset, _doc, ignoreClass) {\n    var container = this.findNode(steps.slice(0, -1), _doc, ignoreClass);\n    var children = container.childNodes;\n    var map = this.normalizedMap(children, TEXT_NODE, ignoreClass);\n    var child;\n    var len;\n    var lastStepIndex = steps[steps.length - 1].index;\n\n    for (let childIndex in map) {\n      if (!map.hasOwnProperty(childIndex)) return;\n\n      if (map[childIndex] === lastStepIndex) {\n        child = children[childIndex];\n        len = child.textContent.length;\n\n        if (offset > len) {\n          offset = offset - len;\n        } else {\n          if (child.nodeType === ELEMENT_NODE) {\n            container = child.childNodes[0];\n          } else {\n            container = child;\n          }\n\n          break;\n        }\n      }\n    }\n\n    return {\n      container: container,\n      offset: offset\n    };\n  }\n  /**\n   * Creates a DOM range representing a CFI\n   * @param {document} _doc document referenced in the base\n   * @param {string} [ignoreClass]\n   * @return {Range}\n   */\n\n\n  toRange(_doc, ignoreClass) {\n    var doc = _doc || document;\n    var range;\n    var start, end, startContainer, endContainer;\n    var cfi = this;\n    var startSteps, endSteps;\n    var needsIgnoring = ignoreClass ? doc.querySelector(\".\" + ignoreClass) != null : false;\n    var missed;\n\n    if (typeof doc.createRange !== \"undefined\") {\n      range = doc.createRange();\n    } else {\n      range = new _core.RangeObject();\n    }\n\n    if (cfi.range) {\n      start = cfi.start;\n      startSteps = cfi.path.steps.concat(start.steps);\n      startContainer = this.findNode(startSteps, doc, needsIgnoring ? ignoreClass : null);\n      end = cfi.end;\n      endSteps = cfi.path.steps.concat(end.steps);\n      endContainer = this.findNode(endSteps, doc, needsIgnoring ? ignoreClass : null);\n    } else {\n      start = cfi.path;\n      startSteps = cfi.path.steps;\n      startContainer = this.findNode(cfi.path.steps, doc, needsIgnoring ? ignoreClass : null);\n    }\n\n    if (startContainer) {\n      try {\n        if (start.terminal.offset != null) {\n          range.setStart(startContainer, start.terminal.offset);\n        } else {\n          range.setStart(startContainer, 0);\n        }\n      } catch (e) {\n        missed = this.fixMiss(startSteps, start.terminal.offset, doc, needsIgnoring ? ignoreClass : null);\n        range.setStart(missed.container, missed.offset);\n      }\n    } else {\n      console.log(\"No startContainer found for\", this.toString()); // No start found\n\n      return null;\n    }\n\n    if (endContainer) {\n      try {\n        if (end.terminal.offset != null) {\n          range.setEnd(endContainer, end.terminal.offset);\n        } else {\n          range.setEnd(endContainer, 0);\n        }\n      } catch (e) {\n        missed = this.fixMiss(endSteps, cfi.end.terminal.offset, doc, needsIgnoring ? ignoreClass : null);\n        range.setEnd(missed.container, missed.offset);\n      }\n    } // doc.defaultView.getSelection().addRange(range);\n\n\n    return range;\n  }\n  /**\n   * Check if a string is wrapped with \"epubcfi()\"\n   * @param {string} str\n   * @returns {boolean}\n   */\n\n\n  isCfiString(str) {\n    if (typeof str === \"string\" && str.indexOf(\"epubcfi(\") === 0 && str[str.length - 1] === \")\") {\n      return true;\n    }\n\n    return false;\n  }\n\n  generateChapterComponent(_spineNodeIndex, _pos, id) {\n    var pos = parseInt(_pos),\n        spineNodeIndex = (_spineNodeIndex + 1) * 2,\n        cfi = \"/\" + spineNodeIndex + \"/\";\n    cfi += (pos + 1) * 2;\n\n    if (id) {\n      cfi += \"[\" + id + \"]\";\n    }\n\n    return cfi;\n  }\n  /**\n   * Collapse a CFI Range to a single CFI Position\n   * @param {boolean} [toStart=false]\n   */\n\n\n  collapse(toStart) {\n    if (!this.range) {\n      return;\n    }\n\n    this.range = false;\n\n    if (toStart) {\n      this.path.steps = this.path.steps.concat(this.start.steps);\n      this.path.terminal = this.start.terminal;\n    } else {\n      this.path.steps = this.path.steps.concat(this.end.steps);\n      this.path.terminal = this.end.terminal;\n    }\n  }\n\n}\n\nvar _default = EpubCFI;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}