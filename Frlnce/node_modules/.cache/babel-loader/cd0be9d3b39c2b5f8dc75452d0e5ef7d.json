{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.proxyMouse = proxyMouse;\nexports.clone = clone; // import 'babelify/polyfill'; // needed for Object.assign\n\nexports.default = {\n  proxyMouse: proxyMouse\n};\n/**\n * Start proxying all mouse events that occur on the target node to each node in\n * a set of tracked nodes.\n *\n * The items in tracked do not strictly have to be DOM Nodes, but they do have\n * to have dispatchEvent, getBoundingClientRect, and getClientRects methods.\n *\n * @param target {Node} The node on which to listen for mouse events.\n * @param tracked {Node[]} A (possibly mutable) array of nodes to which to proxy\n *                         events.\n */\n\nfunction proxyMouse(target, tracked) {\n  function dispatch(e) {\n    // We walk through the set of tracked elements in reverse order so that\n    // events are sent to those most recently added first.\n    //\n    // This is the least surprising behaviour as it simulates the way the\n    // browser would work if items added later were drawn \"on top of\"\n    // earlier ones.\n    for (var i = tracked.length - 1; i >= 0; i--) {\n      var t = tracked[i];\n      var x = e.clientX;\n      var y = e.clientY;\n\n      if (e.touches && e.touches.length) {\n        x = e.touches[0].clientX;\n        y = e.touches[0].clientY;\n      }\n\n      if (!contains(t, target, x, y)) {\n        continue;\n      } // The event targets this mark, so dispatch a cloned event:\n\n\n      t.dispatchEvent(clone(e)); // We only dispatch the cloned event to the first matching mark.\n\n      break;\n    }\n  }\n\n  if (target.nodeName === \"iframe\" || target.nodeName === \"IFRAME\") {\n    try {\n      // Try to get the contents if same domain\n      this.target = target.contentDocument;\n    } catch (err) {\n      this.target = target;\n    }\n  } else {\n    this.target = target;\n  }\n\n  var _arr = ['mouseup', 'mousedown', 'click', 'touchstart'];\n\n  for (var _i = 0; _i < _arr.length; _i++) {\n    var ev = _arr[_i];\n    this.target.addEventListener(ev, function (e) {\n      return dispatch(e);\n    }, false);\n  }\n}\n/**\n * Clone a mouse event object.\n *\n * @param e {MouseEvent} A mouse event object to clone.\n * @returns {MouseEvent}\n */\n\n\nfunction clone(e) {\n  var opts = Object.assign({}, e, {\n    bubbles: false\n  });\n\n  try {\n    return new MouseEvent(e.type, opts);\n  } catch (err) {\n    // compat: webkit\n    var copy = document.createEvent('MouseEvents');\n    copy.initMouseEvent(e.type, false, opts.cancelable, opts.view, opts.detail, opts.screenX, opts.screenY, opts.clientX, opts.clientY, opts.ctrlKey, opts.altKey, opts.shiftKey, opts.metaKey, opts.button, opts.relatedTarget);\n    return copy;\n  }\n}\n/**\n * Check if the item contains the point denoted by the passed coordinates\n * @param item {Object} An object with getBoundingClientRect and getClientRects\n *                      methods.\n * @param x {Number}\n * @param y {Number}\n * @returns {Boolean}\n */\n\n\nfunction contains(item, target, x, y) {\n  // offset\n  var offset = target.getBoundingClientRect();\n\n  function rectContains(r, x, y) {\n    var top = r.top - offset.top;\n    var left = r.left - offset.left;\n    var bottom = top + r.height;\n    var right = left + r.width;\n    return top <= y && left <= x && bottom > y && right > x;\n  } // Check overall bounding box first\n\n\n  var rect = item.getBoundingClientRect();\n\n  if (!rectContains(rect, x, y)) {\n    return false;\n  } // Then continue to check each child rect\n\n\n  var rects = item.getClientRects();\n\n  for (var i = 0, len = rects.length; i < len; i++) {\n    if (rectContains(rects[i], x, y)) {\n      return true;\n    }\n  }\n\n  return false;\n}","map":{"version":3,"sources":["S:/REACT/Ract-Js/Frlnce/node_modules/marks-pane/lib/events.js"],"names":["Object","defineProperty","exports","value","proxyMouse","clone","default","target","tracked","dispatch","e","i","length","t","x","clientX","y","clientY","touches","contains","dispatchEvent","nodeName","contentDocument","err","_arr","_i","ev","addEventListener","opts","assign","bubbles","MouseEvent","type","copy","document","createEvent","initMouseEvent","cancelable","view","detail","screenX","screenY","ctrlKey","altKey","shiftKey","metaKey","button","relatedTarget","item","offset","getBoundingClientRect","rectContains","r","top","left","bottom","height","right","width","rect","rects","getClientRects","len"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.proxyMouse = proxyMouse;\nexports.clone = clone;\n// import 'babelify/polyfill'; // needed for Object.assign\n\nexports.default = {\n    proxyMouse: proxyMouse\n};\n\n/**\n * Start proxying all mouse events that occur on the target node to each node in\n * a set of tracked nodes.\n *\n * The items in tracked do not strictly have to be DOM Nodes, but they do have\n * to have dispatchEvent, getBoundingClientRect, and getClientRects methods.\n *\n * @param target {Node} The node on which to listen for mouse events.\n * @param tracked {Node[]} A (possibly mutable) array of nodes to which to proxy\n *                         events.\n */\n\nfunction proxyMouse(target, tracked) {\n    function dispatch(e) {\n        // We walk through the set of tracked elements in reverse order so that\n        // events are sent to those most recently added first.\n        //\n        // This is the least surprising behaviour as it simulates the way the\n        // browser would work if items added later were drawn \"on top of\"\n        // earlier ones.\n        for (var i = tracked.length - 1; i >= 0; i--) {\n            var t = tracked[i];\n            var x = e.clientX;\n            var y = e.clientY;\n\n            if (e.touches && e.touches.length) {\n                x = e.touches[0].clientX;\n                y = e.touches[0].clientY;\n            }\n\n            if (!contains(t, target, x, y)) {\n                continue;\n            }\n\n            // The event targets this mark, so dispatch a cloned event:\n            t.dispatchEvent(clone(e));\n            // We only dispatch the cloned event to the first matching mark.\n            break;\n        }\n    }\n\n    if (target.nodeName === \"iframe\" || target.nodeName === \"IFRAME\") {\n\n        try {\n            // Try to get the contents if same domain\n            this.target = target.contentDocument;\n        } catch (err) {\n            this.target = target;\n        }\n    } else {\n        this.target = target;\n    }\n\n    var _arr = ['mouseup', 'mousedown', 'click', 'touchstart'];\n    for (var _i = 0; _i < _arr.length; _i++) {\n        var ev = _arr[_i];\n        this.target.addEventListener(ev, function (e) {\n            return dispatch(e);\n        }, false);\n    }\n}\n\n/**\n * Clone a mouse event object.\n *\n * @param e {MouseEvent} A mouse event object to clone.\n * @returns {MouseEvent}\n */\nfunction clone(e) {\n    var opts = Object.assign({}, e, { bubbles: false });\n    try {\n        return new MouseEvent(e.type, opts);\n    } catch (err) {\n        // compat: webkit\n        var copy = document.createEvent('MouseEvents');\n        copy.initMouseEvent(e.type, false, opts.cancelable, opts.view, opts.detail, opts.screenX, opts.screenY, opts.clientX, opts.clientY, opts.ctrlKey, opts.altKey, opts.shiftKey, opts.metaKey, opts.button, opts.relatedTarget);\n        return copy;\n    }\n}\n\n/**\n * Check if the item contains the point denoted by the passed coordinates\n * @param item {Object} An object with getBoundingClientRect and getClientRects\n *                      methods.\n * @param x {Number}\n * @param y {Number}\n * @returns {Boolean}\n */\nfunction contains(item, target, x, y) {\n    // offset\n    var offset = target.getBoundingClientRect();\n\n    function rectContains(r, x, y) {\n        var top = r.top - offset.top;\n        var left = r.left - offset.left;\n        var bottom = top + r.height;\n        var right = left + r.width;\n        return top <= y && left <= x && bottom > y && right > x;\n    }\n\n    // Check overall bounding box first\n    var rect = item.getBoundingClientRect();\n    if (!rectContains(rect, x, y)) {\n        return false;\n    }\n\n    // Then continue to check each child rect\n    var rects = item.getClientRects();\n    for (var i = 0, len = rects.length; i < len; i++) {\n        if (rectContains(rects[i], x, y)) {\n            return true;\n        }\n    }\n    return false;\n}\n"]},"metadata":{},"sourceType":"script"}