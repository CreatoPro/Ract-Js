{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _core = require(\"./utils/core\");\n/**\n * Open Packaging Format Parser\n * @class\n * @param {document} packageDocument OPF XML\n */\n\n\nclass Packaging {\n  constructor(packageDocument) {\n    this.manifest = {};\n    this.navPath = '';\n    this.ncxPath = '';\n    this.coverPath = '';\n    this.spineNodeIndex = 0;\n    this.spine = [];\n    this.metadata = {};\n\n    if (packageDocument) {\n      this.parse(packageDocument);\n    }\n  }\n  /**\n   * Parse OPF XML\n   * @param  {document} packageDocument OPF XML\n   * @return {object} parsed package parts\n   */\n\n\n  parse(packageDocument) {\n    var metadataNode, manifestNode, spineNode;\n\n    if (!packageDocument) {\n      throw new Error(\"Package File Not Found\");\n    }\n\n    metadataNode = (0, _core.qs)(packageDocument, \"metadata\");\n\n    if (!metadataNode) {\n      throw new Error(\"No Metadata Found\");\n    }\n\n    manifestNode = (0, _core.qs)(packageDocument, \"manifest\");\n\n    if (!manifestNode) {\n      throw new Error(\"No Manifest Found\");\n    }\n\n    spineNode = (0, _core.qs)(packageDocument, \"spine\");\n\n    if (!spineNode) {\n      throw new Error(\"No Spine Found\");\n    }\n\n    this.manifest = this.parseManifest(manifestNode);\n    this.navPath = this.findNavPath(manifestNode);\n    this.ncxPath = this.findNcxPath(manifestNode, spineNode);\n    this.coverPath = this.findCoverPath(packageDocument);\n    this.spineNodeIndex = (0, _core.indexOfElementNode)(spineNode);\n    this.spine = this.parseSpine(spineNode, this.manifest);\n    this.uniqueIdentifier = this.findUniqueIdentifier(packageDocument);\n    this.metadata = this.parseMetadata(metadataNode);\n    this.metadata.direction = spineNode.getAttribute(\"page-progression-direction\");\n    return {\n      \"metadata\": this.metadata,\n      \"spine\": this.spine,\n      \"manifest\": this.manifest,\n      \"navPath\": this.navPath,\n      \"ncxPath\": this.ncxPath,\n      \"coverPath\": this.coverPath,\n      \"spineNodeIndex\": this.spineNodeIndex\n    };\n  }\n  /**\n   * Parse Metadata\n   * @private\n   * @param  {node} xml\n   * @return {object} metadata\n   */\n\n\n  parseMetadata(xml) {\n    var metadata = {};\n    metadata.title = this.getElementText(xml, \"title\");\n    metadata.creator = this.getElementText(xml, \"creator\");\n    metadata.description = this.getElementText(xml, \"description\");\n    metadata.pubdate = this.getElementText(xml, \"date\");\n    metadata.publisher = this.getElementText(xml, \"publisher\");\n    metadata.identifier = this.getElementText(xml, \"identifier\");\n    metadata.language = this.getElementText(xml, \"language\");\n    metadata.rights = this.getElementText(xml, \"rights\");\n    metadata.modified_date = this.getPropertyText(xml, \"dcterms:modified\");\n    metadata.layout = this.getPropertyText(xml, \"rendition:layout\");\n    metadata.orientation = this.getPropertyText(xml, \"rendition:orientation\");\n    metadata.flow = this.getPropertyText(xml, \"rendition:flow\");\n    metadata.viewport = this.getPropertyText(xml, \"rendition:viewport\");\n    metadata.media_active_class = this.getPropertyText(xml, \"media:active-class\");\n    metadata.spread = this.getPropertyText(xml, \"rendition:spread\"); // metadata.page_prog_dir = packageXml.querySelector(\"spine\").getAttribute(\"page-progression-direction\");\n\n    return metadata;\n  }\n  /**\n   * Parse Manifest\n   * @private\n   * @param  {node} manifestXml\n   * @return {object} manifest\n   */\n\n\n  parseManifest(manifestXml) {\n    var manifest = {}; //-- Turn items into an array\n    // var selected = manifestXml.querySelectorAll(\"item\");\n\n    var selected = (0, _core.qsa)(manifestXml, \"item\");\n    var items = Array.prototype.slice.call(selected); //-- Create an object with the id as key\n\n    items.forEach(function (item) {\n      var id = item.getAttribute(\"id\"),\n          href = item.getAttribute(\"href\") || \"\",\n          type = item.getAttribute(\"media-type\") || \"\",\n          overlay = item.getAttribute(\"media-overlay\") || \"\",\n          properties = item.getAttribute(\"properties\") || \"\";\n      manifest[id] = {\n        \"href\": href,\n        // \"url\" : href,\n        \"type\": type,\n        \"overlay\": overlay,\n        \"properties\": properties.length ? properties.split(\" \") : []\n      };\n    });\n    return manifest;\n  }\n  /**\n   * Parse Spine\n   * @private\n   * @param  {node} spineXml\n   * @param  {Packaging.manifest} manifest\n   * @return {object} spine\n   */\n\n\n  parseSpine(spineXml, manifest) {\n    var spine = [];\n    var selected = (0, _core.qsa)(spineXml, \"itemref\");\n    var items = Array.prototype.slice.call(selected); // var epubcfi = new EpubCFI();\n    //-- Add to array to maintain ordering and cross reference with manifest\n\n    items.forEach(function (item, index) {\n      var idref = item.getAttribute(\"idref\"); // var cfiBase = epubcfi.generateChapterComponent(spineNodeIndex, index, Id);\n\n      var props = item.getAttribute(\"properties\") || \"\";\n      var propArray = props.length ? props.split(\" \") : []; // var manifestProps = manifest[Id].properties;\n      // var manifestPropArray = manifestProps.length ? manifestProps.split(\" \") : [];\n\n      var itemref = {\n        \"id\": item.getAttribute(\"id\"),\n        \"idref\": idref,\n        \"linear\": item.getAttribute(\"linear\") || \"yes\",\n        \"properties\": propArray,\n        // \"href\" : manifest[Id].href,\n        // \"url\" :  manifest[Id].url,\n        \"index\": index // \"cfiBase\" : cfiBase\n\n      };\n      spine.push(itemref);\n    });\n    return spine;\n  }\n  /**\n   * Find Unique Identifier\n   * @private\n   * @param  {node} packageXml\n   * @return {string} Unique Identifier text\n   */\n\n\n  findUniqueIdentifier(packageXml) {\n    var uniqueIdentifierId = packageXml.documentElement.getAttribute(\"unique-identifier\");\n\n    if (!uniqueIdentifierId) {\n      return \"\";\n    }\n\n    var identifier = packageXml.getElementById(uniqueIdentifierId);\n\n    if (!identifier) {\n      return \"\";\n    }\n\n    if (identifier.localName === \"identifier\" && identifier.namespaceURI === \"http://purl.org/dc/elements/1.1/\") {\n      return identifier.childNodes.length > 0 ? identifier.childNodes[0].nodeValue.trim() : \"\";\n    }\n\n    return \"\";\n  }\n  /**\n   * Find TOC NAV\n   * @private\n   * @param {element} manifestNode\n   * @return {string}\n   */\n\n\n  findNavPath(manifestNode) {\n    // Find item with property \"nav\"\n    // Should catch nav regardless of order\n    // var node = manifestNode.querySelector(\"item[properties$='nav'], item[properties^='nav '], item[properties*=' nav ']\");\n    var node = (0, _core.qsp)(manifestNode, \"item\", {\n      \"properties\": \"nav\"\n    });\n    return node ? node.getAttribute(\"href\") : false;\n  }\n  /**\n   * Find TOC NCX\n   * media-type=\"application/x-dtbncx+xml\" href=\"toc.ncx\"\n   * @private\n   * @param {element} manifestNode\n   * @param {element} spineNode\n   * @return {string}\n   */\n\n\n  findNcxPath(manifestNode, spineNode) {\n    // var node = manifestNode.querySelector(\"item[media-type='application/x-dtbncx+xml']\");\n    var node = (0, _core.qsp)(manifestNode, \"item\", {\n      \"media-type\": \"application/x-dtbncx+xml\"\n    });\n    var tocId; // If we can't find the toc by media-type then try to look for id of the item in the spine attributes as\n    // according to http://www.idpf.org/epub/20/spec/OPF_2.0.1_draft.htm#Section2.4.1.2,\n    // \"The item that describes the NCX must be referenced by the spine toc attribute.\"\n\n    if (!node) {\n      tocId = spineNode.getAttribute(\"toc\");\n\n      if (tocId) {\n        // node = manifestNode.querySelector(\"item[id='\" + tocId + \"']\");\n        node = manifestNode.querySelector(`#${tocId}`);\n      }\n    }\n\n    return node ? node.getAttribute(\"href\") : false;\n  }\n  /**\n   * Find the Cover Path\n   * <item properties=\"cover-image\" id=\"ci\" href=\"cover.svg\" media-type=\"image/svg+xml\" />\n   * Fallback for Epub 2.0\n   * @private\n   * @param  {node} packageXml\n   * @return {string} href\n   */\n\n\n  findCoverPath(packageXml) {\n    var pkg = (0, _core.qs)(packageXml, \"package\");\n    var epubVersion = pkg.getAttribute(\"version\"); // Try parsing cover with epub 3.\n    // var node = packageXml.querySelector(\"item[properties='cover-image']\");\n\n    var node = (0, _core.qsp)(packageXml, \"item\", {\n      \"properties\": \"cover-image\"\n    });\n    if (node) return node.getAttribute(\"href\"); // Fallback to epub 2.\n\n    var metaCover = (0, _core.qsp)(packageXml, \"meta\", {\n      \"name\": \"cover\"\n    });\n\n    if (metaCover) {\n      var coverId = metaCover.getAttribute(\"content\"); // var cover = packageXml.querySelector(\"item[id='\" + coverId + \"']\");\n\n      var cover = packageXml.getElementById(coverId);\n      return cover ? cover.getAttribute(\"href\") : \"\";\n    } else {\n      return false;\n    }\n  }\n  /**\n   * Get text of a namespaced element\n   * @private\n   * @param  {node} xml\n   * @param  {string} tag\n   * @return {string} text\n   */\n\n\n  getElementText(xml, tag) {\n    var found = xml.getElementsByTagNameNS(\"http://purl.org/dc/elements/1.1/\", tag);\n    var el;\n    if (!found || found.length === 0) return \"\";\n    el = found[0];\n\n    if (el.childNodes.length) {\n      return el.childNodes[0].nodeValue;\n    }\n\n    return \"\";\n  }\n  /**\n   * Get text by property\n   * @private\n   * @param  {node} xml\n   * @param  {string} property\n   * @return {string} text\n   */\n\n\n  getPropertyText(xml, property) {\n    var el = (0, _core.qsp)(xml, \"meta\", {\n      \"property\": property\n    });\n\n    if (el && el.childNodes.length) {\n      return el.childNodes[0].nodeValue;\n    }\n\n    return \"\";\n  }\n  /**\n   * Load JSON Manifest\n   * @param  {document} packageDocument OPF XML\n   * @return {object} parsed package parts\n   */\n\n\n  load(json) {\n    this.metadata = json.metadata;\n    let spine = json.readingOrder || json.spine;\n    this.spine = spine.map((item, index) => {\n      item.index = index;\n      item.linear = item.linear || \"yes\";\n      return item;\n    });\n    json.resources.forEach((item, index) => {\n      this.manifest[index] = item;\n\n      if (item.rel && item.rel[0] === \"cover\") {\n        this.coverPath = item.href;\n      }\n    });\n    this.spineNodeIndex = 0;\n    this.toc = json.toc.map((item, index) => {\n      item.label = item.title;\n      return item;\n    });\n    return {\n      \"metadata\": this.metadata,\n      \"spine\": this.spine,\n      \"manifest\": this.manifest,\n      \"navPath\": this.navPath,\n      \"ncxPath\": this.ncxPath,\n      \"coverPath\": this.coverPath,\n      \"spineNodeIndex\": this.spineNodeIndex,\n      \"toc\": this.toc\n    };\n  }\n\n  destroy() {\n    this.manifest = undefined;\n    this.navPath = undefined;\n    this.ncxPath = undefined;\n    this.coverPath = undefined;\n    this.spineNodeIndex = undefined;\n    this.spine = undefined;\n    this.metadata = undefined;\n  }\n\n}\n\nvar _default = Packaging;\nexports.default = _default;","map":{"version":3,"sources":["S:/REACT/Ract-Js/Frlnce/node_modules/epubjs/lib/packaging.js"],"names":["Object","defineProperty","exports","value","default","_core","require","Packaging","constructor","packageDocument","manifest","navPath","ncxPath","coverPath","spineNodeIndex","spine","metadata","parse","metadataNode","manifestNode","spineNode","Error","qs","parseManifest","findNavPath","findNcxPath","findCoverPath","indexOfElementNode","parseSpine","uniqueIdentifier","findUniqueIdentifier","parseMetadata","direction","getAttribute","xml","title","getElementText","creator","description","pubdate","publisher","identifier","language","rights","modified_date","getPropertyText","layout","orientation","flow","viewport","media_active_class","spread","manifestXml","selected","qsa","items","Array","prototype","slice","call","forEach","item","id","href","type","overlay","properties","length","split","spineXml","index","idref","props","propArray","itemref","push","packageXml","uniqueIdentifierId","documentElement","getElementById","localName","namespaceURI","childNodes","nodeValue","trim","node","qsp","tocId","querySelector","pkg","epubVersion","metaCover","coverId","cover","tag","found","getElementsByTagNameNS","el","property","load","json","readingOrder","map","linear","resources","rel","toc","label","destroy","undefined","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _core = require(\"./utils/core\");\n\n/**\n * Open Packaging Format Parser\n * @class\n * @param {document} packageDocument OPF XML\n */\nclass Packaging {\n  constructor(packageDocument) {\n    this.manifest = {};\n    this.navPath = '';\n    this.ncxPath = '';\n    this.coverPath = '';\n    this.spineNodeIndex = 0;\n    this.spine = [];\n    this.metadata = {};\n\n    if (packageDocument) {\n      this.parse(packageDocument);\n    }\n  }\n  /**\n   * Parse OPF XML\n   * @param  {document} packageDocument OPF XML\n   * @return {object} parsed package parts\n   */\n\n\n  parse(packageDocument) {\n    var metadataNode, manifestNode, spineNode;\n\n    if (!packageDocument) {\n      throw new Error(\"Package File Not Found\");\n    }\n\n    metadataNode = (0, _core.qs)(packageDocument, \"metadata\");\n\n    if (!metadataNode) {\n      throw new Error(\"No Metadata Found\");\n    }\n\n    manifestNode = (0, _core.qs)(packageDocument, \"manifest\");\n\n    if (!manifestNode) {\n      throw new Error(\"No Manifest Found\");\n    }\n\n    spineNode = (0, _core.qs)(packageDocument, \"spine\");\n\n    if (!spineNode) {\n      throw new Error(\"No Spine Found\");\n    }\n\n    this.manifest = this.parseManifest(manifestNode);\n    this.navPath = this.findNavPath(manifestNode);\n    this.ncxPath = this.findNcxPath(manifestNode, spineNode);\n    this.coverPath = this.findCoverPath(packageDocument);\n    this.spineNodeIndex = (0, _core.indexOfElementNode)(spineNode);\n    this.spine = this.parseSpine(spineNode, this.manifest);\n    this.uniqueIdentifier = this.findUniqueIdentifier(packageDocument);\n    this.metadata = this.parseMetadata(metadataNode);\n    this.metadata.direction = spineNode.getAttribute(\"page-progression-direction\");\n    return {\n      \"metadata\": this.metadata,\n      \"spine\": this.spine,\n      \"manifest\": this.manifest,\n      \"navPath\": this.navPath,\n      \"ncxPath\": this.ncxPath,\n      \"coverPath\": this.coverPath,\n      \"spineNodeIndex\": this.spineNodeIndex\n    };\n  }\n  /**\n   * Parse Metadata\n   * @private\n   * @param  {node} xml\n   * @return {object} metadata\n   */\n\n\n  parseMetadata(xml) {\n    var metadata = {};\n    metadata.title = this.getElementText(xml, \"title\");\n    metadata.creator = this.getElementText(xml, \"creator\");\n    metadata.description = this.getElementText(xml, \"description\");\n    metadata.pubdate = this.getElementText(xml, \"date\");\n    metadata.publisher = this.getElementText(xml, \"publisher\");\n    metadata.identifier = this.getElementText(xml, \"identifier\");\n    metadata.language = this.getElementText(xml, \"language\");\n    metadata.rights = this.getElementText(xml, \"rights\");\n    metadata.modified_date = this.getPropertyText(xml, \"dcterms:modified\");\n    metadata.layout = this.getPropertyText(xml, \"rendition:layout\");\n    metadata.orientation = this.getPropertyText(xml, \"rendition:orientation\");\n    metadata.flow = this.getPropertyText(xml, \"rendition:flow\");\n    metadata.viewport = this.getPropertyText(xml, \"rendition:viewport\");\n    metadata.media_active_class = this.getPropertyText(xml, \"media:active-class\");\n    metadata.spread = this.getPropertyText(xml, \"rendition:spread\"); // metadata.page_prog_dir = packageXml.querySelector(\"spine\").getAttribute(\"page-progression-direction\");\n\n    return metadata;\n  }\n  /**\n   * Parse Manifest\n   * @private\n   * @param  {node} manifestXml\n   * @return {object} manifest\n   */\n\n\n  parseManifest(manifestXml) {\n    var manifest = {}; //-- Turn items into an array\n    // var selected = manifestXml.querySelectorAll(\"item\");\n\n    var selected = (0, _core.qsa)(manifestXml, \"item\");\n    var items = Array.prototype.slice.call(selected); //-- Create an object with the id as key\n\n    items.forEach(function (item) {\n      var id = item.getAttribute(\"id\"),\n          href = item.getAttribute(\"href\") || \"\",\n          type = item.getAttribute(\"media-type\") || \"\",\n          overlay = item.getAttribute(\"media-overlay\") || \"\",\n          properties = item.getAttribute(\"properties\") || \"\";\n      manifest[id] = {\n        \"href\": href,\n        // \"url\" : href,\n        \"type\": type,\n        \"overlay\": overlay,\n        \"properties\": properties.length ? properties.split(\" \") : []\n      };\n    });\n    return manifest;\n  }\n  /**\n   * Parse Spine\n   * @private\n   * @param  {node} spineXml\n   * @param  {Packaging.manifest} manifest\n   * @return {object} spine\n   */\n\n\n  parseSpine(spineXml, manifest) {\n    var spine = [];\n    var selected = (0, _core.qsa)(spineXml, \"itemref\");\n    var items = Array.prototype.slice.call(selected); // var epubcfi = new EpubCFI();\n    //-- Add to array to maintain ordering and cross reference with manifest\n\n    items.forEach(function (item, index) {\n      var idref = item.getAttribute(\"idref\"); // var cfiBase = epubcfi.generateChapterComponent(spineNodeIndex, index, Id);\n\n      var props = item.getAttribute(\"properties\") || \"\";\n      var propArray = props.length ? props.split(\" \") : []; // var manifestProps = manifest[Id].properties;\n      // var manifestPropArray = manifestProps.length ? manifestProps.split(\" \") : [];\n\n      var itemref = {\n        \"id\": item.getAttribute(\"id\"),\n        \"idref\": idref,\n        \"linear\": item.getAttribute(\"linear\") || \"yes\",\n        \"properties\": propArray,\n        // \"href\" : manifest[Id].href,\n        // \"url\" :  manifest[Id].url,\n        \"index\": index // \"cfiBase\" : cfiBase\n\n      };\n      spine.push(itemref);\n    });\n    return spine;\n  }\n  /**\n   * Find Unique Identifier\n   * @private\n   * @param  {node} packageXml\n   * @return {string} Unique Identifier text\n   */\n\n\n  findUniqueIdentifier(packageXml) {\n    var uniqueIdentifierId = packageXml.documentElement.getAttribute(\"unique-identifier\");\n\n    if (!uniqueIdentifierId) {\n      return \"\";\n    }\n\n    var identifier = packageXml.getElementById(uniqueIdentifierId);\n\n    if (!identifier) {\n      return \"\";\n    }\n\n    if (identifier.localName === \"identifier\" && identifier.namespaceURI === \"http://purl.org/dc/elements/1.1/\") {\n      return identifier.childNodes.length > 0 ? identifier.childNodes[0].nodeValue.trim() : \"\";\n    }\n\n    return \"\";\n  }\n  /**\n   * Find TOC NAV\n   * @private\n   * @param {element} manifestNode\n   * @return {string}\n   */\n\n\n  findNavPath(manifestNode) {\n    // Find item with property \"nav\"\n    // Should catch nav regardless of order\n    // var node = manifestNode.querySelector(\"item[properties$='nav'], item[properties^='nav '], item[properties*=' nav ']\");\n    var node = (0, _core.qsp)(manifestNode, \"item\", {\n      \"properties\": \"nav\"\n    });\n    return node ? node.getAttribute(\"href\") : false;\n  }\n  /**\n   * Find TOC NCX\n   * media-type=\"application/x-dtbncx+xml\" href=\"toc.ncx\"\n   * @private\n   * @param {element} manifestNode\n   * @param {element} spineNode\n   * @return {string}\n   */\n\n\n  findNcxPath(manifestNode, spineNode) {\n    // var node = manifestNode.querySelector(\"item[media-type='application/x-dtbncx+xml']\");\n    var node = (0, _core.qsp)(manifestNode, \"item\", {\n      \"media-type\": \"application/x-dtbncx+xml\"\n    });\n    var tocId; // If we can't find the toc by media-type then try to look for id of the item in the spine attributes as\n    // according to http://www.idpf.org/epub/20/spec/OPF_2.0.1_draft.htm#Section2.4.1.2,\n    // \"The item that describes the NCX must be referenced by the spine toc attribute.\"\n\n    if (!node) {\n      tocId = spineNode.getAttribute(\"toc\");\n\n      if (tocId) {\n        // node = manifestNode.querySelector(\"item[id='\" + tocId + \"']\");\n        node = manifestNode.querySelector(`#${tocId}`);\n      }\n    }\n\n    return node ? node.getAttribute(\"href\") : false;\n  }\n  /**\n   * Find the Cover Path\n   * <item properties=\"cover-image\" id=\"ci\" href=\"cover.svg\" media-type=\"image/svg+xml\" />\n   * Fallback for Epub 2.0\n   * @private\n   * @param  {node} packageXml\n   * @return {string} href\n   */\n\n\n  findCoverPath(packageXml) {\n    var pkg = (0, _core.qs)(packageXml, \"package\");\n    var epubVersion = pkg.getAttribute(\"version\"); // Try parsing cover with epub 3.\n    // var node = packageXml.querySelector(\"item[properties='cover-image']\");\n\n    var node = (0, _core.qsp)(packageXml, \"item\", {\n      \"properties\": \"cover-image\"\n    });\n    if (node) return node.getAttribute(\"href\"); // Fallback to epub 2.\n\n    var metaCover = (0, _core.qsp)(packageXml, \"meta\", {\n      \"name\": \"cover\"\n    });\n\n    if (metaCover) {\n      var coverId = metaCover.getAttribute(\"content\"); // var cover = packageXml.querySelector(\"item[id='\" + coverId + \"']\");\n\n      var cover = packageXml.getElementById(coverId);\n      return cover ? cover.getAttribute(\"href\") : \"\";\n    } else {\n      return false;\n    }\n  }\n  /**\n   * Get text of a namespaced element\n   * @private\n   * @param  {node} xml\n   * @param  {string} tag\n   * @return {string} text\n   */\n\n\n  getElementText(xml, tag) {\n    var found = xml.getElementsByTagNameNS(\"http://purl.org/dc/elements/1.1/\", tag);\n    var el;\n    if (!found || found.length === 0) return \"\";\n    el = found[0];\n\n    if (el.childNodes.length) {\n      return el.childNodes[0].nodeValue;\n    }\n\n    return \"\";\n  }\n  /**\n   * Get text by property\n   * @private\n   * @param  {node} xml\n   * @param  {string} property\n   * @return {string} text\n   */\n\n\n  getPropertyText(xml, property) {\n    var el = (0, _core.qsp)(xml, \"meta\", {\n      \"property\": property\n    });\n\n    if (el && el.childNodes.length) {\n      return el.childNodes[0].nodeValue;\n    }\n\n    return \"\";\n  }\n  /**\n   * Load JSON Manifest\n   * @param  {document} packageDocument OPF XML\n   * @return {object} parsed package parts\n   */\n\n\n  load(json) {\n    this.metadata = json.metadata;\n    let spine = json.readingOrder || json.spine;\n    this.spine = spine.map((item, index) => {\n      item.index = index;\n      item.linear = item.linear || \"yes\";\n      return item;\n    });\n    json.resources.forEach((item, index) => {\n      this.manifest[index] = item;\n\n      if (item.rel && item.rel[0] === \"cover\") {\n        this.coverPath = item.href;\n      }\n    });\n    this.spineNodeIndex = 0;\n    this.toc = json.toc.map((item, index) => {\n      item.label = item.title;\n      return item;\n    });\n    return {\n      \"metadata\": this.metadata,\n      \"spine\": this.spine,\n      \"manifest\": this.manifest,\n      \"navPath\": this.navPath,\n      \"ncxPath\": this.ncxPath,\n      \"coverPath\": this.coverPath,\n      \"spineNodeIndex\": this.spineNodeIndex,\n      \"toc\": this.toc\n    };\n  }\n\n  destroy() {\n    this.manifest = undefined;\n    this.navPath = undefined;\n    this.ncxPath = undefined;\n    this.coverPath = undefined;\n    this.spineNodeIndex = undefined;\n    this.spine = undefined;\n    this.metadata = undefined;\n  }\n\n}\n\nvar _default = Packaging;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}