{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _eventEmitter = _interopRequireDefault(require(\"event-emitter\"));\n\nvar _epubcfi = _interopRequireDefault(require(\"./epubcfi\"));\n\nvar _constants = require(\"./utils/constants\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n\t* Handles managing adding & removing Annotations\n\t* @param {Rendition} rendition\n\t* @class\n\t*/\n\n\nclass Annotations {\n  constructor(rendition) {\n    this.rendition = rendition;\n    this.highlights = [];\n    this.underlines = [];\n    this.marks = [];\n    this._annotations = {};\n    this._annotationsBySectionIndex = {};\n    this.rendition.hooks.render.register(this.inject.bind(this));\n    this.rendition.hooks.unloaded.register(this.clear.bind(this));\n  }\n  /**\n   * Add an annotation to store\n   * @param {string} type Type of annotation to add: \"highlight\", \"underline\", \"mark\"\n   * @param {EpubCFI} cfiRange EpubCFI range to attach annotation to\n   * @param {object} data Data to assign to annotation\n   * @param {function} [cb] Callback after annotation is added\n   * @param {string} className CSS class to assign to annotation\n   * @param {object} styles CSS styles to assign to annotation\n   * @returns {Annotation} annotation\n   */\n\n\n  add(type, cfiRange, data, cb, className, styles) {\n    let hash = encodeURI(cfiRange + type);\n    let cfi = new _epubcfi.default(cfiRange);\n    let sectionIndex = cfi.spinePos;\n    let annotation = new Annotation({\n      type,\n      cfiRange,\n      data,\n      sectionIndex,\n      cb,\n      className,\n      styles\n    });\n    this._annotations[hash] = annotation;\n\n    if (sectionIndex in this._annotationsBySectionIndex) {\n      this._annotationsBySectionIndex[sectionIndex].push(hash);\n    } else {\n      this._annotationsBySectionIndex[sectionIndex] = [hash];\n    }\n\n    let views = this.rendition.views();\n    views.forEach(view => {\n      if (annotation.sectionIndex === view.index) {\n        annotation.attach(view);\n      }\n    });\n    return annotation;\n  }\n  /**\n   * Remove an annotation from store\n   * @param {EpubCFI} cfiRange EpubCFI range the annotation is attached to\n   * @param {string} type Type of annotation to add: \"highlight\", \"underline\", \"mark\"\n   */\n\n\n  remove(cfiRange, type) {\n    let hash = encodeURI(cfiRange + type);\n\n    if (hash in this._annotations) {\n      let annotation = this._annotations[hash];\n\n      if (type && annotation.type !== type) {\n        return;\n      }\n\n      let views = this.rendition.views();\n      views.forEach(view => {\n        this._removeFromAnnotationBySectionIndex(annotation.sectionIndex, hash);\n\n        if (annotation.sectionIndex === view.index) {\n          annotation.detach(view);\n        }\n      });\n      delete this._annotations[hash];\n    }\n  }\n  /**\n   * Remove an annotations by Section Index\n   * @private\n   */\n\n\n  _removeFromAnnotationBySectionIndex(sectionIndex, hash) {\n    this._annotationsBySectionIndex[sectionIndex] = this._annotationsAt(sectionIndex).filter(h => h !== hash);\n  }\n  /**\n   * Get annotations by Section Index\n   * @private\n   */\n\n\n  _annotationsAt(index) {\n    return this._annotationsBySectionIndex[index];\n  }\n  /**\n   * Add a highlight to the store\n   * @param {EpubCFI} cfiRange EpubCFI range to attach annotation to\n   * @param {object} data Data to assign to annotation\n   * @param {function} cb Callback after annotation is clicked\n   * @param {string} className CSS class to assign to annotation\n   * @param {object} styles CSS styles to assign to annotation\n   */\n\n\n  highlight(cfiRange, data, cb, className, styles) {\n    return this.add(\"highlight\", cfiRange, data, cb, className, styles);\n  }\n  /**\n   * Add a underline to the store\n   * @param {EpubCFI} cfiRange EpubCFI range to attach annotation to\n   * @param {object} data Data to assign to annotation\n   * @param {function} cb Callback after annotation is clicked\n   * @param {string} className CSS class to assign to annotation\n   * @param {object} styles CSS styles to assign to annotation\n   */\n\n\n  underline(cfiRange, data, cb, className, styles) {\n    return this.add(\"underline\", cfiRange, data, cb, className, styles);\n  }\n  /**\n   * Add a mark to the store\n   * @param {EpubCFI} cfiRange EpubCFI range to attach annotation to\n   * @param {object} data Data to assign to annotation\n   * @param {function} cb Callback after annotation is clicked\n   */\n\n\n  mark(cfiRange, data, cb) {\n    return this.add(\"mark\", cfiRange, data, cb);\n  }\n  /**\n   * iterate over annotations in the store\n   */\n\n\n  each() {\n    return this._annotations.forEach.apply(this._annotations, arguments);\n  }\n  /**\n   * Hook for injecting annotation into a view\n   * @param {View} view\n   * @private\n   */\n\n\n  inject(view) {\n    let sectionIndex = view.index;\n\n    if (sectionIndex in this._annotationsBySectionIndex) {\n      let annotations = this._annotationsBySectionIndex[sectionIndex];\n      annotations.forEach(hash => {\n        let annotation = this._annotations[hash];\n        annotation.attach(view);\n      });\n    }\n  }\n  /**\n   * Hook for removing annotation from a view\n   * @param {View} view\n   * @private\n   */\n\n\n  clear(view) {\n    let sectionIndex = view.index;\n\n    if (sectionIndex in this._annotationsBySectionIndex) {\n      let annotations = this._annotationsBySectionIndex[sectionIndex];\n      annotations.forEach(hash => {\n        let annotation = this._annotations[hash];\n        annotation.detach(view);\n      });\n    }\n  }\n  /**\n   * [Not Implemented] Show annotations\n   * @TODO: needs implementation in View\n   */\n\n\n  show() {}\n  /**\n   * [Not Implemented] Hide annotations\n   * @TODO: needs implementation in View\n   */\n\n\n  hide() {}\n\n}\n/**\n * Annotation object\n * @class\n * @param {object} options\n * @param {string} options.type Type of annotation to add: \"highlight\", \"underline\", \"mark\"\n * @param {EpubCFI} options.cfiRange EpubCFI range to attach annotation to\n * @param {object} options.data Data to assign to annotation\n * @param {int} options.sectionIndex Index in the Spine of the Section annotation belongs to\n * @param {function} [options.cb] Callback after annotation is clicked\n * @param {string} className CSS class to assign to annotation\n * @param {object} styles CSS styles to assign to annotation\n * @returns {Annotation} annotation\n */\n\n\nclass Annotation {\n  constructor(_ref) {\n    let {\n      type,\n      cfiRange,\n      data,\n      sectionIndex,\n      cb,\n      className,\n      styles\n    } = _ref;\n    this.type = type;\n    this.cfiRange = cfiRange;\n    this.data = data;\n    this.sectionIndex = sectionIndex;\n    this.mark = undefined;\n    this.cb = cb;\n    this.className = className;\n    this.styles = styles;\n  }\n  /**\n   * Update stored data\n   * @param {object} data\n   */\n\n\n  update(data) {\n    this.data = data;\n  }\n  /**\n   * Add to a view\n   * @param {View} view\n   */\n\n\n  attach(view) {\n    let {\n      cfiRange,\n      data,\n      type,\n      mark,\n      cb,\n      className,\n      styles\n    } = this;\n    let result;\n\n    if (type === \"highlight\") {\n      result = view.highlight(cfiRange, data, cb, className, styles);\n    } else if (type === \"underline\") {\n      result = view.underline(cfiRange, data, cb, className, styles);\n    } else if (type === \"mark\") {\n      result = view.mark(cfiRange, data, cb);\n    }\n\n    this.mark = result;\n    this.emit(_constants.EVENTS.ANNOTATION.ATTACH, result);\n    return result;\n  }\n  /**\n   * Remove from a view\n   * @param {View} view\n   */\n\n\n  detach(view) {\n    let {\n      cfiRange,\n      type\n    } = this;\n    let result;\n\n    if (view) {\n      if (type === \"highlight\") {\n        result = view.unhighlight(cfiRange);\n      } else if (type === \"underline\") {\n        result = view.ununderline(cfiRange);\n      } else if (type === \"mark\") {\n        result = view.unmark(cfiRange);\n      }\n    }\n\n    this.mark = undefined;\n    this.emit(_constants.EVENTS.ANNOTATION.DETACH, result);\n    return result;\n  }\n  /**\n   * [Not Implemented] Get text of an annotation\n   * @TODO: needs implementation in contents\n   */\n\n\n  text() {}\n\n}\n\n(0, _eventEmitter.default)(Annotation.prototype);\nvar _default = Annotations;\nexports.default = _default;","map":{"version":3,"sources":["S:/REACT/Ract-Js/Frlnce/node_modules/epubjs/lib/annotations.js"],"names":["Object","defineProperty","exports","value","default","_eventEmitter","_interopRequireDefault","require","_epubcfi","_constants","obj","__esModule","Annotations","constructor","rendition","highlights","underlines","marks","_annotations","_annotationsBySectionIndex","hooks","render","register","inject","bind","unloaded","clear","add","type","cfiRange","data","cb","className","styles","hash","encodeURI","cfi","sectionIndex","spinePos","annotation","Annotation","push","views","forEach","view","index","attach","remove","_removeFromAnnotationBySectionIndex","detach","_annotationsAt","filter","h","highlight","underline","mark","each","apply","arguments","annotations","show","hide","undefined","update","result","emit","EVENTS","ANNOTATION","ATTACH","unhighlight","ununderline","unmark","DETACH","text","prototype","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _eventEmitter = _interopRequireDefault(require(\"event-emitter\"));\n\nvar _epubcfi = _interopRequireDefault(require(\"./epubcfi\"));\n\nvar _constants = require(\"./utils/constants\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n\t* Handles managing adding & removing Annotations\n\t* @param {Rendition} rendition\n\t* @class\n\t*/\nclass Annotations {\n  constructor(rendition) {\n    this.rendition = rendition;\n    this.highlights = [];\n    this.underlines = [];\n    this.marks = [];\n    this._annotations = {};\n    this._annotationsBySectionIndex = {};\n    this.rendition.hooks.render.register(this.inject.bind(this));\n    this.rendition.hooks.unloaded.register(this.clear.bind(this));\n  }\n  /**\n   * Add an annotation to store\n   * @param {string} type Type of annotation to add: \"highlight\", \"underline\", \"mark\"\n   * @param {EpubCFI} cfiRange EpubCFI range to attach annotation to\n   * @param {object} data Data to assign to annotation\n   * @param {function} [cb] Callback after annotation is added\n   * @param {string} className CSS class to assign to annotation\n   * @param {object} styles CSS styles to assign to annotation\n   * @returns {Annotation} annotation\n   */\n\n\n  add(type, cfiRange, data, cb, className, styles) {\n    let hash = encodeURI(cfiRange + type);\n    let cfi = new _epubcfi.default(cfiRange);\n    let sectionIndex = cfi.spinePos;\n    let annotation = new Annotation({\n      type,\n      cfiRange,\n      data,\n      sectionIndex,\n      cb,\n      className,\n      styles\n    });\n    this._annotations[hash] = annotation;\n\n    if (sectionIndex in this._annotationsBySectionIndex) {\n      this._annotationsBySectionIndex[sectionIndex].push(hash);\n    } else {\n      this._annotationsBySectionIndex[sectionIndex] = [hash];\n    }\n\n    let views = this.rendition.views();\n    views.forEach(view => {\n      if (annotation.sectionIndex === view.index) {\n        annotation.attach(view);\n      }\n    });\n    return annotation;\n  }\n  /**\n   * Remove an annotation from store\n   * @param {EpubCFI} cfiRange EpubCFI range the annotation is attached to\n   * @param {string} type Type of annotation to add: \"highlight\", \"underline\", \"mark\"\n   */\n\n\n  remove(cfiRange, type) {\n    let hash = encodeURI(cfiRange + type);\n\n    if (hash in this._annotations) {\n      let annotation = this._annotations[hash];\n\n      if (type && annotation.type !== type) {\n        return;\n      }\n\n      let views = this.rendition.views();\n      views.forEach(view => {\n        this._removeFromAnnotationBySectionIndex(annotation.sectionIndex, hash);\n\n        if (annotation.sectionIndex === view.index) {\n          annotation.detach(view);\n        }\n      });\n      delete this._annotations[hash];\n    }\n  }\n  /**\n   * Remove an annotations by Section Index\n   * @private\n   */\n\n\n  _removeFromAnnotationBySectionIndex(sectionIndex, hash) {\n    this._annotationsBySectionIndex[sectionIndex] = this._annotationsAt(sectionIndex).filter(h => h !== hash);\n  }\n  /**\n   * Get annotations by Section Index\n   * @private\n   */\n\n\n  _annotationsAt(index) {\n    return this._annotationsBySectionIndex[index];\n  }\n  /**\n   * Add a highlight to the store\n   * @param {EpubCFI} cfiRange EpubCFI range to attach annotation to\n   * @param {object} data Data to assign to annotation\n   * @param {function} cb Callback after annotation is clicked\n   * @param {string} className CSS class to assign to annotation\n   * @param {object} styles CSS styles to assign to annotation\n   */\n\n\n  highlight(cfiRange, data, cb, className, styles) {\n    return this.add(\"highlight\", cfiRange, data, cb, className, styles);\n  }\n  /**\n   * Add a underline to the store\n   * @param {EpubCFI} cfiRange EpubCFI range to attach annotation to\n   * @param {object} data Data to assign to annotation\n   * @param {function} cb Callback after annotation is clicked\n   * @param {string} className CSS class to assign to annotation\n   * @param {object} styles CSS styles to assign to annotation\n   */\n\n\n  underline(cfiRange, data, cb, className, styles) {\n    return this.add(\"underline\", cfiRange, data, cb, className, styles);\n  }\n  /**\n   * Add a mark to the store\n   * @param {EpubCFI} cfiRange EpubCFI range to attach annotation to\n   * @param {object} data Data to assign to annotation\n   * @param {function} cb Callback after annotation is clicked\n   */\n\n\n  mark(cfiRange, data, cb) {\n    return this.add(\"mark\", cfiRange, data, cb);\n  }\n  /**\n   * iterate over annotations in the store\n   */\n\n\n  each() {\n    return this._annotations.forEach.apply(this._annotations, arguments);\n  }\n  /**\n   * Hook for injecting annotation into a view\n   * @param {View} view\n   * @private\n   */\n\n\n  inject(view) {\n    let sectionIndex = view.index;\n\n    if (sectionIndex in this._annotationsBySectionIndex) {\n      let annotations = this._annotationsBySectionIndex[sectionIndex];\n      annotations.forEach(hash => {\n        let annotation = this._annotations[hash];\n        annotation.attach(view);\n      });\n    }\n  }\n  /**\n   * Hook for removing annotation from a view\n   * @param {View} view\n   * @private\n   */\n\n\n  clear(view) {\n    let sectionIndex = view.index;\n\n    if (sectionIndex in this._annotationsBySectionIndex) {\n      let annotations = this._annotationsBySectionIndex[sectionIndex];\n      annotations.forEach(hash => {\n        let annotation = this._annotations[hash];\n        annotation.detach(view);\n      });\n    }\n  }\n  /**\n   * [Not Implemented] Show annotations\n   * @TODO: needs implementation in View\n   */\n\n\n  show() {}\n  /**\n   * [Not Implemented] Hide annotations\n   * @TODO: needs implementation in View\n   */\n\n\n  hide() {}\n\n}\n/**\n * Annotation object\n * @class\n * @param {object} options\n * @param {string} options.type Type of annotation to add: \"highlight\", \"underline\", \"mark\"\n * @param {EpubCFI} options.cfiRange EpubCFI range to attach annotation to\n * @param {object} options.data Data to assign to annotation\n * @param {int} options.sectionIndex Index in the Spine of the Section annotation belongs to\n * @param {function} [options.cb] Callback after annotation is clicked\n * @param {string} className CSS class to assign to annotation\n * @param {object} styles CSS styles to assign to annotation\n * @returns {Annotation} annotation\n */\n\n\nclass Annotation {\n  constructor({\n    type,\n    cfiRange,\n    data,\n    sectionIndex,\n    cb,\n    className,\n    styles\n  }) {\n    this.type = type;\n    this.cfiRange = cfiRange;\n    this.data = data;\n    this.sectionIndex = sectionIndex;\n    this.mark = undefined;\n    this.cb = cb;\n    this.className = className;\n    this.styles = styles;\n  }\n  /**\n   * Update stored data\n   * @param {object} data\n   */\n\n\n  update(data) {\n    this.data = data;\n  }\n  /**\n   * Add to a view\n   * @param {View} view\n   */\n\n\n  attach(view) {\n    let {\n      cfiRange,\n      data,\n      type,\n      mark,\n      cb,\n      className,\n      styles\n    } = this;\n    let result;\n\n    if (type === \"highlight\") {\n      result = view.highlight(cfiRange, data, cb, className, styles);\n    } else if (type === \"underline\") {\n      result = view.underline(cfiRange, data, cb, className, styles);\n    } else if (type === \"mark\") {\n      result = view.mark(cfiRange, data, cb);\n    }\n\n    this.mark = result;\n    this.emit(_constants.EVENTS.ANNOTATION.ATTACH, result);\n    return result;\n  }\n  /**\n   * Remove from a view\n   * @param {View} view\n   */\n\n\n  detach(view) {\n    let {\n      cfiRange,\n      type\n    } = this;\n    let result;\n\n    if (view) {\n      if (type === \"highlight\") {\n        result = view.unhighlight(cfiRange);\n      } else if (type === \"underline\") {\n        result = view.ununderline(cfiRange);\n      } else if (type === \"mark\") {\n        result = view.unmark(cfiRange);\n      }\n    }\n\n    this.mark = undefined;\n    this.emit(_constants.EVENTS.ANNOTATION.DETACH, result);\n    return result;\n  }\n  /**\n   * [Not Implemented] Get text of an annotation\n   * @TODO: needs implementation in contents\n   */\n\n\n  text() {}\n\n}\n\n(0, _eventEmitter.default)(Annotation.prototype);\nvar _default = Annotations;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}