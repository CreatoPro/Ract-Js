{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _core = require(\"./utils/core\");\n\nvar _queue = _interopRequireDefault(require(\"./utils/queue\"));\n\nvar _epubcfi = _interopRequireDefault(require(\"./epubcfi\"));\n\nvar _constants = require(\"./utils/constants\");\n\nvar _eventEmitter = _interopRequireDefault(require(\"event-emitter\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Find Locations for a Book\n * @param {Spine} spine\n * @param {request} request\n * @param {number} [pause=100]\n */\n\n\nclass Locations {\n  constructor(spine, request, pause) {\n    this.spine = spine;\n    this.request = request;\n    this.pause = pause || 100;\n    this.q = new _queue.default(this);\n    this.epubcfi = new _epubcfi.default();\n    this._locations = [];\n    this._locationsWords = [];\n    this.total = 0;\n    this.break = 150;\n    this._current = 0;\n    this._wordCounter = 0;\n    this.currentLocation = '';\n    this._currentCfi = '';\n    this.processingTimeout = undefined;\n  }\n  /**\n   * Load all of sections in the book to generate locations\n   * @param  {int} chars how many chars to split on\n   * @return {Promise<Array<string>>} locations\n   */\n\n\n  generate(chars) {\n    if (chars) {\n      this.break = chars;\n    }\n\n    this.q.pause();\n    this.spine.each(function (section) {\n      if (section.linear) {\n        this.q.enqueue(this.process.bind(this), section);\n      }\n    }.bind(this));\n    return this.q.run().then(function () {\n      this.total = this._locations.length - 1;\n\n      if (this._currentCfi) {\n        this.currentLocation = this._currentCfi;\n      }\n\n      return this._locations; // console.log(this.percentage(this.book.rendition.location.start), this.percentage(this.book.rendition.location.end));\n    }.bind(this));\n  }\n\n  createRange() {\n    return {\n      startContainer: undefined,\n      startOffset: undefined,\n      endContainer: undefined,\n      endOffset: undefined\n    };\n  }\n\n  process(section) {\n    return section.load(this.request).then(function (contents) {\n      var completed = new _core.defer();\n      var locations = this.parse(contents, section.cfiBase);\n      this._locations = this._locations.concat(locations);\n      section.unload();\n      this.processingTimeout = setTimeout(() => completed.resolve(locations), this.pause);\n      return completed.promise;\n    }.bind(this));\n  }\n\n  parse(contents, cfiBase, chars) {\n    var locations = [];\n    var range;\n    var doc = contents.ownerDocument;\n    var body = (0, _core.qs)(doc, \"body\");\n    var counter = 0;\n    var prev;\n\n    var _break = chars || this.break;\n\n    var parser = function (node) {\n      var len = node.length;\n      var dist;\n      var pos = 0;\n\n      if (node.textContent.trim().length === 0) {\n        return false; // continue\n      } // Start range\n\n\n      if (counter == 0) {\n        range = this.createRange();\n        range.startContainer = node;\n        range.startOffset = 0;\n      }\n\n      dist = _break - counter; // Node is smaller than a break,\n      // skip over it\n\n      if (dist > len) {\n        counter += len;\n        pos = len;\n      }\n\n      while (pos < len) {\n        dist = _break - counter;\n\n        if (counter === 0) {\n          // Start new range\n          pos += 1;\n          range = this.createRange();\n          range.startContainer = node;\n          range.startOffset = pos;\n        } // pos += dist;\n        // Gone over\n\n\n        if (pos + dist >= len) {\n          // Continue counter for next node\n          counter += len - pos; // break\n\n          pos = len; // At End\n        } else {\n          // Advance pos\n          pos += dist; // End the previous range\n\n          range.endContainer = node;\n          range.endOffset = pos; // cfi = section.cfiFromRange(range);\n\n          let cfi = new _epubcfi.default(range, cfiBase).toString();\n          locations.push(cfi);\n          counter = 0;\n        }\n      }\n\n      prev = node;\n    };\n\n    (0, _core.sprint)(body, parser.bind(this)); // Close remaining\n\n    if (range && range.startContainer && prev) {\n      range.endContainer = prev;\n      range.endOffset = prev.length;\n      let cfi = new _epubcfi.default(range, cfiBase).toString();\n      locations.push(cfi);\n      counter = 0;\n    }\n\n    return locations;\n  }\n  /**\n   * Load all of sections in the book to generate locations\n   * @param  {string} startCfi start position\n   * @param  {int} wordCount how many words to split on\n   * @param  {int} count result count\n   * @return {object} locations\n   */\n\n\n  generateFromWords(startCfi, wordCount, count) {\n    var start = startCfi ? new _epubcfi.default(startCfi) : undefined;\n    this.q.pause();\n    this._locationsWords = [];\n    this._wordCounter = 0;\n    this.spine.each(function (section) {\n      if (section.linear) {\n        if (start) {\n          if (section.index >= start.spinePos) {\n            this.q.enqueue(this.processWords.bind(this), section, wordCount, start, count);\n          }\n        } else {\n          this.q.enqueue(this.processWords.bind(this), section, wordCount, start, count);\n        }\n      }\n    }.bind(this));\n    return this.q.run().then(function () {\n      if (this._currentCfi) {\n        this.currentLocation = this._currentCfi;\n      }\n\n      return this._locationsWords;\n    }.bind(this));\n  }\n\n  processWords(section, wordCount, startCfi, count) {\n    if (count && this._locationsWords.length >= count) {\n      return Promise.resolve();\n    }\n\n    return section.load(this.request).then(function (contents) {\n      var completed = new _core.defer();\n      var locations = this.parseWords(contents, section, wordCount, startCfi);\n      var remainingCount = count - this._locationsWords.length;\n      this._locationsWords = this._locationsWords.concat(locations.length >= count ? locations.slice(0, remainingCount) : locations);\n      section.unload();\n      this.processingTimeout = setTimeout(() => completed.resolve(locations), this.pause);\n      return completed.promise;\n    }.bind(this));\n  } //http://stackoverflow.com/questions/18679576/counting-words-in-string\n\n\n  countWords(s) {\n    s = s.replace(/(^\\s*)|(\\s*$)/gi, \"\"); //exclude  start and end white-space\n\n    s = s.replace(/[ ]{2,}/gi, \" \"); //2 or more space to 1\n\n    s = s.replace(/\\n /, \"\\n\"); // exclude newline with a start spacing\n\n    return s.split(\" \").length;\n  }\n\n  parseWords(contents, section, wordCount, startCfi) {\n    var cfiBase = section.cfiBase;\n    var locations = [];\n    var doc = contents.ownerDocument;\n    var body = (0, _core.qs)(doc, \"body\");\n    var prev;\n    var _break = wordCount;\n    var foundStartNode = startCfi ? startCfi.spinePos !== section.index : true;\n    var startNode;\n\n    if (startCfi && section.index === startCfi.spinePos) {\n      startNode = startCfi.findNode(startCfi.range ? startCfi.path.steps.concat(startCfi.start.steps) : startCfi.path.steps, contents.ownerDocument);\n    }\n\n    var parser = function (node) {\n      if (!foundStartNode) {\n        if (node === startNode) {\n          foundStartNode = true;\n        } else {\n          return false;\n        }\n      }\n\n      if (node.textContent.length < 10) {\n        if (node.textContent.trim().length === 0) {\n          return false;\n        }\n      }\n\n      var len = this.countWords(node.textContent);\n      var dist;\n      var pos = 0;\n\n      if (len === 0) {\n        return false; // continue\n      }\n\n      dist = _break - this._wordCounter; // Node is smaller than a break,\n      // skip over it\n\n      if (dist > len) {\n        this._wordCounter += len;\n        pos = len;\n      }\n\n      while (pos < len) {\n        dist = _break - this._wordCounter; // Gone over\n\n        if (pos + dist >= len) {\n          // Continue counter for next node\n          this._wordCounter += len - pos; // break\n\n          pos = len; // At End\n        } else {\n          // Advance pos\n          pos += dist;\n          let cfi = new _epubcfi.default(node, cfiBase);\n          locations.push({\n            cfi: cfi.toString(),\n            wordCount: this._wordCounter\n          });\n          this._wordCounter = 0;\n        }\n      }\n\n      prev = node;\n    };\n\n    (0, _core.sprint)(body, parser.bind(this));\n    return locations;\n  }\n  /**\n   * Get a location from an EpubCFI\n   * @param {EpubCFI} cfi\n   * @return {number}\n   */\n\n\n  locationFromCfi(cfi) {\n    let loc;\n\n    if (_epubcfi.default.prototype.isCfiString(cfi)) {\n      cfi = new _epubcfi.default(cfi);\n    } // Check if the location has not been set yet\n\n\n    if (this._locations.length === 0) {\n      return -1;\n    }\n\n    loc = (0, _core.locationOf)(cfi, this._locations, this.epubcfi.compare);\n\n    if (loc > this.total) {\n      return this.total;\n    }\n\n    return loc;\n  }\n  /**\n   * Get a percentage position in locations from an EpubCFI\n   * @param {EpubCFI} cfi\n   * @return {number}\n   */\n\n\n  percentageFromCfi(cfi) {\n    if (this._locations.length === 0) {\n      return null;\n    } // Find closest cfi\n\n\n    var loc = this.locationFromCfi(cfi); // Get percentage in total\n\n    return this.percentageFromLocation(loc);\n  }\n  /**\n   * Get a percentage position from a location index\n   * @param {number} location\n   * @return {number}\n   */\n\n\n  percentageFromLocation(loc) {\n    if (!loc || !this.total) {\n      return 0;\n    }\n\n    return loc / this.total;\n  }\n  /**\n   * Get an EpubCFI from location index\n   * @param {number} loc\n   * @return {EpubCFI} cfi\n   */\n\n\n  cfiFromLocation(loc) {\n    var cfi = -1; // check that pg is an int\n\n    if (typeof loc != \"number\") {\n      loc = parseInt(loc);\n    }\n\n    if (loc >= 0 && loc < this._locations.length) {\n      cfi = this._locations[loc];\n    }\n\n    return cfi;\n  }\n  /**\n   * Get an EpubCFI from location percentage\n   * @param {number} percentage\n   * @return {EpubCFI} cfi\n   */\n\n\n  cfiFromPercentage(percentage) {\n    let loc;\n\n    if (percentage > 1) {\n      console.warn(\"Normalize cfiFromPercentage value to between 0 - 1\");\n    } // Make sure 1 goes to very end\n\n\n    if (percentage >= 1) {\n      let cfi = new _epubcfi.default(this._locations[this.total]);\n      cfi.collapse();\n      return cfi.toString();\n    }\n\n    loc = Math.ceil(this.total * percentage);\n    return this.cfiFromLocation(loc);\n  }\n  /**\n   * Load locations from JSON\n   * @param {json} locations\n   */\n\n\n  load(locations) {\n    if (typeof locations === \"string\") {\n      this._locations = JSON.parse(locations);\n    } else {\n      this._locations = locations;\n    }\n\n    this.total = this._locations.length - 1;\n    return this._locations;\n  }\n  /**\n   * Save locations to JSON\n   * @return {json}\n   */\n\n\n  save() {\n    return JSON.stringify(this._locations);\n  }\n\n  getCurrent() {\n    return this._current;\n  }\n\n  setCurrent(curr) {\n    var loc;\n\n    if (typeof curr == \"string\") {\n      this._currentCfi = curr;\n    } else if (typeof curr == \"number\") {\n      this._current = curr;\n    } else {\n      return;\n    }\n\n    if (this._locations.length === 0) {\n      return;\n    }\n\n    if (typeof curr == \"string\") {\n      loc = this.locationFromCfi(curr);\n      this._current = loc;\n    } else {\n      loc = curr;\n    }\n\n    this.emit(_constants.EVENTS.LOCATIONS.CHANGED, {\n      percentage: this.percentageFromLocation(loc)\n    });\n  }\n  /**\n   * Get the current location\n   */\n\n\n  get currentLocation() {\n    return this._current;\n  }\n  /**\n   * Set the current location\n   */\n\n\n  set currentLocation(curr) {\n    this.setCurrent(curr);\n  }\n  /**\n   * Locations length\n   */\n\n\n  length() {\n    return this._locations.length;\n  }\n\n  destroy() {\n    this.spine = undefined;\n    this.request = undefined;\n    this.pause = undefined;\n    this.q.stop();\n    this.q = undefined;\n    this.epubcfi = undefined;\n    this._locations = undefined;\n    this.total = undefined;\n    this.break = undefined;\n    this._current = undefined;\n    this.currentLocation = undefined;\n    this._currentCfi = undefined;\n    clearTimeout(this.processingTimeout);\n  }\n\n}\n\n(0, _eventEmitter.default)(Locations.prototype);\nvar _default = Locations;\nexports.default = _default;","map":{"version":3,"sources":["S:/REACT/Ract-Js/Frlnce/node_modules/epubjs/lib/locations.js"],"names":["Object","defineProperty","exports","value","default","_core","require","_queue","_interopRequireDefault","_epubcfi","_constants","_eventEmitter","obj","__esModule","Locations","constructor","spine","request","pause","q","epubcfi","_locations","_locationsWords","total","break","_current","_wordCounter","currentLocation","_currentCfi","processingTimeout","undefined","generate","chars","each","section","linear","enqueue","process","bind","run","then","length","createRange","startContainer","startOffset","endContainer","endOffset","load","contents","completed","defer","locations","parse","cfiBase","concat","unload","setTimeout","resolve","promise","range","doc","ownerDocument","body","qs","counter","prev","_break","parser","node","len","dist","pos","textContent","trim","cfi","toString","push","sprint","generateFromWords","startCfi","wordCount","count","start","index","spinePos","processWords","Promise","parseWords","remainingCount","slice","countWords","s","replace","split","foundStartNode","startNode","findNode","path","steps","locationFromCfi","loc","prototype","isCfiString","locationOf","compare","percentageFromCfi","percentageFromLocation","cfiFromLocation","parseInt","cfiFromPercentage","percentage","console","warn","collapse","Math","ceil","JSON","save","stringify","getCurrent","setCurrent","curr","emit","EVENTS","LOCATIONS","CHANGED","destroy","stop","clearTimeout","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _core = require(\"./utils/core\");\n\nvar _queue = _interopRequireDefault(require(\"./utils/queue\"));\n\nvar _epubcfi = _interopRequireDefault(require(\"./epubcfi\"));\n\nvar _constants = require(\"./utils/constants\");\n\nvar _eventEmitter = _interopRequireDefault(require(\"event-emitter\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Find Locations for a Book\n * @param {Spine} spine\n * @param {request} request\n * @param {number} [pause=100]\n */\nclass Locations {\n  constructor(spine, request, pause) {\n    this.spine = spine;\n    this.request = request;\n    this.pause = pause || 100;\n    this.q = new _queue.default(this);\n    this.epubcfi = new _epubcfi.default();\n    this._locations = [];\n    this._locationsWords = [];\n    this.total = 0;\n    this.break = 150;\n    this._current = 0;\n    this._wordCounter = 0;\n    this.currentLocation = '';\n    this._currentCfi = '';\n    this.processingTimeout = undefined;\n  }\n  /**\n   * Load all of sections in the book to generate locations\n   * @param  {int} chars how many chars to split on\n   * @return {Promise<Array<string>>} locations\n   */\n\n\n  generate(chars) {\n    if (chars) {\n      this.break = chars;\n    }\n\n    this.q.pause();\n    this.spine.each(function (section) {\n      if (section.linear) {\n        this.q.enqueue(this.process.bind(this), section);\n      }\n    }.bind(this));\n    return this.q.run().then(function () {\n      this.total = this._locations.length - 1;\n\n      if (this._currentCfi) {\n        this.currentLocation = this._currentCfi;\n      }\n\n      return this._locations; // console.log(this.percentage(this.book.rendition.location.start), this.percentage(this.book.rendition.location.end));\n    }.bind(this));\n  }\n\n  createRange() {\n    return {\n      startContainer: undefined,\n      startOffset: undefined,\n      endContainer: undefined,\n      endOffset: undefined\n    };\n  }\n\n  process(section) {\n    return section.load(this.request).then(function (contents) {\n      var completed = new _core.defer();\n      var locations = this.parse(contents, section.cfiBase);\n      this._locations = this._locations.concat(locations);\n      section.unload();\n      this.processingTimeout = setTimeout(() => completed.resolve(locations), this.pause);\n      return completed.promise;\n    }.bind(this));\n  }\n\n  parse(contents, cfiBase, chars) {\n    var locations = [];\n    var range;\n    var doc = contents.ownerDocument;\n    var body = (0, _core.qs)(doc, \"body\");\n    var counter = 0;\n    var prev;\n\n    var _break = chars || this.break;\n\n    var parser = function (node) {\n      var len = node.length;\n      var dist;\n      var pos = 0;\n\n      if (node.textContent.trim().length === 0) {\n        return false; // continue\n      } // Start range\n\n\n      if (counter == 0) {\n        range = this.createRange();\n        range.startContainer = node;\n        range.startOffset = 0;\n      }\n\n      dist = _break - counter; // Node is smaller than a break,\n      // skip over it\n\n      if (dist > len) {\n        counter += len;\n        pos = len;\n      }\n\n      while (pos < len) {\n        dist = _break - counter;\n\n        if (counter === 0) {\n          // Start new range\n          pos += 1;\n          range = this.createRange();\n          range.startContainer = node;\n          range.startOffset = pos;\n        } // pos += dist;\n        // Gone over\n\n\n        if (pos + dist >= len) {\n          // Continue counter for next node\n          counter += len - pos; // break\n\n          pos = len; // At End\n        } else {\n          // Advance pos\n          pos += dist; // End the previous range\n\n          range.endContainer = node;\n          range.endOffset = pos; // cfi = section.cfiFromRange(range);\n\n          let cfi = new _epubcfi.default(range, cfiBase).toString();\n          locations.push(cfi);\n          counter = 0;\n        }\n      }\n\n      prev = node;\n    };\n\n    (0, _core.sprint)(body, parser.bind(this)); // Close remaining\n\n    if (range && range.startContainer && prev) {\n      range.endContainer = prev;\n      range.endOffset = prev.length;\n      let cfi = new _epubcfi.default(range, cfiBase).toString();\n      locations.push(cfi);\n      counter = 0;\n    }\n\n    return locations;\n  }\n  /**\n   * Load all of sections in the book to generate locations\n   * @param  {string} startCfi start position\n   * @param  {int} wordCount how many words to split on\n   * @param  {int} count result count\n   * @return {object} locations\n   */\n\n\n  generateFromWords(startCfi, wordCount, count) {\n    var start = startCfi ? new _epubcfi.default(startCfi) : undefined;\n    this.q.pause();\n    this._locationsWords = [];\n    this._wordCounter = 0;\n    this.spine.each(function (section) {\n      if (section.linear) {\n        if (start) {\n          if (section.index >= start.spinePos) {\n            this.q.enqueue(this.processWords.bind(this), section, wordCount, start, count);\n          }\n        } else {\n          this.q.enqueue(this.processWords.bind(this), section, wordCount, start, count);\n        }\n      }\n    }.bind(this));\n    return this.q.run().then(function () {\n      if (this._currentCfi) {\n        this.currentLocation = this._currentCfi;\n      }\n\n      return this._locationsWords;\n    }.bind(this));\n  }\n\n  processWords(section, wordCount, startCfi, count) {\n    if (count && this._locationsWords.length >= count) {\n      return Promise.resolve();\n    }\n\n    return section.load(this.request).then(function (contents) {\n      var completed = new _core.defer();\n      var locations = this.parseWords(contents, section, wordCount, startCfi);\n      var remainingCount = count - this._locationsWords.length;\n      this._locationsWords = this._locationsWords.concat(locations.length >= count ? locations.slice(0, remainingCount) : locations);\n      section.unload();\n      this.processingTimeout = setTimeout(() => completed.resolve(locations), this.pause);\n      return completed.promise;\n    }.bind(this));\n  } //http://stackoverflow.com/questions/18679576/counting-words-in-string\n\n\n  countWords(s) {\n    s = s.replace(/(^\\s*)|(\\s*$)/gi, \"\"); //exclude  start and end white-space\n\n    s = s.replace(/[ ]{2,}/gi, \" \"); //2 or more space to 1\n\n    s = s.replace(/\\n /, \"\\n\"); // exclude newline with a start spacing\n\n    return s.split(\" \").length;\n  }\n\n  parseWords(contents, section, wordCount, startCfi) {\n    var cfiBase = section.cfiBase;\n    var locations = [];\n    var doc = contents.ownerDocument;\n    var body = (0, _core.qs)(doc, \"body\");\n    var prev;\n    var _break = wordCount;\n    var foundStartNode = startCfi ? startCfi.spinePos !== section.index : true;\n    var startNode;\n\n    if (startCfi && section.index === startCfi.spinePos) {\n      startNode = startCfi.findNode(startCfi.range ? startCfi.path.steps.concat(startCfi.start.steps) : startCfi.path.steps, contents.ownerDocument);\n    }\n\n    var parser = function (node) {\n      if (!foundStartNode) {\n        if (node === startNode) {\n          foundStartNode = true;\n        } else {\n          return false;\n        }\n      }\n\n      if (node.textContent.length < 10) {\n        if (node.textContent.trim().length === 0) {\n          return false;\n        }\n      }\n\n      var len = this.countWords(node.textContent);\n      var dist;\n      var pos = 0;\n\n      if (len === 0) {\n        return false; // continue\n      }\n\n      dist = _break - this._wordCounter; // Node is smaller than a break,\n      // skip over it\n\n      if (dist > len) {\n        this._wordCounter += len;\n        pos = len;\n      }\n\n      while (pos < len) {\n        dist = _break - this._wordCounter; // Gone over\n\n        if (pos + dist >= len) {\n          // Continue counter for next node\n          this._wordCounter += len - pos; // break\n\n          pos = len; // At End\n        } else {\n          // Advance pos\n          pos += dist;\n          let cfi = new _epubcfi.default(node, cfiBase);\n          locations.push({\n            cfi: cfi.toString(),\n            wordCount: this._wordCounter\n          });\n          this._wordCounter = 0;\n        }\n      }\n\n      prev = node;\n    };\n\n    (0, _core.sprint)(body, parser.bind(this));\n    return locations;\n  }\n  /**\n   * Get a location from an EpubCFI\n   * @param {EpubCFI} cfi\n   * @return {number}\n   */\n\n\n  locationFromCfi(cfi) {\n    let loc;\n\n    if (_epubcfi.default.prototype.isCfiString(cfi)) {\n      cfi = new _epubcfi.default(cfi);\n    } // Check if the location has not been set yet\n\n\n    if (this._locations.length === 0) {\n      return -1;\n    }\n\n    loc = (0, _core.locationOf)(cfi, this._locations, this.epubcfi.compare);\n\n    if (loc > this.total) {\n      return this.total;\n    }\n\n    return loc;\n  }\n  /**\n   * Get a percentage position in locations from an EpubCFI\n   * @param {EpubCFI} cfi\n   * @return {number}\n   */\n\n\n  percentageFromCfi(cfi) {\n    if (this._locations.length === 0) {\n      return null;\n    } // Find closest cfi\n\n\n    var loc = this.locationFromCfi(cfi); // Get percentage in total\n\n    return this.percentageFromLocation(loc);\n  }\n  /**\n   * Get a percentage position from a location index\n   * @param {number} location\n   * @return {number}\n   */\n\n\n  percentageFromLocation(loc) {\n    if (!loc || !this.total) {\n      return 0;\n    }\n\n    return loc / this.total;\n  }\n  /**\n   * Get an EpubCFI from location index\n   * @param {number} loc\n   * @return {EpubCFI} cfi\n   */\n\n\n  cfiFromLocation(loc) {\n    var cfi = -1; // check that pg is an int\n\n    if (typeof loc != \"number\") {\n      loc = parseInt(loc);\n    }\n\n    if (loc >= 0 && loc < this._locations.length) {\n      cfi = this._locations[loc];\n    }\n\n    return cfi;\n  }\n  /**\n   * Get an EpubCFI from location percentage\n   * @param {number} percentage\n   * @return {EpubCFI} cfi\n   */\n\n\n  cfiFromPercentage(percentage) {\n    let loc;\n\n    if (percentage > 1) {\n      console.warn(\"Normalize cfiFromPercentage value to between 0 - 1\");\n    } // Make sure 1 goes to very end\n\n\n    if (percentage >= 1) {\n      let cfi = new _epubcfi.default(this._locations[this.total]);\n      cfi.collapse();\n      return cfi.toString();\n    }\n\n    loc = Math.ceil(this.total * percentage);\n    return this.cfiFromLocation(loc);\n  }\n  /**\n   * Load locations from JSON\n   * @param {json} locations\n   */\n\n\n  load(locations) {\n    if (typeof locations === \"string\") {\n      this._locations = JSON.parse(locations);\n    } else {\n      this._locations = locations;\n    }\n\n    this.total = this._locations.length - 1;\n    return this._locations;\n  }\n  /**\n   * Save locations to JSON\n   * @return {json}\n   */\n\n\n  save() {\n    return JSON.stringify(this._locations);\n  }\n\n  getCurrent() {\n    return this._current;\n  }\n\n  setCurrent(curr) {\n    var loc;\n\n    if (typeof curr == \"string\") {\n      this._currentCfi = curr;\n    } else if (typeof curr == \"number\") {\n      this._current = curr;\n    } else {\n      return;\n    }\n\n    if (this._locations.length === 0) {\n      return;\n    }\n\n    if (typeof curr == \"string\") {\n      loc = this.locationFromCfi(curr);\n      this._current = loc;\n    } else {\n      loc = curr;\n    }\n\n    this.emit(_constants.EVENTS.LOCATIONS.CHANGED, {\n      percentage: this.percentageFromLocation(loc)\n    });\n  }\n  /**\n   * Get the current location\n   */\n\n\n  get currentLocation() {\n    return this._current;\n  }\n  /**\n   * Set the current location\n   */\n\n\n  set currentLocation(curr) {\n    this.setCurrent(curr);\n  }\n  /**\n   * Locations length\n   */\n\n\n  length() {\n    return this._locations.length;\n  }\n\n  destroy() {\n    this.spine = undefined;\n    this.request = undefined;\n    this.pause = undefined;\n    this.q.stop();\n    this.q = undefined;\n    this.epubcfi = undefined;\n    this._locations = undefined;\n    this.total = undefined;\n    this.break = undefined;\n    this._current = undefined;\n    this.currentLocation = undefined;\n    this._currentCfi = undefined;\n    clearTimeout(this.processingTimeout);\n  }\n\n}\n\n(0, _eventEmitter.default)(Locations.prototype);\nvar _default = Locations;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}