{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _core = require(\"./utils/core\");\n\nvar _request = _interopRequireDefault(require(\"./utils/request\"));\n\nvar _mime = _interopRequireDefault(require(\"./utils/mime\"));\n\nvar _path = _interopRequireDefault(require(\"./utils/path\"));\n\nvar _eventEmitter = _interopRequireDefault(require(\"event-emitter\"));\n\nvar _localforage = _interopRequireDefault(require(\"localforage\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Handles saving and requesting files from local storage\n * @class\n * @param {string} name This should be the name of the application for modals\n * @param {function} [requester]\n * @param {function} [resolver]\n */\n\n\nclass Store {\n  constructor(name, requester, resolver) {\n    this.urlCache = {};\n    this.storage = undefined;\n    this.name = name;\n    this.requester = requester || _request.default;\n    this.resolver = resolver;\n    this.online = true;\n    this.checkRequirements();\n    this.addListeners();\n  }\n  /**\n   * Checks to see if localForage exists in global namspace,\n   * Requires localForage if it isn't there\n   * @private\n   */\n\n\n  checkRequirements() {\n    try {\n      let store;\n\n      if (typeof _localforage.default === \"undefined\") {\n        store = _localforage.default;\n      }\n\n      this.storage = store.createInstance({\n        name: this.name\n      });\n    } catch (e) {\n      throw new Error(\"localForage lib not loaded\");\n    }\n  }\n  /**\n   * Add online and offline event listeners\n   * @private\n   */\n\n\n  addListeners() {\n    this._status = this.status.bind(this);\n    window.addEventListener('online', this._status);\n    window.addEventListener('offline', this._status);\n  }\n  /**\n   * Remove online and offline event listeners\n   * @private\n   */\n\n\n  removeListeners() {\n    window.removeEventListener('online', this._status);\n    window.removeEventListener('offline', this._status);\n    this._status = undefined;\n  }\n  /**\n   * Update the online / offline status\n   * @private\n   */\n\n\n  status(event) {\n    let online = navigator.onLine;\n    this.online = online;\n\n    if (online) {\n      this.emit(\"online\", this);\n    } else {\n      this.emit(\"offline\", this);\n    }\n  }\n  /**\n   * Add all of a book resources to the store\n   * @param  {Resources} resources  book resources\n   * @param  {boolean} [force] force resaving resources\n   * @return {Promise<object>} store objects\n   */\n\n\n  add(resources, force) {\n    let mapped = resources.resources.map(item => {\n      let {\n        href\n      } = item;\n      let url = this.resolver(href);\n      let encodedUrl = window.encodeURIComponent(url);\n      return this.storage.getItem(encodedUrl).then(item => {\n        if (!item || force) {\n          return this.requester(url, \"binary\").then(data => {\n            return this.storage.setItem(encodedUrl, data);\n          });\n        } else {\n          return item;\n        }\n      });\n    });\n    return Promise.all(mapped);\n  }\n  /**\n   * Put binary data from a url to storage\n   * @param  {string} url  a url to request from storage\n   * @param  {boolean} [withCredentials]\n   * @param  {object} [headers]\n   * @return {Promise<Blob>}\n   */\n\n\n  put(url, withCredentials, headers) {\n    let encodedUrl = window.encodeURIComponent(url);\n    return this.storage.getItem(encodedUrl).then(result => {\n      if (!result) {\n        return this.requester(url, \"binary\", withCredentials, headers).then(data => {\n          return this.storage.setItem(encodedUrl, data);\n        });\n      }\n\n      return result;\n    });\n  }\n  /**\n   * Request a url\n   * @param  {string} url  a url to request from storage\n   * @param  {string} [type] specify the type of the returned result\n   * @param  {boolean} [withCredentials]\n   * @param  {object} [headers]\n   * @return {Promise<Blob | string | JSON | Document | XMLDocument>}\n   */\n\n\n  request(url, type, withCredentials, headers) {\n    if (this.online) {\n      // From network\n      return this.requester(url, type, withCredentials, headers).then(data => {\n        // save to store if not present\n        this.put(url);\n        return data;\n      });\n    } else {\n      // From store\n      return this.retrieve(url, type);\n    }\n  }\n  /**\n   * Request a url from storage\n   * @param  {string} url  a url to request from storage\n   * @param  {string} [type] specify the type of the returned result\n   * @return {Promise<Blob | string | JSON | Document | XMLDocument>}\n   */\n\n\n  retrieve(url, type) {\n    var deferred = new _core.defer();\n    var response;\n    var path = new _path.default(url); // If type isn't set, determine it from the file extension\n\n    if (!type) {\n      type = path.extension;\n    }\n\n    if (type == \"blob\") {\n      response = this.getBlob(url);\n    } else {\n      response = this.getText(url);\n    }\n\n    return response.then(r => {\n      var deferred = new _core.defer();\n      var result;\n\n      if (r) {\n        result = this.handleResponse(r, type);\n        deferred.resolve(result);\n      } else {\n        deferred.reject({\n          message: \"File not found in storage: \" + url,\n          stack: new Error().stack\n        });\n      }\n\n      return deferred.promise;\n    });\n  }\n  /**\n   * Handle the response from request\n   * @private\n   * @param  {any} response\n   * @param  {string} [type]\n   * @return {any} the parsed result\n   */\n\n\n  handleResponse(response, type) {\n    var r;\n\n    if (type == \"json\") {\n      r = JSON.parse(response);\n    } else if ((0, _core.isXml)(type)) {\n      r = (0, _core.parse)(response, \"text/xml\");\n    } else if (type == \"xhtml\") {\n      r = (0, _core.parse)(response, \"application/xhtml+xml\");\n    } else if (type == \"html\" || type == \"htm\") {\n      r = (0, _core.parse)(response, \"text/html\");\n    } else {\n      r = response;\n    }\n\n    return r;\n  }\n  /**\n   * Get a Blob from Storage by Url\n   * @param  {string} url\n   * @param  {string} [mimeType]\n   * @return {Blob}\n   */\n\n\n  getBlob(url, mimeType) {\n    let encodedUrl = window.encodeURIComponent(url);\n    return this.storage.getItem(encodedUrl).then(function (uint8array) {\n      if (!uint8array) return;\n      mimeType = mimeType || _mime.default.lookup(url);\n      return new Blob([uint8array], {\n        type: mimeType\n      });\n    });\n  }\n  /**\n   * Get Text from Storage by Url\n   * @param  {string} url\n   * @param  {string} [mimeType]\n   * @return {string}\n   */\n\n\n  getText(url, mimeType) {\n    let encodedUrl = window.encodeURIComponent(url);\n    mimeType = mimeType || _mime.default.lookup(url);\n    return this.storage.getItem(encodedUrl).then(function (uint8array) {\n      var deferred = new _core.defer();\n      var reader = new FileReader();\n      var blob;\n      if (!uint8array) return;\n      blob = new Blob([uint8array], {\n        type: mimeType\n      });\n      reader.addEventListener(\"loadend\", () => {\n        deferred.resolve(reader.result);\n      });\n      reader.readAsText(blob, mimeType);\n      return deferred.promise;\n    });\n  }\n  /**\n   * Get a base64 encoded result from Storage by Url\n   * @param  {string} url\n   * @param  {string} [mimeType]\n   * @return {string} base64 encoded\n   */\n\n\n  getBase64(url, mimeType) {\n    let encodedUrl = window.encodeURIComponent(url);\n    mimeType = mimeType || _mime.default.lookup(url);\n    return this.storage.getItem(encodedUrl).then(uint8array => {\n      var deferred = new _core.defer();\n      var reader = new FileReader();\n      var blob;\n      if (!uint8array) return;\n      blob = new Blob([uint8array], {\n        type: mimeType\n      });\n      reader.addEventListener(\"loadend\", () => {\n        deferred.resolve(reader.result);\n      });\n      reader.readAsDataURL(blob, mimeType);\n      return deferred.promise;\n    });\n  }\n  /**\n   * Create a Url from a stored item\n   * @param  {string} url\n   * @param  {object} [options.base64] use base64 encoding or blob url\n   * @return {Promise} url promise with Url string\n   */\n\n\n  createUrl(url, options) {\n    var deferred = new _core.defer();\n\n    var _URL = window.URL || window.webkitURL || window.mozURL;\n\n    var tempUrl;\n    var response;\n    var useBase64 = options && options.base64;\n\n    if (url in this.urlCache) {\n      deferred.resolve(this.urlCache[url]);\n      return deferred.promise;\n    }\n\n    if (useBase64) {\n      response = this.getBase64(url);\n\n      if (response) {\n        response.then(function (tempUrl) {\n          this.urlCache[url] = tempUrl;\n          deferred.resolve(tempUrl);\n        }.bind(this));\n      }\n    } else {\n      response = this.getBlob(url);\n\n      if (response) {\n        response.then(function (blob) {\n          tempUrl = _URL.createObjectURL(blob);\n          this.urlCache[url] = tempUrl;\n          deferred.resolve(tempUrl);\n        }.bind(this));\n      }\n    }\n\n    if (!response) {\n      deferred.reject({\n        message: \"File not found in storage: \" + url,\n        stack: new Error().stack\n      });\n    }\n\n    return deferred.promise;\n  }\n  /**\n   * Revoke Temp Url for a archive item\n   * @param  {string} url url of the item in the store\n   */\n\n\n  revokeUrl(url) {\n    var _URL = window.URL || window.webkitURL || window.mozURL;\n\n    var fromCache = this.urlCache[url];\n    if (fromCache) _URL.revokeObjectURL(fromCache);\n  }\n\n  destroy() {\n    var _URL = window.URL || window.webkitURL || window.mozURL;\n\n    for (let fromCache in this.urlCache) {\n      _URL.revokeObjectURL(fromCache);\n    }\n\n    this.urlCache = {};\n    this.removeListeners();\n  }\n\n}\n\n(0, _eventEmitter.default)(Store.prototype);\nvar _default = Store;\nexports.default = _default;","map":{"version":3,"sources":["S:/REACT/Ract-Js/Frlnce/node_modules/epubjs/lib/store.js"],"names":["Object","defineProperty","exports","value","default","_core","require","_request","_interopRequireDefault","_mime","_path","_eventEmitter","_localforage","obj","__esModule","Store","constructor","name","requester","resolver","urlCache","storage","undefined","online","checkRequirements","addListeners","store","createInstance","e","Error","_status","status","bind","window","addEventListener","removeListeners","removeEventListener","event","navigator","onLine","emit","add","resources","force","mapped","map","item","href","url","encodedUrl","encodeURIComponent","getItem","then","data","setItem","Promise","all","put","withCredentials","headers","result","request","type","retrieve","deferred","defer","response","path","extension","getBlob","getText","r","handleResponse","resolve","reject","message","stack","promise","JSON","parse","isXml","mimeType","uint8array","lookup","Blob","reader","FileReader","blob","readAsText","getBase64","readAsDataURL","createUrl","options","_URL","URL","webkitURL","mozURL","tempUrl","useBase64","base64","createObjectURL","revokeUrl","fromCache","revokeObjectURL","destroy","prototype","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _core = require(\"./utils/core\");\n\nvar _request = _interopRequireDefault(require(\"./utils/request\"));\n\nvar _mime = _interopRequireDefault(require(\"./utils/mime\"));\n\nvar _path = _interopRequireDefault(require(\"./utils/path\"));\n\nvar _eventEmitter = _interopRequireDefault(require(\"event-emitter\"));\n\nvar _localforage = _interopRequireDefault(require(\"localforage\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Handles saving and requesting files from local storage\n * @class\n * @param {string} name This should be the name of the application for modals\n * @param {function} [requester]\n * @param {function} [resolver]\n */\nclass Store {\n  constructor(name, requester, resolver) {\n    this.urlCache = {};\n    this.storage = undefined;\n    this.name = name;\n    this.requester = requester || _request.default;\n    this.resolver = resolver;\n    this.online = true;\n    this.checkRequirements();\n    this.addListeners();\n  }\n  /**\n   * Checks to see if localForage exists in global namspace,\n   * Requires localForage if it isn't there\n   * @private\n   */\n\n\n  checkRequirements() {\n    try {\n      let store;\n\n      if (typeof _localforage.default === \"undefined\") {\n        store = _localforage.default;\n      }\n\n      this.storage = store.createInstance({\n        name: this.name\n      });\n    } catch (e) {\n      throw new Error(\"localForage lib not loaded\");\n    }\n  }\n  /**\n   * Add online and offline event listeners\n   * @private\n   */\n\n\n  addListeners() {\n    this._status = this.status.bind(this);\n    window.addEventListener('online', this._status);\n    window.addEventListener('offline', this._status);\n  }\n  /**\n   * Remove online and offline event listeners\n   * @private\n   */\n\n\n  removeListeners() {\n    window.removeEventListener('online', this._status);\n    window.removeEventListener('offline', this._status);\n    this._status = undefined;\n  }\n  /**\n   * Update the online / offline status\n   * @private\n   */\n\n\n  status(event) {\n    let online = navigator.onLine;\n    this.online = online;\n\n    if (online) {\n      this.emit(\"online\", this);\n    } else {\n      this.emit(\"offline\", this);\n    }\n  }\n  /**\n   * Add all of a book resources to the store\n   * @param  {Resources} resources  book resources\n   * @param  {boolean} [force] force resaving resources\n   * @return {Promise<object>} store objects\n   */\n\n\n  add(resources, force) {\n    let mapped = resources.resources.map(item => {\n      let {\n        href\n      } = item;\n      let url = this.resolver(href);\n      let encodedUrl = window.encodeURIComponent(url);\n      return this.storage.getItem(encodedUrl).then(item => {\n        if (!item || force) {\n          return this.requester(url, \"binary\").then(data => {\n            return this.storage.setItem(encodedUrl, data);\n          });\n        } else {\n          return item;\n        }\n      });\n    });\n    return Promise.all(mapped);\n  }\n  /**\n   * Put binary data from a url to storage\n   * @param  {string} url  a url to request from storage\n   * @param  {boolean} [withCredentials]\n   * @param  {object} [headers]\n   * @return {Promise<Blob>}\n   */\n\n\n  put(url, withCredentials, headers) {\n    let encodedUrl = window.encodeURIComponent(url);\n    return this.storage.getItem(encodedUrl).then(result => {\n      if (!result) {\n        return this.requester(url, \"binary\", withCredentials, headers).then(data => {\n          return this.storage.setItem(encodedUrl, data);\n        });\n      }\n\n      return result;\n    });\n  }\n  /**\n   * Request a url\n   * @param  {string} url  a url to request from storage\n   * @param  {string} [type] specify the type of the returned result\n   * @param  {boolean} [withCredentials]\n   * @param  {object} [headers]\n   * @return {Promise<Blob | string | JSON | Document | XMLDocument>}\n   */\n\n\n  request(url, type, withCredentials, headers) {\n    if (this.online) {\n      // From network\n      return this.requester(url, type, withCredentials, headers).then(data => {\n        // save to store if not present\n        this.put(url);\n        return data;\n      });\n    } else {\n      // From store\n      return this.retrieve(url, type);\n    }\n  }\n  /**\n   * Request a url from storage\n   * @param  {string} url  a url to request from storage\n   * @param  {string} [type] specify the type of the returned result\n   * @return {Promise<Blob | string | JSON | Document | XMLDocument>}\n   */\n\n\n  retrieve(url, type) {\n    var deferred = new _core.defer();\n    var response;\n    var path = new _path.default(url); // If type isn't set, determine it from the file extension\n\n    if (!type) {\n      type = path.extension;\n    }\n\n    if (type == \"blob\") {\n      response = this.getBlob(url);\n    } else {\n      response = this.getText(url);\n    }\n\n    return response.then(r => {\n      var deferred = new _core.defer();\n      var result;\n\n      if (r) {\n        result = this.handleResponse(r, type);\n        deferred.resolve(result);\n      } else {\n        deferred.reject({\n          message: \"File not found in storage: \" + url,\n          stack: new Error().stack\n        });\n      }\n\n      return deferred.promise;\n    });\n  }\n  /**\n   * Handle the response from request\n   * @private\n   * @param  {any} response\n   * @param  {string} [type]\n   * @return {any} the parsed result\n   */\n\n\n  handleResponse(response, type) {\n    var r;\n\n    if (type == \"json\") {\n      r = JSON.parse(response);\n    } else if ((0, _core.isXml)(type)) {\n      r = (0, _core.parse)(response, \"text/xml\");\n    } else if (type == \"xhtml\") {\n      r = (0, _core.parse)(response, \"application/xhtml+xml\");\n    } else if (type == \"html\" || type == \"htm\") {\n      r = (0, _core.parse)(response, \"text/html\");\n    } else {\n      r = response;\n    }\n\n    return r;\n  }\n  /**\n   * Get a Blob from Storage by Url\n   * @param  {string} url\n   * @param  {string} [mimeType]\n   * @return {Blob}\n   */\n\n\n  getBlob(url, mimeType) {\n    let encodedUrl = window.encodeURIComponent(url);\n    return this.storage.getItem(encodedUrl).then(function (uint8array) {\n      if (!uint8array) return;\n      mimeType = mimeType || _mime.default.lookup(url);\n      return new Blob([uint8array], {\n        type: mimeType\n      });\n    });\n  }\n  /**\n   * Get Text from Storage by Url\n   * @param  {string} url\n   * @param  {string} [mimeType]\n   * @return {string}\n   */\n\n\n  getText(url, mimeType) {\n    let encodedUrl = window.encodeURIComponent(url);\n    mimeType = mimeType || _mime.default.lookup(url);\n    return this.storage.getItem(encodedUrl).then(function (uint8array) {\n      var deferred = new _core.defer();\n      var reader = new FileReader();\n      var blob;\n      if (!uint8array) return;\n      blob = new Blob([uint8array], {\n        type: mimeType\n      });\n      reader.addEventListener(\"loadend\", () => {\n        deferred.resolve(reader.result);\n      });\n      reader.readAsText(blob, mimeType);\n      return deferred.promise;\n    });\n  }\n  /**\n   * Get a base64 encoded result from Storage by Url\n   * @param  {string} url\n   * @param  {string} [mimeType]\n   * @return {string} base64 encoded\n   */\n\n\n  getBase64(url, mimeType) {\n    let encodedUrl = window.encodeURIComponent(url);\n    mimeType = mimeType || _mime.default.lookup(url);\n    return this.storage.getItem(encodedUrl).then(uint8array => {\n      var deferred = new _core.defer();\n      var reader = new FileReader();\n      var blob;\n      if (!uint8array) return;\n      blob = new Blob([uint8array], {\n        type: mimeType\n      });\n      reader.addEventListener(\"loadend\", () => {\n        deferred.resolve(reader.result);\n      });\n      reader.readAsDataURL(blob, mimeType);\n      return deferred.promise;\n    });\n  }\n  /**\n   * Create a Url from a stored item\n   * @param  {string} url\n   * @param  {object} [options.base64] use base64 encoding or blob url\n   * @return {Promise} url promise with Url string\n   */\n\n\n  createUrl(url, options) {\n    var deferred = new _core.defer();\n\n    var _URL = window.URL || window.webkitURL || window.mozURL;\n\n    var tempUrl;\n    var response;\n    var useBase64 = options && options.base64;\n\n    if (url in this.urlCache) {\n      deferred.resolve(this.urlCache[url]);\n      return deferred.promise;\n    }\n\n    if (useBase64) {\n      response = this.getBase64(url);\n\n      if (response) {\n        response.then(function (tempUrl) {\n          this.urlCache[url] = tempUrl;\n          deferred.resolve(tempUrl);\n        }.bind(this));\n      }\n    } else {\n      response = this.getBlob(url);\n\n      if (response) {\n        response.then(function (blob) {\n          tempUrl = _URL.createObjectURL(blob);\n          this.urlCache[url] = tempUrl;\n          deferred.resolve(tempUrl);\n        }.bind(this));\n      }\n    }\n\n    if (!response) {\n      deferred.reject({\n        message: \"File not found in storage: \" + url,\n        stack: new Error().stack\n      });\n    }\n\n    return deferred.promise;\n  }\n  /**\n   * Revoke Temp Url for a archive item\n   * @param  {string} url url of the item in the store\n   */\n\n\n  revokeUrl(url) {\n    var _URL = window.URL || window.webkitURL || window.mozURL;\n\n    var fromCache = this.urlCache[url];\n    if (fromCache) _URL.revokeObjectURL(fromCache);\n  }\n\n  destroy() {\n    var _URL = window.URL || window.webkitURL || window.mozURL;\n\n    for (let fromCache in this.urlCache) {\n      _URL.revokeObjectURL(fromCache);\n    }\n\n    this.urlCache = {};\n    this.removeListeners();\n  }\n\n}\n\n(0, _eventEmitter.default)(Store.prototype);\nvar _default = Store;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}