{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _epubcfi = _interopRequireDefault(require(\"./epubcfi\"));\n\nvar _core = require(\"./utils/core\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Map text locations to CFI ranges\n * @class\n * @param {Layout} layout Layout to apply\n * @param {string} [direction=\"ltr\"] Text direction\n * @param {string} [axis=\"horizontal\"] vertical or horizontal axis\n * @param {boolean} [dev] toggle developer highlighting\n */\n\n\nclass Mapping {\n  constructor(layout, direction, axis) {\n    let dev = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    this.layout = layout;\n    this.horizontal = axis === \"horizontal\" ? true : false;\n    this.direction = direction || \"ltr\";\n    this._dev = dev;\n  }\n  /**\n   * Find CFI pairs for entire section at once\n   */\n\n\n  section(view) {\n    var ranges = this.findRanges(view);\n    var map = this.rangeListToCfiList(view.section.cfiBase, ranges);\n    return map;\n  }\n  /**\n   * Find CFI pairs for a page\n   * @param {Contents} contents Contents from view\n   * @param {string} cfiBase string of the base for a cfi\n   * @param {number} start position to start at\n   * @param {number} end position to end at\n   */\n\n\n  page(contents, cfiBase, start, end) {\n    var root = contents && contents.document ? contents.document.body : false;\n    var result;\n\n    if (!root) {\n      return;\n    }\n\n    result = this.rangePairToCfiPair(cfiBase, {\n      start: this.findStart(root, start, end),\n      end: this.findEnd(root, start, end)\n    });\n\n    if (this._dev === true) {\n      let doc = contents.document;\n      let startRange = new _epubcfi.default(result.start).toRange(doc);\n      let endRange = new _epubcfi.default(result.end).toRange(doc);\n      let selection = doc.defaultView.getSelection();\n      let r = doc.createRange();\n      selection.removeAllRanges();\n      r.setStart(startRange.startContainer, startRange.startOffset);\n      r.setEnd(endRange.endContainer, endRange.endOffset);\n      selection.addRange(r);\n    }\n\n    return result;\n  }\n  /**\n   * Walk a node, preforming a function on each node it finds\n   * @private\n   * @param {Node} root Node to walkToNode\n   * @param {function} func walk function\n   * @return {*} returns the result of the walk function\n   */\n\n\n  walk(root, func) {\n    // IE11 has strange issue, if root is text node IE throws exception on\n    // calling treeWalker.nextNode(), saying\n    // Unexpected call to method or property access instead of returning null value\n    if (root && root.nodeType === Node.TEXT_NODE) {\n      return;\n    } // safeFilter is required so that it can work in IE as filter is a function for IE\n    // and for other browser filter is an object.\n\n\n    var filter = {\n      acceptNode: function (node) {\n        if (node.data.trim().length > 0) {\n          return NodeFilter.FILTER_ACCEPT;\n        } else {\n          return NodeFilter.FILTER_REJECT;\n        }\n      }\n    };\n    var safeFilter = filter.acceptNode;\n    safeFilter.acceptNode = filter.acceptNode;\n    var treeWalker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, safeFilter, false);\n    var node;\n    var result;\n\n    while (node = treeWalker.nextNode()) {\n      result = func(node);\n      if (result) break;\n    }\n\n    return result;\n  }\n\n  findRanges(view) {\n    var columns = [];\n    var scrollWidth = view.contents.scrollWidth();\n    var spreads = Math.ceil(scrollWidth / this.layout.spreadWidth);\n    var count = spreads * this.layout.divisor;\n    var columnWidth = this.layout.columnWidth;\n    var gap = this.layout.gap;\n    var start, end;\n\n    for (var i = 0; i < count.pages; i++) {\n      start = (columnWidth + gap) * i;\n      end = columnWidth * (i + 1) + gap * i;\n      columns.push({\n        start: this.findStart(view.document.body, start, end),\n        end: this.findEnd(view.document.body, start, end)\n      });\n    }\n\n    return columns;\n  }\n  /**\n   * Find Start Range\n   * @private\n   * @param {Node} root root node\n   * @param {number} start position to start at\n   * @param {number} end position to end at\n   * @return {Range}\n   */\n\n\n  findStart(root, start, end) {\n    var stack = [root];\n    var $el;\n    var found;\n    var $prev = root;\n\n    while (stack.length) {\n      $el = stack.shift();\n      found = this.walk($el, node => {\n        var left, right, top, bottom;\n        var elPos;\n        var elRange;\n        elPos = (0, _core.nodeBounds)(node);\n\n        if (this.horizontal && this.direction === \"ltr\") {\n          left = this.horizontal ? elPos.left : elPos.top;\n          right = this.horizontal ? elPos.right : elPos.bottom;\n\n          if (left >= start && left <= end) {\n            return node;\n          } else if (right > start) {\n            return node;\n          } else {\n            $prev = node;\n            stack.push(node);\n          }\n        } else if (this.horizontal && this.direction === \"rtl\") {\n          left = elPos.left;\n          right = elPos.right;\n\n          if (right <= end && right >= start) {\n            return node;\n          } else if (left < end) {\n            return node;\n          } else {\n            $prev = node;\n            stack.push(node);\n          }\n        } else {\n          top = elPos.top;\n          bottom = elPos.bottom;\n\n          if (top >= start && top <= end) {\n            return node;\n          } else if (bottom > start) {\n            return node;\n          } else {\n            $prev = node;\n            stack.push(node);\n          }\n        }\n      });\n\n      if (found) {\n        return this.findTextStartRange(found, start, end);\n      }\n    } // Return last element\n\n\n    return this.findTextStartRange($prev, start, end);\n  }\n  /**\n   * Find End Range\n   * @private\n   * @param {Node} root root node\n   * @param {number} start position to start at\n   * @param {number} end position to end at\n   * @return {Range}\n   */\n\n\n  findEnd(root, start, end) {\n    var stack = [root];\n    var $el;\n    var $prev = root;\n    var found;\n\n    while (stack.length) {\n      $el = stack.shift();\n      found = this.walk($el, node => {\n        var left, right, top, bottom;\n        var elPos;\n        var elRange;\n        elPos = (0, _core.nodeBounds)(node);\n\n        if (this.horizontal && this.direction === \"ltr\") {\n          left = Math.round(elPos.left);\n          right = Math.round(elPos.right);\n\n          if (left > end && $prev) {\n            return $prev;\n          } else if (right > end) {\n            return node;\n          } else {\n            $prev = node;\n            stack.push(node);\n          }\n        } else if (this.horizontal && this.direction === \"rtl\") {\n          left = Math.round(this.horizontal ? elPos.left : elPos.top);\n          right = Math.round(this.horizontal ? elPos.right : elPos.bottom);\n\n          if (right < start && $prev) {\n            return $prev;\n          } else if (left < start) {\n            return node;\n          } else {\n            $prev = node;\n            stack.push(node);\n          }\n        } else {\n          top = Math.round(elPos.top);\n          bottom = Math.round(elPos.bottom);\n\n          if (top > end && $prev) {\n            return $prev;\n          } else if (bottom > end) {\n            return node;\n          } else {\n            $prev = node;\n            stack.push(node);\n          }\n        }\n      });\n\n      if (found) {\n        return this.findTextEndRange(found, start, end);\n      }\n    } // end of chapter\n\n\n    return this.findTextEndRange($prev, start, end);\n  }\n  /**\n   * Find Text Start Range\n   * @private\n   * @param {Node} root root node\n   * @param {number} start position to start at\n   * @param {number} end position to end at\n   * @return {Range}\n   */\n\n\n  findTextStartRange(node, start, end) {\n    var ranges = this.splitTextNodeIntoRanges(node);\n    var range;\n    var pos;\n    var left, top, right;\n\n    for (var i = 0; i < ranges.length; i++) {\n      range = ranges[i];\n      pos = range.getBoundingClientRect();\n\n      if (this.horizontal && this.direction === \"ltr\") {\n        left = pos.left;\n\n        if (left >= start) {\n          return range;\n        }\n      } else if (this.horizontal && this.direction === \"rtl\") {\n        right = pos.right;\n\n        if (right <= end) {\n          return range;\n        }\n      } else {\n        top = pos.top;\n\n        if (top >= start) {\n          return range;\n        }\n      } // prev = range;\n\n    }\n\n    return ranges[0];\n  }\n  /**\n   * Find Text End Range\n   * @private\n   * @param {Node} root root node\n   * @param {number} start position to start at\n   * @param {number} end position to end at\n   * @return {Range}\n   */\n\n\n  findTextEndRange(node, start, end) {\n    var ranges = this.splitTextNodeIntoRanges(node);\n    var prev;\n    var range;\n    var pos;\n    var left, right, top, bottom;\n\n    for (var i = 0; i < ranges.length; i++) {\n      range = ranges[i];\n      pos = range.getBoundingClientRect();\n\n      if (this.horizontal && this.direction === \"ltr\") {\n        left = pos.left;\n        right = pos.right;\n\n        if (left > end && prev) {\n          return prev;\n        } else if (right > end) {\n          return range;\n        }\n      } else if (this.horizontal && this.direction === \"rtl\") {\n        left = pos.left;\n        right = pos.right;\n\n        if (right < start && prev) {\n          return prev;\n        } else if (left < start) {\n          return range;\n        }\n      } else {\n        top = pos.top;\n        bottom = pos.bottom;\n\n        if (top > end && prev) {\n          return prev;\n        } else if (bottom > end) {\n          return range;\n        }\n      }\n\n      prev = range;\n    } // Ends before limit\n\n\n    return ranges[ranges.length - 1];\n  }\n  /**\n   * Split up a text node into ranges for each word\n   * @private\n   * @param {Node} root root node\n   * @param {string} [_splitter] what to split on\n   * @return {Range[]}\n   */\n\n\n  splitTextNodeIntoRanges(node, _splitter) {\n    var ranges = [];\n    var textContent = node.textContent || \"\";\n    var text = textContent.trim();\n    var range;\n    var doc = node.ownerDocument;\n    var splitter = _splitter || \" \";\n    var pos = text.indexOf(splitter);\n\n    if (pos === -1 || node.nodeType != Node.TEXT_NODE) {\n      range = doc.createRange();\n      range.selectNodeContents(node);\n      return [range];\n    }\n\n    range = doc.createRange();\n    range.setStart(node, 0);\n    range.setEnd(node, pos);\n    ranges.push(range);\n    range = false;\n\n    while (pos != -1) {\n      pos = text.indexOf(splitter, pos + 1);\n\n      if (pos > 0) {\n        if (range) {\n          range.setEnd(node, pos);\n          ranges.push(range);\n        }\n\n        range = doc.createRange();\n        range.setStart(node, pos + 1);\n      }\n    }\n\n    if (range) {\n      range.setEnd(node, text.length);\n      ranges.push(range);\n    }\n\n    return ranges;\n  }\n  /**\n   * Turn a pair of ranges into a pair of CFIs\n   * @private\n   * @param {string} cfiBase base string for an EpubCFI\n   * @param {object} rangePair { start: Range, end: Range }\n   * @return {object} { start: \"epubcfi(...)\", end: \"epubcfi(...)\" }\n   */\n\n\n  rangePairToCfiPair(cfiBase, rangePair) {\n    var startRange = rangePair.start;\n    var endRange = rangePair.end;\n    startRange.collapse(true);\n    endRange.collapse(false);\n    let startCfi = new _epubcfi.default(startRange, cfiBase).toString();\n    let endCfi = new _epubcfi.default(endRange, cfiBase).toString();\n    return {\n      start: startCfi,\n      end: endCfi\n    };\n  }\n\n  rangeListToCfiList(cfiBase, columns) {\n    var map = [];\n    var cifPair;\n\n    for (var i = 0; i < columns.length; i++) {\n      cifPair = this.rangePairToCfiPair(cfiBase, columns[i]);\n      map.push(cifPair);\n    }\n\n    return map;\n  }\n  /**\n   * Set the axis for mapping\n   * @param {string} axis horizontal | vertical\n   * @return {boolean} is it horizontal?\n   */\n\n\n  axis(axis) {\n    if (axis) {\n      this.horizontal = axis === \"horizontal\" ? true : false;\n    }\n\n    return this.horizontal;\n  }\n\n}\n\nvar _default = Mapping;\nexports.default = _default;","map":{"version":3,"sources":["S:/REACT/Ract-Js/Frlnce/node_modules/epubjs/lib/mapping.js"],"names":["Object","defineProperty","exports","value","default","_epubcfi","_interopRequireDefault","require","_core","obj","__esModule","Mapping","constructor","layout","direction","axis","dev","horizontal","_dev","section","view","ranges","findRanges","map","rangeListToCfiList","cfiBase","page","contents","start","end","root","document","body","result","rangePairToCfiPair","findStart","findEnd","doc","startRange","toRange","endRange","selection","defaultView","getSelection","r","createRange","removeAllRanges","setStart","startContainer","startOffset","setEnd","endContainer","endOffset","addRange","walk","func","nodeType","Node","TEXT_NODE","filter","acceptNode","node","data","trim","length","NodeFilter","FILTER_ACCEPT","FILTER_REJECT","safeFilter","treeWalker","createTreeWalker","SHOW_TEXT","nextNode","columns","scrollWidth","spreads","Math","ceil","spreadWidth","count","divisor","columnWidth","gap","i","pages","push","stack","$el","found","$prev","shift","left","right","top","bottom","elPos","elRange","nodeBounds","findTextStartRange","round","findTextEndRange","splitTextNodeIntoRanges","range","pos","getBoundingClientRect","prev","_splitter","textContent","text","ownerDocument","splitter","indexOf","selectNodeContents","rangePair","collapse","startCfi","toString","endCfi","cifPair","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _epubcfi = _interopRequireDefault(require(\"./epubcfi\"));\n\nvar _core = require(\"./utils/core\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Map text locations to CFI ranges\n * @class\n * @param {Layout} layout Layout to apply\n * @param {string} [direction=\"ltr\"] Text direction\n * @param {string} [axis=\"horizontal\"] vertical or horizontal axis\n * @param {boolean} [dev] toggle developer highlighting\n */\nclass Mapping {\n  constructor(layout, direction, axis, dev = false) {\n    this.layout = layout;\n    this.horizontal = axis === \"horizontal\" ? true : false;\n    this.direction = direction || \"ltr\";\n    this._dev = dev;\n  }\n  /**\n   * Find CFI pairs for entire section at once\n   */\n\n\n  section(view) {\n    var ranges = this.findRanges(view);\n    var map = this.rangeListToCfiList(view.section.cfiBase, ranges);\n    return map;\n  }\n  /**\n   * Find CFI pairs for a page\n   * @param {Contents} contents Contents from view\n   * @param {string} cfiBase string of the base for a cfi\n   * @param {number} start position to start at\n   * @param {number} end position to end at\n   */\n\n\n  page(contents, cfiBase, start, end) {\n    var root = contents && contents.document ? contents.document.body : false;\n    var result;\n\n    if (!root) {\n      return;\n    }\n\n    result = this.rangePairToCfiPair(cfiBase, {\n      start: this.findStart(root, start, end),\n      end: this.findEnd(root, start, end)\n    });\n\n    if (this._dev === true) {\n      let doc = contents.document;\n      let startRange = new _epubcfi.default(result.start).toRange(doc);\n      let endRange = new _epubcfi.default(result.end).toRange(doc);\n      let selection = doc.defaultView.getSelection();\n      let r = doc.createRange();\n      selection.removeAllRanges();\n      r.setStart(startRange.startContainer, startRange.startOffset);\n      r.setEnd(endRange.endContainer, endRange.endOffset);\n      selection.addRange(r);\n    }\n\n    return result;\n  }\n  /**\n   * Walk a node, preforming a function on each node it finds\n   * @private\n   * @param {Node} root Node to walkToNode\n   * @param {function} func walk function\n   * @return {*} returns the result of the walk function\n   */\n\n\n  walk(root, func) {\n    // IE11 has strange issue, if root is text node IE throws exception on\n    // calling treeWalker.nextNode(), saying\n    // Unexpected call to method or property access instead of returning null value\n    if (root && root.nodeType === Node.TEXT_NODE) {\n      return;\n    } // safeFilter is required so that it can work in IE as filter is a function for IE\n    // and for other browser filter is an object.\n\n\n    var filter = {\n      acceptNode: function (node) {\n        if (node.data.trim().length > 0) {\n          return NodeFilter.FILTER_ACCEPT;\n        } else {\n          return NodeFilter.FILTER_REJECT;\n        }\n      }\n    };\n    var safeFilter = filter.acceptNode;\n    safeFilter.acceptNode = filter.acceptNode;\n    var treeWalker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, safeFilter, false);\n    var node;\n    var result;\n\n    while (node = treeWalker.nextNode()) {\n      result = func(node);\n      if (result) break;\n    }\n\n    return result;\n  }\n\n  findRanges(view) {\n    var columns = [];\n    var scrollWidth = view.contents.scrollWidth();\n    var spreads = Math.ceil(scrollWidth / this.layout.spreadWidth);\n    var count = spreads * this.layout.divisor;\n    var columnWidth = this.layout.columnWidth;\n    var gap = this.layout.gap;\n    var start, end;\n\n    for (var i = 0; i < count.pages; i++) {\n      start = (columnWidth + gap) * i;\n      end = columnWidth * (i + 1) + gap * i;\n      columns.push({\n        start: this.findStart(view.document.body, start, end),\n        end: this.findEnd(view.document.body, start, end)\n      });\n    }\n\n    return columns;\n  }\n  /**\n   * Find Start Range\n   * @private\n   * @param {Node} root root node\n   * @param {number} start position to start at\n   * @param {number} end position to end at\n   * @return {Range}\n   */\n\n\n  findStart(root, start, end) {\n    var stack = [root];\n    var $el;\n    var found;\n    var $prev = root;\n\n    while (stack.length) {\n      $el = stack.shift();\n      found = this.walk($el, node => {\n        var left, right, top, bottom;\n        var elPos;\n        var elRange;\n        elPos = (0, _core.nodeBounds)(node);\n\n        if (this.horizontal && this.direction === \"ltr\") {\n          left = this.horizontal ? elPos.left : elPos.top;\n          right = this.horizontal ? elPos.right : elPos.bottom;\n\n          if (left >= start && left <= end) {\n            return node;\n          } else if (right > start) {\n            return node;\n          } else {\n            $prev = node;\n            stack.push(node);\n          }\n        } else if (this.horizontal && this.direction === \"rtl\") {\n          left = elPos.left;\n          right = elPos.right;\n\n          if (right <= end && right >= start) {\n            return node;\n          } else if (left < end) {\n            return node;\n          } else {\n            $prev = node;\n            stack.push(node);\n          }\n        } else {\n          top = elPos.top;\n          bottom = elPos.bottom;\n\n          if (top >= start && top <= end) {\n            return node;\n          } else if (bottom > start) {\n            return node;\n          } else {\n            $prev = node;\n            stack.push(node);\n          }\n        }\n      });\n\n      if (found) {\n        return this.findTextStartRange(found, start, end);\n      }\n    } // Return last element\n\n\n    return this.findTextStartRange($prev, start, end);\n  }\n  /**\n   * Find End Range\n   * @private\n   * @param {Node} root root node\n   * @param {number} start position to start at\n   * @param {number} end position to end at\n   * @return {Range}\n   */\n\n\n  findEnd(root, start, end) {\n    var stack = [root];\n    var $el;\n    var $prev = root;\n    var found;\n\n    while (stack.length) {\n      $el = stack.shift();\n      found = this.walk($el, node => {\n        var left, right, top, bottom;\n        var elPos;\n        var elRange;\n        elPos = (0, _core.nodeBounds)(node);\n\n        if (this.horizontal && this.direction === \"ltr\") {\n          left = Math.round(elPos.left);\n          right = Math.round(elPos.right);\n\n          if (left > end && $prev) {\n            return $prev;\n          } else if (right > end) {\n            return node;\n          } else {\n            $prev = node;\n            stack.push(node);\n          }\n        } else if (this.horizontal && this.direction === \"rtl\") {\n          left = Math.round(this.horizontal ? elPos.left : elPos.top);\n          right = Math.round(this.horizontal ? elPos.right : elPos.bottom);\n\n          if (right < start && $prev) {\n            return $prev;\n          } else if (left < start) {\n            return node;\n          } else {\n            $prev = node;\n            stack.push(node);\n          }\n        } else {\n          top = Math.round(elPos.top);\n          bottom = Math.round(elPos.bottom);\n\n          if (top > end && $prev) {\n            return $prev;\n          } else if (bottom > end) {\n            return node;\n          } else {\n            $prev = node;\n            stack.push(node);\n          }\n        }\n      });\n\n      if (found) {\n        return this.findTextEndRange(found, start, end);\n      }\n    } // end of chapter\n\n\n    return this.findTextEndRange($prev, start, end);\n  }\n  /**\n   * Find Text Start Range\n   * @private\n   * @param {Node} root root node\n   * @param {number} start position to start at\n   * @param {number} end position to end at\n   * @return {Range}\n   */\n\n\n  findTextStartRange(node, start, end) {\n    var ranges = this.splitTextNodeIntoRanges(node);\n    var range;\n    var pos;\n    var left, top, right;\n\n    for (var i = 0; i < ranges.length; i++) {\n      range = ranges[i];\n      pos = range.getBoundingClientRect();\n\n      if (this.horizontal && this.direction === \"ltr\") {\n        left = pos.left;\n\n        if (left >= start) {\n          return range;\n        }\n      } else if (this.horizontal && this.direction === \"rtl\") {\n        right = pos.right;\n\n        if (right <= end) {\n          return range;\n        }\n      } else {\n        top = pos.top;\n\n        if (top >= start) {\n          return range;\n        }\n      } // prev = range;\n\n    }\n\n    return ranges[0];\n  }\n  /**\n   * Find Text End Range\n   * @private\n   * @param {Node} root root node\n   * @param {number} start position to start at\n   * @param {number} end position to end at\n   * @return {Range}\n   */\n\n\n  findTextEndRange(node, start, end) {\n    var ranges = this.splitTextNodeIntoRanges(node);\n    var prev;\n    var range;\n    var pos;\n    var left, right, top, bottom;\n\n    for (var i = 0; i < ranges.length; i++) {\n      range = ranges[i];\n      pos = range.getBoundingClientRect();\n\n      if (this.horizontal && this.direction === \"ltr\") {\n        left = pos.left;\n        right = pos.right;\n\n        if (left > end && prev) {\n          return prev;\n        } else if (right > end) {\n          return range;\n        }\n      } else if (this.horizontal && this.direction === \"rtl\") {\n        left = pos.left;\n        right = pos.right;\n\n        if (right < start && prev) {\n          return prev;\n        } else if (left < start) {\n          return range;\n        }\n      } else {\n        top = pos.top;\n        bottom = pos.bottom;\n\n        if (top > end && prev) {\n          return prev;\n        } else if (bottom > end) {\n          return range;\n        }\n      }\n\n      prev = range;\n    } // Ends before limit\n\n\n    return ranges[ranges.length - 1];\n  }\n  /**\n   * Split up a text node into ranges for each word\n   * @private\n   * @param {Node} root root node\n   * @param {string} [_splitter] what to split on\n   * @return {Range[]}\n   */\n\n\n  splitTextNodeIntoRanges(node, _splitter) {\n    var ranges = [];\n    var textContent = node.textContent || \"\";\n    var text = textContent.trim();\n    var range;\n    var doc = node.ownerDocument;\n    var splitter = _splitter || \" \";\n    var pos = text.indexOf(splitter);\n\n    if (pos === -1 || node.nodeType != Node.TEXT_NODE) {\n      range = doc.createRange();\n      range.selectNodeContents(node);\n      return [range];\n    }\n\n    range = doc.createRange();\n    range.setStart(node, 0);\n    range.setEnd(node, pos);\n    ranges.push(range);\n    range = false;\n\n    while (pos != -1) {\n      pos = text.indexOf(splitter, pos + 1);\n\n      if (pos > 0) {\n        if (range) {\n          range.setEnd(node, pos);\n          ranges.push(range);\n        }\n\n        range = doc.createRange();\n        range.setStart(node, pos + 1);\n      }\n    }\n\n    if (range) {\n      range.setEnd(node, text.length);\n      ranges.push(range);\n    }\n\n    return ranges;\n  }\n  /**\n   * Turn a pair of ranges into a pair of CFIs\n   * @private\n   * @param {string} cfiBase base string for an EpubCFI\n   * @param {object} rangePair { start: Range, end: Range }\n   * @return {object} { start: \"epubcfi(...)\", end: \"epubcfi(...)\" }\n   */\n\n\n  rangePairToCfiPair(cfiBase, rangePair) {\n    var startRange = rangePair.start;\n    var endRange = rangePair.end;\n    startRange.collapse(true);\n    endRange.collapse(false);\n    let startCfi = new _epubcfi.default(startRange, cfiBase).toString();\n    let endCfi = new _epubcfi.default(endRange, cfiBase).toString();\n    return {\n      start: startCfi,\n      end: endCfi\n    };\n  }\n\n  rangeListToCfiList(cfiBase, columns) {\n    var map = [];\n    var cifPair;\n\n    for (var i = 0; i < columns.length; i++) {\n      cifPair = this.rangePairToCfiPair(cfiBase, columns[i]);\n      map.push(cifPair);\n    }\n\n    return map;\n  }\n  /**\n   * Set the axis for mapping\n   * @param {string} axis horizontal | vertical\n   * @return {boolean} is it horizontal?\n   */\n\n\n  axis(axis) {\n    if (axis) {\n      this.horizontal = axis === \"horizontal\" ? true : false;\n    }\n\n    return this.horizontal;\n  }\n\n}\n\nvar _default = Mapping;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}