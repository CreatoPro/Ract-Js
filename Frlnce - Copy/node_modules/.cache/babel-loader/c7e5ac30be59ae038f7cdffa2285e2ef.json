{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _eventEmitter = _interopRequireDefault(require(\"event-emitter\"));\n\nvar _core = require(\"../../utils/core\");\n\nvar _scrolltype = _interopRequireDefault(require(\"../../utils/scrolltype\"));\n\nvar _mapping = _interopRequireDefault(require(\"../../mapping\"));\n\nvar _queue = _interopRequireDefault(require(\"../../utils/queue\"));\n\nvar _stage = _interopRequireDefault(require(\"../helpers/stage\"));\n\nvar _views = _interopRequireDefault(require(\"../helpers/views\"));\n\nvar _constants = require(\"../../utils/constants\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nclass DefaultViewManager {\n  constructor(options) {\n    this.name = \"default\";\n    this.optsSettings = options.settings;\n    this.View = options.view;\n    this.request = options.request;\n    this.renditionQueue = options.queue;\n    this.q = new _queue.default(this);\n    this.settings = (0, _core.extend)(this.settings || {}, {\n      infinite: true,\n      hidden: false,\n      width: undefined,\n      height: undefined,\n      axis: undefined,\n      writingMode: undefined,\n      flow: \"scrolled\",\n      ignoreClass: \"\",\n      fullsize: undefined,\n      allowScriptedContent: false,\n      allowPopups: false\n    });\n    (0, _core.extend)(this.settings, options.settings || {});\n    this.viewSettings = {\n      ignoreClass: this.settings.ignoreClass,\n      axis: this.settings.axis,\n      flow: this.settings.flow,\n      layout: this.layout,\n      method: this.settings.method,\n      // srcdoc, blobUrl, write\n      width: 0,\n      height: 0,\n      forceEvenPages: true,\n      allowScriptedContent: this.settings.allowScriptedContent,\n      allowPopups: this.settings.allowPopups\n    };\n    this.rendered = false;\n  }\n\n  render(element, size) {\n    let tag = element.tagName;\n\n    if (typeof this.settings.fullsize === \"undefined\" && tag && (tag.toLowerCase() == \"body\" || tag.toLowerCase() == \"html\")) {\n      this.settings.fullsize = true;\n    }\n\n    if (this.settings.fullsize) {\n      this.settings.overflow = \"visible\";\n      this.overflow = this.settings.overflow;\n    }\n\n    this.settings.size = size;\n    this.settings.rtlScrollType = (0, _scrolltype.default)(); // Save the stage\n\n    this.stage = new _stage.default({\n      width: size.width,\n      height: size.height,\n      overflow: this.overflow,\n      hidden: this.settings.hidden,\n      axis: this.settings.axis,\n      fullsize: this.settings.fullsize,\n      direction: this.settings.direction\n    });\n    this.stage.attachTo(element); // Get this stage container div\n\n    this.container = this.stage.getContainer(); // Views array methods\n\n    this.views = new _views.default(this.container); // Calculate Stage Size\n\n    this._bounds = this.bounds();\n    this._stageSize = this.stage.size(); // Set the dimensions for views\n\n    this.viewSettings.width = this._stageSize.width;\n    this.viewSettings.height = this._stageSize.height; // Function to handle a resize event.\n    // Will only attach if width and height are both fixed.\n\n    this.stage.onResize(this.onResized.bind(this));\n    this.stage.onOrientationChange(this.onOrientationChange.bind(this)); // Add Event Listeners\n\n    this.addEventListeners(); // Add Layout method\n    // this.applyLayoutMethod();\n\n    if (this.layout) {\n      this.updateLayout();\n    }\n\n    this.rendered = true;\n  }\n\n  addEventListeners() {\n    var scroller;\n    window.addEventListener(\"unload\", function (e) {\n      this.destroy();\n    }.bind(this));\n\n    if (!this.settings.fullsize) {\n      scroller = this.container;\n    } else {\n      scroller = window;\n    }\n\n    this._onScroll = this.onScroll.bind(this);\n    scroller.addEventListener(\"scroll\", this._onScroll);\n  }\n\n  removeEventListeners() {\n    var scroller;\n\n    if (!this.settings.fullsize) {\n      scroller = this.container;\n    } else {\n      scroller = window;\n    }\n\n    scroller.removeEventListener(\"scroll\", this._onScroll);\n    this._onScroll = undefined;\n  }\n\n  destroy() {\n    clearTimeout(this.orientationTimeout);\n    clearTimeout(this.resizeTimeout);\n    clearTimeout(this.afterScrolled);\n    this.clear();\n    this.removeEventListeners();\n    this.stage.destroy();\n    this.rendered = false;\n    /*\n    \t\tclearTimeout(this.trimTimeout);\n    \tif(this.settings.hidden) {\n    \t\tthis.element.removeChild(this.wrapper);\n    \t} else {\n    \t\tthis.element.removeChild(this.container);\n    \t}\n    */\n  }\n\n  onOrientationChange(e) {\n    let {\n      orientation\n    } = window;\n\n    if (this.optsSettings.resizeOnOrientationChange) {\n      this.resize();\n    } // Per ampproject:\n    // In IOS 10.3, the measured size of an element is incorrect if the\n    // element size depends on window size directly and the measurement\n    // happens in window.resize event. Adding a timeout for correct\n    // measurement. See https://github.com/ampproject/amphtml/issues/8479\n\n\n    clearTimeout(this.orientationTimeout);\n    this.orientationTimeout = setTimeout(function () {\n      this.orientationTimeout = undefined;\n\n      if (this.optsSettings.resizeOnOrientationChange) {\n        this.resize();\n      }\n\n      this.emit(_constants.EVENTS.MANAGERS.ORIENTATION_CHANGE, orientation);\n    }.bind(this), 500);\n  }\n\n  onResized(e) {\n    this.resize();\n  }\n\n  resize(width, height, epubcfi) {\n    let stageSize = this.stage.size(width, height); // For Safari, wait for orientation to catch up\n    // if the window is a square\n\n    this.winBounds = (0, _core.windowBounds)();\n\n    if (this.orientationTimeout && this.winBounds.width === this.winBounds.height) {\n      // reset the stage size for next resize\n      this._stageSize = undefined;\n      return;\n    }\n\n    if (this._stageSize && this._stageSize.width === stageSize.width && this._stageSize.height === stageSize.height) {\n      // Size is the same, no need to resize\n      return;\n    }\n\n    this._stageSize = stageSize;\n    this._bounds = this.bounds(); // Clear current views\n\n    this.clear(); // Update for new views\n\n    this.viewSettings.width = this._stageSize.width;\n    this.viewSettings.height = this._stageSize.height;\n    this.updateLayout();\n    this.emit(_constants.EVENTS.MANAGERS.RESIZED, {\n      width: this._stageSize.width,\n      height: this._stageSize.height\n    }, epubcfi);\n  }\n\n  createView(section, forceRight) {\n    return new this.View(section, (0, _core.extend)(this.viewSettings, {\n      forceRight\n    }));\n  }\n\n  handleNextPrePaginated(forceRight, section, action) {\n    let next;\n\n    if (this.layout.name === \"pre-paginated\" && this.layout.divisor > 1) {\n      if (forceRight || section.index === 0) {\n        // First page (cover) should stand alone for pre-paginated books\n        return;\n      }\n\n      next = section.next();\n\n      if (next && !next.properties.includes(\"page-spread-left\")) {\n        return action.call(this, next);\n      }\n    }\n  }\n\n  display(section, target) {\n    var displaying = new _core.defer();\n    var displayed = displaying.promise; // Check if moving to target is needed\n\n    if (target === section.href || (0, _core.isNumber)(target)) {\n      target = undefined;\n    } // Check to make sure the section we want isn't already shown\n\n\n    var visible = this.views.find(section); // View is already shown, just move to correct location in view\n\n    if (visible && section && this.layout.name !== \"pre-paginated\") {\n      let offset = visible.offset();\n\n      if (this.settings.direction === \"ltr\") {\n        this.scrollTo(offset.left, offset.top, true);\n      } else {\n        let width = visible.width();\n        this.scrollTo(offset.left + width, offset.top, true);\n      }\n\n      if (target) {\n        let offset = visible.locationOf(target);\n        let width = visible.width();\n        this.moveTo(offset, width);\n      }\n\n      displaying.resolve();\n      return displayed;\n    } // Hide all current views\n\n\n    this.clear();\n    let forceRight = false;\n\n    if (this.layout.name === \"pre-paginated\" && this.layout.divisor === 2 && section.properties.includes(\"page-spread-right\")) {\n      forceRight = true;\n    }\n\n    this.add(section, forceRight).then(function (view) {\n      // Move to correct place within the section, if needed\n      if (target) {\n        let offset = view.locationOf(target);\n        let width = view.width();\n        this.moveTo(offset, width);\n      }\n    }.bind(this), err => {\n      displaying.reject(err);\n    }).then(function () {\n      return this.handleNextPrePaginated(forceRight, section, this.add);\n    }.bind(this)).then(function () {\n      this.views.show();\n      displaying.resolve();\n    }.bind(this)); // .then(function(){\n    // \treturn this.hooks.display.trigger(view);\n    // }.bind(this))\n    // .then(function(){\n    // \tthis.views.show();\n    // }.bind(this));\n\n    return displayed;\n  }\n\n  afterDisplayed(view) {\n    this.emit(_constants.EVENTS.MANAGERS.ADDED, view);\n  }\n\n  afterResized(view) {\n    this.emit(_constants.EVENTS.MANAGERS.RESIZE, view.section);\n  }\n\n  moveTo(offset, width) {\n    var distX = 0,\n        distY = 0;\n\n    if (!this.isPaginated) {\n      distY = offset.top;\n    } else {\n      distX = Math.floor(offset.left / this.layout.delta) * this.layout.delta;\n\n      if (distX + this.layout.delta > this.container.scrollWidth) {\n        distX = this.container.scrollWidth - this.layout.delta;\n      }\n\n      distY = Math.floor(offset.top / this.layout.delta) * this.layout.delta;\n\n      if (distY + this.layout.delta > this.container.scrollHeight) {\n        distY = this.container.scrollHeight - this.layout.delta;\n      }\n    }\n\n    if (this.settings.direction === 'rtl') {\n      /***\n      \tthe `floor` function above (L343) is on positive values, so we should add one `layout.delta`\n      \tto distX or use `Math.ceil` function, or multiply offset.left by -1\n      \tbefore `Math.floor`\n      */\n      distX = distX + this.layout.delta;\n      distX = distX - width;\n    }\n\n    this.scrollTo(distX, distY, true);\n  }\n\n  add(section, forceRight) {\n    var view = this.createView(section, forceRight);\n    this.views.append(view); // view.on(EVENTS.VIEWS.SHOWN, this.afterDisplayed.bind(this));\n\n    view.onDisplayed = this.afterDisplayed.bind(this);\n    view.onResize = this.afterResized.bind(this);\n    view.on(_constants.EVENTS.VIEWS.AXIS, axis => {\n      this.updateAxis(axis);\n    });\n    view.on(_constants.EVENTS.VIEWS.WRITING_MODE, mode => {\n      this.updateWritingMode(mode);\n    });\n    return view.display(this.request);\n  }\n\n  append(section, forceRight) {\n    var view = this.createView(section, forceRight);\n    this.views.append(view);\n    view.onDisplayed = this.afterDisplayed.bind(this);\n    view.onResize = this.afterResized.bind(this);\n    view.on(_constants.EVENTS.VIEWS.AXIS, axis => {\n      this.updateAxis(axis);\n    });\n    view.on(_constants.EVENTS.VIEWS.WRITING_MODE, mode => {\n      this.updateWritingMode(mode);\n    });\n    return view.display(this.request);\n  }\n\n  prepend(section, forceRight) {\n    var view = this.createView(section, forceRight);\n    view.on(_constants.EVENTS.VIEWS.RESIZED, bounds => {\n      this.counter(bounds);\n    });\n    this.views.prepend(view);\n    view.onDisplayed = this.afterDisplayed.bind(this);\n    view.onResize = this.afterResized.bind(this);\n    view.on(_constants.EVENTS.VIEWS.AXIS, axis => {\n      this.updateAxis(axis);\n    });\n    view.on(_constants.EVENTS.VIEWS.WRITING_MODE, mode => {\n      this.updateWritingMode(mode);\n    });\n    return view.display(this.request);\n  }\n\n  counter(bounds) {\n    if (this.settings.axis === \"vertical\") {\n      this.scrollBy(0, bounds.heightDelta, true);\n    } else {\n      this.scrollBy(bounds.widthDelta, 0, true);\n    }\n  } // resizeView(view) {\n  //\n  // \tif(this.settings.globalLayoutProperties.layout === \"pre-paginated\") {\n  // \t\tview.lock(\"both\", this.bounds.width, this.bounds.height);\n  // \t} else {\n  // \t\tview.lock(\"width\", this.bounds.width, this.bounds.height);\n  // \t}\n  //\n  // };\n\n\n  next() {\n    var next;\n    var left;\n    let dir = this.settings.direction;\n    if (!this.views.length) return;\n\n    if (this.isPaginated && this.settings.axis === \"horizontal\" && (!dir || dir === \"ltr\")) {\n      this.scrollLeft = this.container.scrollLeft;\n      left = this.container.scrollLeft + this.container.offsetWidth + this.layout.delta;\n\n      if (left <= this.container.scrollWidth) {\n        this.scrollBy(this.layout.delta, 0, true);\n      } else {\n        next = this.views.last().section.next();\n      }\n    } else if (this.isPaginated && this.settings.axis === \"horizontal\" && dir === \"rtl\") {\n      this.scrollLeft = this.container.scrollLeft;\n\n      if (this.settings.rtlScrollType === \"default\") {\n        left = this.container.scrollLeft;\n\n        if (left > 0) {\n          this.scrollBy(this.layout.delta, 0, true);\n        } else {\n          next = this.views.last().section.next();\n        }\n      } else {\n        left = this.container.scrollLeft + this.layout.delta * -1;\n\n        if (left > this.container.scrollWidth * -1) {\n          this.scrollBy(this.layout.delta, 0, true);\n        } else {\n          next = this.views.last().section.next();\n        }\n      }\n    } else if (this.isPaginated && this.settings.axis === \"vertical\") {\n      this.scrollTop = this.container.scrollTop;\n      let top = this.container.scrollTop + this.container.offsetHeight;\n\n      if (top < this.container.scrollHeight) {\n        this.scrollBy(0, this.layout.height, true);\n      } else {\n        next = this.views.last().section.next();\n      }\n    } else {\n      next = this.views.last().section.next();\n    }\n\n    if (next) {\n      this.clear(); // The new section may have a different writing-mode from the old section. Thus, we need to update layout.\n\n      this.updateLayout();\n      let forceRight = false;\n\n      if (this.layout.name === \"pre-paginated\" && this.layout.divisor === 2 && next.properties.includes(\"page-spread-right\")) {\n        forceRight = true;\n      }\n\n      return this.append(next, forceRight).then(function () {\n        return this.handleNextPrePaginated(forceRight, next, this.append);\n      }.bind(this), err => {\n        return err;\n      }).then(function () {\n        // Reset position to start for scrolled-doc vertical-rl in default mode\n        if (!this.isPaginated && this.settings.axis === \"horizontal\" && this.settings.direction === \"rtl\" && this.settings.rtlScrollType === \"default\") {\n          this.scrollTo(this.container.scrollWidth, 0, true);\n        }\n\n        this.views.show();\n      }.bind(this));\n    }\n  }\n\n  prev() {\n    var prev;\n    var left;\n    let dir = this.settings.direction;\n    if (!this.views.length) return;\n\n    if (this.isPaginated && this.settings.axis === \"horizontal\" && (!dir || dir === \"ltr\")) {\n      this.scrollLeft = this.container.scrollLeft;\n      left = this.container.scrollLeft;\n\n      if (left > 0) {\n        this.scrollBy(-this.layout.delta, 0, true);\n      } else {\n        prev = this.views.first().section.prev();\n      }\n    } else if (this.isPaginated && this.settings.axis === \"horizontal\" && dir === \"rtl\") {\n      this.scrollLeft = this.container.scrollLeft;\n\n      if (this.settings.rtlScrollType === \"default\") {\n        left = this.container.scrollLeft + this.container.offsetWidth;\n\n        if (left < this.container.scrollWidth) {\n          this.scrollBy(-this.layout.delta, 0, true);\n        } else {\n          prev = this.views.first().section.prev();\n        }\n      } else {\n        left = this.container.scrollLeft;\n\n        if (left < 0) {\n          this.scrollBy(-this.layout.delta, 0, true);\n        } else {\n          prev = this.views.first().section.prev();\n        }\n      }\n    } else if (this.isPaginated && this.settings.axis === \"vertical\") {\n      this.scrollTop = this.container.scrollTop;\n      let top = this.container.scrollTop;\n\n      if (top > 0) {\n        this.scrollBy(0, -this.layout.height, true);\n      } else {\n        prev = this.views.first().section.prev();\n      }\n    } else {\n      prev = this.views.first().section.prev();\n    }\n\n    if (prev) {\n      this.clear(); // The new section may have a different writing-mode from the old section. Thus, we need to update layout.\n\n      this.updateLayout();\n      let forceRight = false;\n\n      if (this.layout.name === \"pre-paginated\" && this.layout.divisor === 2 && typeof prev.prev() !== \"object\") {\n        forceRight = true;\n      }\n\n      return this.prepend(prev, forceRight).then(function () {\n        var left;\n\n        if (this.layout.name === \"pre-paginated\" && this.layout.divisor > 1) {\n          left = prev.prev();\n\n          if (left) {\n            return this.prepend(left);\n          }\n        }\n      }.bind(this), err => {\n        return err;\n      }).then(function () {\n        if (this.isPaginated && this.settings.axis === \"horizontal\") {\n          if (this.settings.direction === \"rtl\") {\n            if (this.settings.rtlScrollType === \"default\") {\n              this.scrollTo(0, 0, true);\n            } else {\n              this.scrollTo(this.container.scrollWidth * -1 + this.layout.delta, 0, true);\n            }\n          } else {\n            this.scrollTo(this.container.scrollWidth - this.layout.delta, 0, true);\n          }\n        }\n\n        this.views.show();\n      }.bind(this));\n    }\n  }\n\n  current() {\n    var visible = this.visible();\n\n    if (visible.length) {\n      // Current is the last visible view\n      return visible[visible.length - 1];\n    }\n\n    return null;\n  }\n\n  clear() {\n    // this.q.clear();\n    if (this.views) {\n      this.views.hide();\n      this.scrollTo(0, 0, true);\n      this.views.clear();\n    }\n  }\n\n  currentLocation() {\n    this.updateLayout();\n\n    if (this.isPaginated && this.settings.axis === \"horizontal\") {\n      this.location = this.paginatedLocation();\n    } else {\n      this.location = this.scrolledLocation();\n    }\n\n    return this.location;\n  }\n\n  scrolledLocation() {\n    let visible = this.visible();\n    let container = this.container.getBoundingClientRect();\n    let pageHeight = container.height < window.innerHeight ? container.height : window.innerHeight;\n    let pageWidth = container.width < window.innerWidth ? container.width : window.innerWidth;\n    let vertical = this.settings.axis === \"vertical\";\n    let rtl = this.settings.direction === \"rtl\";\n    let offset = 0;\n    let used = 0;\n\n    if (this.settings.fullsize) {\n      offset = vertical ? window.scrollY : window.scrollX;\n    }\n\n    let sections = visible.map(view => {\n      let {\n        index,\n        href\n      } = view.section;\n      let position = view.position();\n      let width = view.width();\n      let height = view.height();\n      let startPos;\n      let endPos;\n      let stopPos;\n      let totalPages;\n\n      if (vertical) {\n        startPos = offset + container.top - position.top + used;\n        endPos = startPos + pageHeight - used;\n        totalPages = this.layout.count(height, pageHeight).pages;\n        stopPos = pageHeight;\n      } else {\n        startPos = offset + container.left - position.left + used;\n        endPos = startPos + pageWidth - used;\n        totalPages = this.layout.count(width, pageWidth).pages;\n        stopPos = pageWidth;\n      }\n\n      let currPage = Math.ceil(startPos / stopPos);\n      let pages = [];\n      let endPage = Math.ceil(endPos / stopPos); // Reverse page counts for horizontal rtl\n\n      if (this.settings.direction === \"rtl\" && !vertical) {\n        let tempStartPage = currPage;\n        currPage = totalPages - endPage;\n        endPage = totalPages - tempStartPage;\n      }\n\n      pages = [];\n\n      for (var i = currPage; i <= endPage; i++) {\n        let pg = i + 1;\n        pages.push(pg);\n      }\n\n      let mapping = this.mapping.page(view.contents, view.section.cfiBase, startPos, endPos);\n      return {\n        index,\n        href,\n        pages,\n        totalPages,\n        mapping\n      };\n    });\n    return sections;\n  }\n\n  paginatedLocation() {\n    let visible = this.visible();\n    let container = this.container.getBoundingClientRect();\n    let left = 0;\n    let used = 0;\n\n    if (this.settings.fullsize) {\n      left = window.scrollX;\n    }\n\n    let sections = visible.map(view => {\n      let {\n        index,\n        href\n      } = view.section;\n      let offset;\n      let position = view.position();\n      let width = view.width(); // Find mapping\n\n      let start;\n      let end;\n      let pageWidth;\n\n      if (this.settings.direction === \"rtl\") {\n        offset = container.right - left;\n        pageWidth = Math.min(Math.abs(offset - position.left), this.layout.width) - used;\n        end = position.width - (position.right - offset) - used;\n        start = end - pageWidth;\n      } else {\n        offset = container.left + left;\n        pageWidth = Math.min(position.right - offset, this.layout.width) - used;\n        start = offset - position.left + used;\n        end = start + pageWidth;\n      }\n\n      used += pageWidth;\n      let mapping = this.mapping.page(view.contents, view.section.cfiBase, start, end);\n      let totalPages = this.layout.count(width).pages;\n      let startPage = Math.floor(start / this.layout.pageWidth);\n      let pages = [];\n      let endPage = Math.floor(end / this.layout.pageWidth); // start page should not be negative\n\n      if (startPage < 0) {\n        startPage = 0;\n        endPage = endPage + 1;\n      } // Reverse page counts for rtl\n\n\n      if (this.settings.direction === \"rtl\") {\n        let tempStartPage = startPage;\n        startPage = totalPages - endPage;\n        endPage = totalPages - tempStartPage;\n      }\n\n      for (var i = startPage + 1; i <= endPage; i++) {\n        let pg = i;\n        pages.push(pg);\n      }\n\n      return {\n        index,\n        href,\n        pages,\n        totalPages,\n        mapping\n      };\n    });\n    return sections;\n  }\n\n  isVisible(view, offsetPrev, offsetNext, _container) {\n    var position = view.position();\n\n    var container = _container || this.bounds();\n\n    if (this.settings.axis === \"horizontal\" && position.right > container.left - offsetPrev && position.left < container.right + offsetNext) {\n      return true;\n    } else if (this.settings.axis === \"vertical\" && position.bottom > container.top - offsetPrev && position.top < container.bottom + offsetNext) {\n      return true;\n    }\n\n    return false;\n  }\n\n  visible() {\n    var container = this.bounds();\n    var views = this.views.displayed();\n    var viewsLength = views.length;\n    var visible = [];\n    var isVisible;\n    var view;\n\n    for (var i = 0; i < viewsLength; i++) {\n      view = views[i];\n      isVisible = this.isVisible(view, 0, 0, container);\n\n      if (isVisible === true) {\n        visible.push(view);\n      }\n    }\n\n    return visible;\n  }\n\n  scrollBy(x, y, silent) {\n    let dir = this.settings.direction === \"rtl\" ? -1 : 1;\n\n    if (silent) {\n      this.ignore = true;\n    }\n\n    if (!this.settings.fullsize) {\n      if (x) this.container.scrollLeft += x * dir;\n      if (y) this.container.scrollTop += y;\n    } else {\n      window.scrollBy(x * dir, y * dir);\n    }\n\n    this.scrolled = true;\n  }\n\n  scrollTo(x, y, silent) {\n    if (silent) {\n      this.ignore = true;\n    }\n\n    if (!this.settings.fullsize) {\n      this.container.scrollLeft = x;\n      this.container.scrollTop = y;\n    } else {\n      window.scrollTo(x, y);\n    }\n\n    this.scrolled = true;\n  }\n\n  onScroll() {\n    let scrollTop;\n    let scrollLeft;\n\n    if (!this.settings.fullsize) {\n      scrollTop = this.container.scrollTop;\n      scrollLeft = this.container.scrollLeft;\n    } else {\n      scrollTop = window.scrollY;\n      scrollLeft = window.scrollX;\n    }\n\n    this.scrollTop = scrollTop;\n    this.scrollLeft = scrollLeft;\n\n    if (!this.ignore) {\n      this.emit(_constants.EVENTS.MANAGERS.SCROLL, {\n        top: scrollTop,\n        left: scrollLeft\n      });\n      clearTimeout(this.afterScrolled);\n      this.afterScrolled = setTimeout(function () {\n        this.emit(_constants.EVENTS.MANAGERS.SCROLLED, {\n          top: this.scrollTop,\n          left: this.scrollLeft\n        });\n      }.bind(this), 20);\n    } else {\n      this.ignore = false;\n    }\n  }\n\n  bounds() {\n    var bounds;\n    bounds = this.stage.bounds();\n    return bounds;\n  }\n\n  applyLayout(layout) {\n    this.layout = layout;\n    this.updateLayout();\n\n    if (this.views && this.views.length > 0 && this.layout.name === \"pre-paginated\") {\n      this.display(this.views.first().section);\n    } // this.manager.layout(this.layout.format);\n\n  }\n\n  updateLayout() {\n    if (!this.stage) {\n      return;\n    }\n\n    this._stageSize = this.stage.size();\n\n    if (!this.isPaginated) {\n      this.layout.calculate(this._stageSize.width, this._stageSize.height);\n    } else {\n      this.layout.calculate(this._stageSize.width, this._stageSize.height, this.settings.gap); // Set the look ahead offset for what is visible\n\n      this.settings.offset = this.layout.delta / this.layout.divisor; // this.stage.addStyleRules(\"iframe\", [{\"margin-right\" : this.layout.gap + \"px\"}]);\n    } // Set the dimensions for views\n\n\n    this.viewSettings.width = this.layout.width;\n    this.viewSettings.height = this.layout.height;\n    this.setLayout(this.layout);\n  }\n\n  setLayout(layout) {\n    this.viewSettings.layout = layout;\n    this.mapping = new _mapping.default(layout.props, this.settings.direction, this.settings.axis);\n\n    if (this.views) {\n      this.views.forEach(function (view) {\n        if (view) {\n          view.setLayout(layout);\n        }\n      });\n    }\n  }\n\n  updateWritingMode(mode) {\n    this.writingMode = mode;\n  }\n\n  updateAxis(axis, forceUpdate) {\n    if (!forceUpdate && axis === this.settings.axis) {\n      return;\n    }\n\n    this.settings.axis = axis;\n    this.stage && this.stage.axis(axis);\n    this.viewSettings.axis = axis;\n\n    if (this.mapping) {\n      this.mapping = new _mapping.default(this.layout.props, this.settings.direction, this.settings.axis);\n    }\n\n    if (this.layout) {\n      if (axis === \"vertical\") {\n        this.layout.spread(\"none\");\n      } else {\n        this.layout.spread(this.layout.settings.spread);\n      }\n    }\n  }\n\n  updateFlow(flow) {\n    let defaultScrolledOverflow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"auto\";\n    let isPaginated = flow === \"paginated\" || flow === \"auto\";\n    this.isPaginated = isPaginated;\n\n    if (flow === \"scrolled-doc\" || flow === \"scrolled-continuous\" || flow === \"scrolled\") {\n      this.updateAxis(\"vertical\");\n    } else {\n      this.updateAxis(\"horizontal\");\n    }\n\n    this.viewSettings.flow = flow;\n\n    if (!this.settings.overflow) {\n      this.overflow = isPaginated ? \"hidden\" : defaultScrolledOverflow;\n    } else {\n      this.overflow = this.settings.overflow;\n    }\n\n    this.stage && this.stage.overflow(this.overflow);\n    this.updateLayout();\n  }\n\n  getContents() {\n    var contents = [];\n\n    if (!this.views) {\n      return contents;\n    }\n\n    this.views.forEach(function (view) {\n      const viewContents = view && view.contents;\n\n      if (viewContents) {\n        contents.push(viewContents);\n      }\n    });\n    return contents;\n  }\n\n  direction() {\n    let dir = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"ltr\";\n    this.settings.direction = dir;\n    this.stage && this.stage.direction(dir);\n    this.viewSettings.direction = dir;\n    this.updateLayout();\n  }\n\n  isRendered() {\n    return this.rendered;\n  }\n\n} //-- Enable binding events to Manager\n\n\n(0, _eventEmitter.default)(DefaultViewManager.prototype);\nvar _default = DefaultViewManager;\nexports.default = _default;","map":{"version":3,"sources":["S:/REACT/Ract-Js/Frlnce/node_modules/epubjs/lib/managers/default/index.js"],"names":["Object","defineProperty","exports","value","default","_eventEmitter","_interopRequireDefault","require","_core","_scrolltype","_mapping","_queue","_stage","_views","_constants","obj","__esModule","DefaultViewManager","constructor","options","name","optsSettings","settings","View","view","request","renditionQueue","queue","q","extend","infinite","hidden","width","undefined","height","axis","writingMode","flow","ignoreClass","fullsize","allowScriptedContent","allowPopups","viewSettings","layout","method","forceEvenPages","rendered","render","element","size","tag","tagName","toLowerCase","overflow","rtlScrollType","stage","direction","attachTo","container","getContainer","views","_bounds","bounds","_stageSize","onResize","onResized","bind","onOrientationChange","addEventListeners","updateLayout","scroller","window","addEventListener","e","destroy","_onScroll","onScroll","removeEventListeners","removeEventListener","clearTimeout","orientationTimeout","resizeTimeout","afterScrolled","clear","orientation","resizeOnOrientationChange","resize","setTimeout","emit","EVENTS","MANAGERS","ORIENTATION_CHANGE","epubcfi","stageSize","winBounds","windowBounds","RESIZED","createView","section","forceRight","handleNextPrePaginated","action","next","divisor","index","properties","includes","call","display","target","displaying","defer","displayed","promise","href","isNumber","visible","find","offset","scrollTo","left","top","locationOf","moveTo","resolve","add","then","err","reject","show","afterDisplayed","ADDED","afterResized","RESIZE","distX","distY","isPaginated","Math","floor","delta","scrollWidth","scrollHeight","append","onDisplayed","on","VIEWS","AXIS","updateAxis","WRITING_MODE","mode","updateWritingMode","prepend","counter","scrollBy","heightDelta","widthDelta","dir","length","scrollLeft","offsetWidth","last","scrollTop","offsetHeight","prev","first","current","hide","currentLocation","location","paginatedLocation","scrolledLocation","getBoundingClientRect","pageHeight","innerHeight","pageWidth","innerWidth","vertical","rtl","used","scrollY","scrollX","sections","map","position","startPos","endPos","stopPos","totalPages","count","pages","currPage","ceil","endPage","tempStartPage","i","pg","push","mapping","page","contents","cfiBase","start","end","right","min","abs","startPage","isVisible","offsetPrev","offsetNext","_container","bottom","viewsLength","x","y","silent","ignore","scrolled","SCROLL","SCROLLED","applyLayout","calculate","gap","setLayout","props","forEach","forceUpdate","spread","updateFlow","defaultScrolledOverflow","getContents","viewContents","isRendered","prototype","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _eventEmitter = _interopRequireDefault(require(\"event-emitter\"));\n\nvar _core = require(\"../../utils/core\");\n\nvar _scrolltype = _interopRequireDefault(require(\"../../utils/scrolltype\"));\n\nvar _mapping = _interopRequireDefault(require(\"../../mapping\"));\n\nvar _queue = _interopRequireDefault(require(\"../../utils/queue\"));\n\nvar _stage = _interopRequireDefault(require(\"../helpers/stage\"));\n\nvar _views = _interopRequireDefault(require(\"../helpers/views\"));\n\nvar _constants = require(\"../../utils/constants\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass DefaultViewManager {\n  constructor(options) {\n    this.name = \"default\";\n    this.optsSettings = options.settings;\n    this.View = options.view;\n    this.request = options.request;\n    this.renditionQueue = options.queue;\n    this.q = new _queue.default(this);\n    this.settings = (0, _core.extend)(this.settings || {}, {\n      infinite: true,\n      hidden: false,\n      width: undefined,\n      height: undefined,\n      axis: undefined,\n      writingMode: undefined,\n      flow: \"scrolled\",\n      ignoreClass: \"\",\n      fullsize: undefined,\n      allowScriptedContent: false,\n      allowPopups: false\n    });\n    (0, _core.extend)(this.settings, options.settings || {});\n    this.viewSettings = {\n      ignoreClass: this.settings.ignoreClass,\n      axis: this.settings.axis,\n      flow: this.settings.flow,\n      layout: this.layout,\n      method: this.settings.method,\n      // srcdoc, blobUrl, write\n      width: 0,\n      height: 0,\n      forceEvenPages: true,\n      allowScriptedContent: this.settings.allowScriptedContent,\n      allowPopups: this.settings.allowPopups\n    };\n    this.rendered = false;\n  }\n\n  render(element, size) {\n    let tag = element.tagName;\n\n    if (typeof this.settings.fullsize === \"undefined\" && tag && (tag.toLowerCase() == \"body\" || tag.toLowerCase() == \"html\")) {\n      this.settings.fullsize = true;\n    }\n\n    if (this.settings.fullsize) {\n      this.settings.overflow = \"visible\";\n      this.overflow = this.settings.overflow;\n    }\n\n    this.settings.size = size;\n    this.settings.rtlScrollType = (0, _scrolltype.default)(); // Save the stage\n\n    this.stage = new _stage.default({\n      width: size.width,\n      height: size.height,\n      overflow: this.overflow,\n      hidden: this.settings.hidden,\n      axis: this.settings.axis,\n      fullsize: this.settings.fullsize,\n      direction: this.settings.direction\n    });\n    this.stage.attachTo(element); // Get this stage container div\n\n    this.container = this.stage.getContainer(); // Views array methods\n\n    this.views = new _views.default(this.container); // Calculate Stage Size\n\n    this._bounds = this.bounds();\n    this._stageSize = this.stage.size(); // Set the dimensions for views\n\n    this.viewSettings.width = this._stageSize.width;\n    this.viewSettings.height = this._stageSize.height; // Function to handle a resize event.\n    // Will only attach if width and height are both fixed.\n\n    this.stage.onResize(this.onResized.bind(this));\n    this.stage.onOrientationChange(this.onOrientationChange.bind(this)); // Add Event Listeners\n\n    this.addEventListeners(); // Add Layout method\n    // this.applyLayoutMethod();\n\n    if (this.layout) {\n      this.updateLayout();\n    }\n\n    this.rendered = true;\n  }\n\n  addEventListeners() {\n    var scroller;\n    window.addEventListener(\"unload\", function (e) {\n      this.destroy();\n    }.bind(this));\n\n    if (!this.settings.fullsize) {\n      scroller = this.container;\n    } else {\n      scroller = window;\n    }\n\n    this._onScroll = this.onScroll.bind(this);\n    scroller.addEventListener(\"scroll\", this._onScroll);\n  }\n\n  removeEventListeners() {\n    var scroller;\n\n    if (!this.settings.fullsize) {\n      scroller = this.container;\n    } else {\n      scroller = window;\n    }\n\n    scroller.removeEventListener(\"scroll\", this._onScroll);\n    this._onScroll = undefined;\n  }\n\n  destroy() {\n    clearTimeout(this.orientationTimeout);\n    clearTimeout(this.resizeTimeout);\n    clearTimeout(this.afterScrolled);\n    this.clear();\n    this.removeEventListeners();\n    this.stage.destroy();\n    this.rendered = false;\n    /*\n    \t\tclearTimeout(this.trimTimeout);\n    \tif(this.settings.hidden) {\n    \t\tthis.element.removeChild(this.wrapper);\n    \t} else {\n    \t\tthis.element.removeChild(this.container);\n    \t}\n    */\n  }\n\n  onOrientationChange(e) {\n    let {\n      orientation\n    } = window;\n\n    if (this.optsSettings.resizeOnOrientationChange) {\n      this.resize();\n    } // Per ampproject:\n    // In IOS 10.3, the measured size of an element is incorrect if the\n    // element size depends on window size directly and the measurement\n    // happens in window.resize event. Adding a timeout for correct\n    // measurement. See https://github.com/ampproject/amphtml/issues/8479\n\n\n    clearTimeout(this.orientationTimeout);\n    this.orientationTimeout = setTimeout(function () {\n      this.orientationTimeout = undefined;\n\n      if (this.optsSettings.resizeOnOrientationChange) {\n        this.resize();\n      }\n\n      this.emit(_constants.EVENTS.MANAGERS.ORIENTATION_CHANGE, orientation);\n    }.bind(this), 500);\n  }\n\n  onResized(e) {\n    this.resize();\n  }\n\n  resize(width, height, epubcfi) {\n    let stageSize = this.stage.size(width, height); // For Safari, wait for orientation to catch up\n    // if the window is a square\n\n    this.winBounds = (0, _core.windowBounds)();\n\n    if (this.orientationTimeout && this.winBounds.width === this.winBounds.height) {\n      // reset the stage size for next resize\n      this._stageSize = undefined;\n      return;\n    }\n\n    if (this._stageSize && this._stageSize.width === stageSize.width && this._stageSize.height === stageSize.height) {\n      // Size is the same, no need to resize\n      return;\n    }\n\n    this._stageSize = stageSize;\n    this._bounds = this.bounds(); // Clear current views\n\n    this.clear(); // Update for new views\n\n    this.viewSettings.width = this._stageSize.width;\n    this.viewSettings.height = this._stageSize.height;\n    this.updateLayout();\n    this.emit(_constants.EVENTS.MANAGERS.RESIZED, {\n      width: this._stageSize.width,\n      height: this._stageSize.height\n    }, epubcfi);\n  }\n\n  createView(section, forceRight) {\n    return new this.View(section, (0, _core.extend)(this.viewSettings, {\n      forceRight\n    }));\n  }\n\n  handleNextPrePaginated(forceRight, section, action) {\n    let next;\n\n    if (this.layout.name === \"pre-paginated\" && this.layout.divisor > 1) {\n      if (forceRight || section.index === 0) {\n        // First page (cover) should stand alone for pre-paginated books\n        return;\n      }\n\n      next = section.next();\n\n      if (next && !next.properties.includes(\"page-spread-left\")) {\n        return action.call(this, next);\n      }\n    }\n  }\n\n  display(section, target) {\n    var displaying = new _core.defer();\n    var displayed = displaying.promise; // Check if moving to target is needed\n\n    if (target === section.href || (0, _core.isNumber)(target)) {\n      target = undefined;\n    } // Check to make sure the section we want isn't already shown\n\n\n    var visible = this.views.find(section); // View is already shown, just move to correct location in view\n\n    if (visible && section && this.layout.name !== \"pre-paginated\") {\n      let offset = visible.offset();\n\n      if (this.settings.direction === \"ltr\") {\n        this.scrollTo(offset.left, offset.top, true);\n      } else {\n        let width = visible.width();\n        this.scrollTo(offset.left + width, offset.top, true);\n      }\n\n      if (target) {\n        let offset = visible.locationOf(target);\n        let width = visible.width();\n        this.moveTo(offset, width);\n      }\n\n      displaying.resolve();\n      return displayed;\n    } // Hide all current views\n\n\n    this.clear();\n    let forceRight = false;\n\n    if (this.layout.name === \"pre-paginated\" && this.layout.divisor === 2 && section.properties.includes(\"page-spread-right\")) {\n      forceRight = true;\n    }\n\n    this.add(section, forceRight).then(function (view) {\n      // Move to correct place within the section, if needed\n      if (target) {\n        let offset = view.locationOf(target);\n        let width = view.width();\n        this.moveTo(offset, width);\n      }\n    }.bind(this), err => {\n      displaying.reject(err);\n    }).then(function () {\n      return this.handleNextPrePaginated(forceRight, section, this.add);\n    }.bind(this)).then(function () {\n      this.views.show();\n      displaying.resolve();\n    }.bind(this)); // .then(function(){\n    // \treturn this.hooks.display.trigger(view);\n    // }.bind(this))\n    // .then(function(){\n    // \tthis.views.show();\n    // }.bind(this));\n\n    return displayed;\n  }\n\n  afterDisplayed(view) {\n    this.emit(_constants.EVENTS.MANAGERS.ADDED, view);\n  }\n\n  afterResized(view) {\n    this.emit(_constants.EVENTS.MANAGERS.RESIZE, view.section);\n  }\n\n  moveTo(offset, width) {\n    var distX = 0,\n        distY = 0;\n\n    if (!this.isPaginated) {\n      distY = offset.top;\n    } else {\n      distX = Math.floor(offset.left / this.layout.delta) * this.layout.delta;\n\n      if (distX + this.layout.delta > this.container.scrollWidth) {\n        distX = this.container.scrollWidth - this.layout.delta;\n      }\n\n      distY = Math.floor(offset.top / this.layout.delta) * this.layout.delta;\n\n      if (distY + this.layout.delta > this.container.scrollHeight) {\n        distY = this.container.scrollHeight - this.layout.delta;\n      }\n    }\n\n    if (this.settings.direction === 'rtl') {\n      /***\n      \tthe `floor` function above (L343) is on positive values, so we should add one `layout.delta`\n      \tto distX or use `Math.ceil` function, or multiply offset.left by -1\n      \tbefore `Math.floor`\n      */\n      distX = distX + this.layout.delta;\n      distX = distX - width;\n    }\n\n    this.scrollTo(distX, distY, true);\n  }\n\n  add(section, forceRight) {\n    var view = this.createView(section, forceRight);\n    this.views.append(view); // view.on(EVENTS.VIEWS.SHOWN, this.afterDisplayed.bind(this));\n\n    view.onDisplayed = this.afterDisplayed.bind(this);\n    view.onResize = this.afterResized.bind(this);\n    view.on(_constants.EVENTS.VIEWS.AXIS, axis => {\n      this.updateAxis(axis);\n    });\n    view.on(_constants.EVENTS.VIEWS.WRITING_MODE, mode => {\n      this.updateWritingMode(mode);\n    });\n    return view.display(this.request);\n  }\n\n  append(section, forceRight) {\n    var view = this.createView(section, forceRight);\n    this.views.append(view);\n    view.onDisplayed = this.afterDisplayed.bind(this);\n    view.onResize = this.afterResized.bind(this);\n    view.on(_constants.EVENTS.VIEWS.AXIS, axis => {\n      this.updateAxis(axis);\n    });\n    view.on(_constants.EVENTS.VIEWS.WRITING_MODE, mode => {\n      this.updateWritingMode(mode);\n    });\n    return view.display(this.request);\n  }\n\n  prepend(section, forceRight) {\n    var view = this.createView(section, forceRight);\n    view.on(_constants.EVENTS.VIEWS.RESIZED, bounds => {\n      this.counter(bounds);\n    });\n    this.views.prepend(view);\n    view.onDisplayed = this.afterDisplayed.bind(this);\n    view.onResize = this.afterResized.bind(this);\n    view.on(_constants.EVENTS.VIEWS.AXIS, axis => {\n      this.updateAxis(axis);\n    });\n    view.on(_constants.EVENTS.VIEWS.WRITING_MODE, mode => {\n      this.updateWritingMode(mode);\n    });\n    return view.display(this.request);\n  }\n\n  counter(bounds) {\n    if (this.settings.axis === \"vertical\") {\n      this.scrollBy(0, bounds.heightDelta, true);\n    } else {\n      this.scrollBy(bounds.widthDelta, 0, true);\n    }\n  } // resizeView(view) {\n  //\n  // \tif(this.settings.globalLayoutProperties.layout === \"pre-paginated\") {\n  // \t\tview.lock(\"both\", this.bounds.width, this.bounds.height);\n  // \t} else {\n  // \t\tview.lock(\"width\", this.bounds.width, this.bounds.height);\n  // \t}\n  //\n  // };\n\n\n  next() {\n    var next;\n    var left;\n    let dir = this.settings.direction;\n    if (!this.views.length) return;\n\n    if (this.isPaginated && this.settings.axis === \"horizontal\" && (!dir || dir === \"ltr\")) {\n      this.scrollLeft = this.container.scrollLeft;\n      left = this.container.scrollLeft + this.container.offsetWidth + this.layout.delta;\n\n      if (left <= this.container.scrollWidth) {\n        this.scrollBy(this.layout.delta, 0, true);\n      } else {\n        next = this.views.last().section.next();\n      }\n    } else if (this.isPaginated && this.settings.axis === \"horizontal\" && dir === \"rtl\") {\n      this.scrollLeft = this.container.scrollLeft;\n\n      if (this.settings.rtlScrollType === \"default\") {\n        left = this.container.scrollLeft;\n\n        if (left > 0) {\n          this.scrollBy(this.layout.delta, 0, true);\n        } else {\n          next = this.views.last().section.next();\n        }\n      } else {\n        left = this.container.scrollLeft + this.layout.delta * -1;\n\n        if (left > this.container.scrollWidth * -1) {\n          this.scrollBy(this.layout.delta, 0, true);\n        } else {\n          next = this.views.last().section.next();\n        }\n      }\n    } else if (this.isPaginated && this.settings.axis === \"vertical\") {\n      this.scrollTop = this.container.scrollTop;\n      let top = this.container.scrollTop + this.container.offsetHeight;\n\n      if (top < this.container.scrollHeight) {\n        this.scrollBy(0, this.layout.height, true);\n      } else {\n        next = this.views.last().section.next();\n      }\n    } else {\n      next = this.views.last().section.next();\n    }\n\n    if (next) {\n      this.clear(); // The new section may have a different writing-mode from the old section. Thus, we need to update layout.\n\n      this.updateLayout();\n      let forceRight = false;\n\n      if (this.layout.name === \"pre-paginated\" && this.layout.divisor === 2 && next.properties.includes(\"page-spread-right\")) {\n        forceRight = true;\n      }\n\n      return this.append(next, forceRight).then(function () {\n        return this.handleNextPrePaginated(forceRight, next, this.append);\n      }.bind(this), err => {\n        return err;\n      }).then(function () {\n        // Reset position to start for scrolled-doc vertical-rl in default mode\n        if (!this.isPaginated && this.settings.axis === \"horizontal\" && this.settings.direction === \"rtl\" && this.settings.rtlScrollType === \"default\") {\n          this.scrollTo(this.container.scrollWidth, 0, true);\n        }\n\n        this.views.show();\n      }.bind(this));\n    }\n  }\n\n  prev() {\n    var prev;\n    var left;\n    let dir = this.settings.direction;\n    if (!this.views.length) return;\n\n    if (this.isPaginated && this.settings.axis === \"horizontal\" && (!dir || dir === \"ltr\")) {\n      this.scrollLeft = this.container.scrollLeft;\n      left = this.container.scrollLeft;\n\n      if (left > 0) {\n        this.scrollBy(-this.layout.delta, 0, true);\n      } else {\n        prev = this.views.first().section.prev();\n      }\n    } else if (this.isPaginated && this.settings.axis === \"horizontal\" && dir === \"rtl\") {\n      this.scrollLeft = this.container.scrollLeft;\n\n      if (this.settings.rtlScrollType === \"default\") {\n        left = this.container.scrollLeft + this.container.offsetWidth;\n\n        if (left < this.container.scrollWidth) {\n          this.scrollBy(-this.layout.delta, 0, true);\n        } else {\n          prev = this.views.first().section.prev();\n        }\n      } else {\n        left = this.container.scrollLeft;\n\n        if (left < 0) {\n          this.scrollBy(-this.layout.delta, 0, true);\n        } else {\n          prev = this.views.first().section.prev();\n        }\n      }\n    } else if (this.isPaginated && this.settings.axis === \"vertical\") {\n      this.scrollTop = this.container.scrollTop;\n      let top = this.container.scrollTop;\n\n      if (top > 0) {\n        this.scrollBy(0, -this.layout.height, true);\n      } else {\n        prev = this.views.first().section.prev();\n      }\n    } else {\n      prev = this.views.first().section.prev();\n    }\n\n    if (prev) {\n      this.clear(); // The new section may have a different writing-mode from the old section. Thus, we need to update layout.\n\n      this.updateLayout();\n      let forceRight = false;\n\n      if (this.layout.name === \"pre-paginated\" && this.layout.divisor === 2 && typeof prev.prev() !== \"object\") {\n        forceRight = true;\n      }\n\n      return this.prepend(prev, forceRight).then(function () {\n        var left;\n\n        if (this.layout.name === \"pre-paginated\" && this.layout.divisor > 1) {\n          left = prev.prev();\n\n          if (left) {\n            return this.prepend(left);\n          }\n        }\n      }.bind(this), err => {\n        return err;\n      }).then(function () {\n        if (this.isPaginated && this.settings.axis === \"horizontal\") {\n          if (this.settings.direction === \"rtl\") {\n            if (this.settings.rtlScrollType === \"default\") {\n              this.scrollTo(0, 0, true);\n            } else {\n              this.scrollTo(this.container.scrollWidth * -1 + this.layout.delta, 0, true);\n            }\n          } else {\n            this.scrollTo(this.container.scrollWidth - this.layout.delta, 0, true);\n          }\n        }\n\n        this.views.show();\n      }.bind(this));\n    }\n  }\n\n  current() {\n    var visible = this.visible();\n\n    if (visible.length) {\n      // Current is the last visible view\n      return visible[visible.length - 1];\n    }\n\n    return null;\n  }\n\n  clear() {\n    // this.q.clear();\n    if (this.views) {\n      this.views.hide();\n      this.scrollTo(0, 0, true);\n      this.views.clear();\n    }\n  }\n\n  currentLocation() {\n    this.updateLayout();\n\n    if (this.isPaginated && this.settings.axis === \"horizontal\") {\n      this.location = this.paginatedLocation();\n    } else {\n      this.location = this.scrolledLocation();\n    }\n\n    return this.location;\n  }\n\n  scrolledLocation() {\n    let visible = this.visible();\n    let container = this.container.getBoundingClientRect();\n    let pageHeight = container.height < window.innerHeight ? container.height : window.innerHeight;\n    let pageWidth = container.width < window.innerWidth ? container.width : window.innerWidth;\n    let vertical = this.settings.axis === \"vertical\";\n    let rtl = this.settings.direction === \"rtl\";\n    let offset = 0;\n    let used = 0;\n\n    if (this.settings.fullsize) {\n      offset = vertical ? window.scrollY : window.scrollX;\n    }\n\n    let sections = visible.map(view => {\n      let {\n        index,\n        href\n      } = view.section;\n      let position = view.position();\n      let width = view.width();\n      let height = view.height();\n      let startPos;\n      let endPos;\n      let stopPos;\n      let totalPages;\n\n      if (vertical) {\n        startPos = offset + container.top - position.top + used;\n        endPos = startPos + pageHeight - used;\n        totalPages = this.layout.count(height, pageHeight).pages;\n        stopPos = pageHeight;\n      } else {\n        startPos = offset + container.left - position.left + used;\n        endPos = startPos + pageWidth - used;\n        totalPages = this.layout.count(width, pageWidth).pages;\n        stopPos = pageWidth;\n      }\n\n      let currPage = Math.ceil(startPos / stopPos);\n      let pages = [];\n      let endPage = Math.ceil(endPos / stopPos); // Reverse page counts for horizontal rtl\n\n      if (this.settings.direction === \"rtl\" && !vertical) {\n        let tempStartPage = currPage;\n        currPage = totalPages - endPage;\n        endPage = totalPages - tempStartPage;\n      }\n\n      pages = [];\n\n      for (var i = currPage; i <= endPage; i++) {\n        let pg = i + 1;\n        pages.push(pg);\n      }\n\n      let mapping = this.mapping.page(view.contents, view.section.cfiBase, startPos, endPos);\n      return {\n        index,\n        href,\n        pages,\n        totalPages,\n        mapping\n      };\n    });\n    return sections;\n  }\n\n  paginatedLocation() {\n    let visible = this.visible();\n    let container = this.container.getBoundingClientRect();\n    let left = 0;\n    let used = 0;\n\n    if (this.settings.fullsize) {\n      left = window.scrollX;\n    }\n\n    let sections = visible.map(view => {\n      let {\n        index,\n        href\n      } = view.section;\n      let offset;\n      let position = view.position();\n      let width = view.width(); // Find mapping\n\n      let start;\n      let end;\n      let pageWidth;\n\n      if (this.settings.direction === \"rtl\") {\n        offset = container.right - left;\n        pageWidth = Math.min(Math.abs(offset - position.left), this.layout.width) - used;\n        end = position.width - (position.right - offset) - used;\n        start = end - pageWidth;\n      } else {\n        offset = container.left + left;\n        pageWidth = Math.min(position.right - offset, this.layout.width) - used;\n        start = offset - position.left + used;\n        end = start + pageWidth;\n      }\n\n      used += pageWidth;\n      let mapping = this.mapping.page(view.contents, view.section.cfiBase, start, end);\n      let totalPages = this.layout.count(width).pages;\n      let startPage = Math.floor(start / this.layout.pageWidth);\n      let pages = [];\n      let endPage = Math.floor(end / this.layout.pageWidth); // start page should not be negative\n\n      if (startPage < 0) {\n        startPage = 0;\n        endPage = endPage + 1;\n      } // Reverse page counts for rtl\n\n\n      if (this.settings.direction === \"rtl\") {\n        let tempStartPage = startPage;\n        startPage = totalPages - endPage;\n        endPage = totalPages - tempStartPage;\n      }\n\n      for (var i = startPage + 1; i <= endPage; i++) {\n        let pg = i;\n        pages.push(pg);\n      }\n\n      return {\n        index,\n        href,\n        pages,\n        totalPages,\n        mapping\n      };\n    });\n    return sections;\n  }\n\n  isVisible(view, offsetPrev, offsetNext, _container) {\n    var position = view.position();\n\n    var container = _container || this.bounds();\n\n    if (this.settings.axis === \"horizontal\" && position.right > container.left - offsetPrev && position.left < container.right + offsetNext) {\n      return true;\n    } else if (this.settings.axis === \"vertical\" && position.bottom > container.top - offsetPrev && position.top < container.bottom + offsetNext) {\n      return true;\n    }\n\n    return false;\n  }\n\n  visible() {\n    var container = this.bounds();\n    var views = this.views.displayed();\n    var viewsLength = views.length;\n    var visible = [];\n    var isVisible;\n    var view;\n\n    for (var i = 0; i < viewsLength; i++) {\n      view = views[i];\n      isVisible = this.isVisible(view, 0, 0, container);\n\n      if (isVisible === true) {\n        visible.push(view);\n      }\n    }\n\n    return visible;\n  }\n\n  scrollBy(x, y, silent) {\n    let dir = this.settings.direction === \"rtl\" ? -1 : 1;\n\n    if (silent) {\n      this.ignore = true;\n    }\n\n    if (!this.settings.fullsize) {\n      if (x) this.container.scrollLeft += x * dir;\n      if (y) this.container.scrollTop += y;\n    } else {\n      window.scrollBy(x * dir, y * dir);\n    }\n\n    this.scrolled = true;\n  }\n\n  scrollTo(x, y, silent) {\n    if (silent) {\n      this.ignore = true;\n    }\n\n    if (!this.settings.fullsize) {\n      this.container.scrollLeft = x;\n      this.container.scrollTop = y;\n    } else {\n      window.scrollTo(x, y);\n    }\n\n    this.scrolled = true;\n  }\n\n  onScroll() {\n    let scrollTop;\n    let scrollLeft;\n\n    if (!this.settings.fullsize) {\n      scrollTop = this.container.scrollTop;\n      scrollLeft = this.container.scrollLeft;\n    } else {\n      scrollTop = window.scrollY;\n      scrollLeft = window.scrollX;\n    }\n\n    this.scrollTop = scrollTop;\n    this.scrollLeft = scrollLeft;\n\n    if (!this.ignore) {\n      this.emit(_constants.EVENTS.MANAGERS.SCROLL, {\n        top: scrollTop,\n        left: scrollLeft\n      });\n      clearTimeout(this.afterScrolled);\n      this.afterScrolled = setTimeout(function () {\n        this.emit(_constants.EVENTS.MANAGERS.SCROLLED, {\n          top: this.scrollTop,\n          left: this.scrollLeft\n        });\n      }.bind(this), 20);\n    } else {\n      this.ignore = false;\n    }\n  }\n\n  bounds() {\n    var bounds;\n    bounds = this.stage.bounds();\n    return bounds;\n  }\n\n  applyLayout(layout) {\n    this.layout = layout;\n    this.updateLayout();\n\n    if (this.views && this.views.length > 0 && this.layout.name === \"pre-paginated\") {\n      this.display(this.views.first().section);\n    } // this.manager.layout(this.layout.format);\n\n  }\n\n  updateLayout() {\n    if (!this.stage) {\n      return;\n    }\n\n    this._stageSize = this.stage.size();\n\n    if (!this.isPaginated) {\n      this.layout.calculate(this._stageSize.width, this._stageSize.height);\n    } else {\n      this.layout.calculate(this._stageSize.width, this._stageSize.height, this.settings.gap); // Set the look ahead offset for what is visible\n\n      this.settings.offset = this.layout.delta / this.layout.divisor; // this.stage.addStyleRules(\"iframe\", [{\"margin-right\" : this.layout.gap + \"px\"}]);\n    } // Set the dimensions for views\n\n\n    this.viewSettings.width = this.layout.width;\n    this.viewSettings.height = this.layout.height;\n    this.setLayout(this.layout);\n  }\n\n  setLayout(layout) {\n    this.viewSettings.layout = layout;\n    this.mapping = new _mapping.default(layout.props, this.settings.direction, this.settings.axis);\n\n    if (this.views) {\n      this.views.forEach(function (view) {\n        if (view) {\n          view.setLayout(layout);\n        }\n      });\n    }\n  }\n\n  updateWritingMode(mode) {\n    this.writingMode = mode;\n  }\n\n  updateAxis(axis, forceUpdate) {\n    if (!forceUpdate && axis === this.settings.axis) {\n      return;\n    }\n\n    this.settings.axis = axis;\n    this.stage && this.stage.axis(axis);\n    this.viewSettings.axis = axis;\n\n    if (this.mapping) {\n      this.mapping = new _mapping.default(this.layout.props, this.settings.direction, this.settings.axis);\n    }\n\n    if (this.layout) {\n      if (axis === \"vertical\") {\n        this.layout.spread(\"none\");\n      } else {\n        this.layout.spread(this.layout.settings.spread);\n      }\n    }\n  }\n\n  updateFlow(flow, defaultScrolledOverflow = \"auto\") {\n    let isPaginated = flow === \"paginated\" || flow === \"auto\";\n    this.isPaginated = isPaginated;\n\n    if (flow === \"scrolled-doc\" || flow === \"scrolled-continuous\" || flow === \"scrolled\") {\n      this.updateAxis(\"vertical\");\n    } else {\n      this.updateAxis(\"horizontal\");\n    }\n\n    this.viewSettings.flow = flow;\n\n    if (!this.settings.overflow) {\n      this.overflow = isPaginated ? \"hidden\" : defaultScrolledOverflow;\n    } else {\n      this.overflow = this.settings.overflow;\n    }\n\n    this.stage && this.stage.overflow(this.overflow);\n    this.updateLayout();\n  }\n\n  getContents() {\n    var contents = [];\n\n    if (!this.views) {\n      return contents;\n    }\n\n    this.views.forEach(function (view) {\n      const viewContents = view && view.contents;\n\n      if (viewContents) {\n        contents.push(viewContents);\n      }\n    });\n    return contents;\n  }\n\n  direction(dir = \"ltr\") {\n    this.settings.direction = dir;\n    this.stage && this.stage.direction(dir);\n    this.viewSettings.direction = dir;\n    this.updateLayout();\n  }\n\n  isRendered() {\n    return this.rendered;\n  }\n\n} //-- Enable binding events to Manager\n\n\n(0, _eventEmitter.default)(DefaultViewManager.prototype);\nvar _default = DefaultViewManager;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}