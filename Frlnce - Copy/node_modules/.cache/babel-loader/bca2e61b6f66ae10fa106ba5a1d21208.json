{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.Task = void 0;\n\nvar _core = require(\"./core\");\n/**\n * Queue for handling tasks one at a time\n * @class\n * @param {scope} context what this will resolve to in the tasks\n */\n\n\nclass Queue {\n  constructor(context) {\n    this._q = [];\n    this.context = context;\n    this.tick = _core.requestAnimationFrame;\n    this.running = false;\n    this.paused = false;\n  }\n  /**\n   * Add an item to the queue\n   * @return {Promise}\n   */\n\n\n  enqueue() {\n    var deferred, promise;\n    var queued;\n    var task = [].shift.call(arguments);\n    var args = arguments; // Handle single args without context\n    // if(args && !Array.isArray(args)) {\n    //   args = [args];\n    // }\n\n    if (!task) {\n      throw new Error(\"No Task Provided\");\n    }\n\n    if (typeof task === \"function\") {\n      deferred = new _core.defer();\n      promise = deferred.promise;\n      queued = {\n        \"task\": task,\n        \"args\": args,\n        //\"context\"  : context,\n        \"deferred\": deferred,\n        \"promise\": promise\n      };\n    } else {\n      // Task is a promise\n      queued = {\n        \"promise\": task\n      };\n    }\n\n    this._q.push(queued); // Wait to start queue flush\n\n\n    if (this.paused == false && !this.running) {\n      // setTimeout(this.flush.bind(this), 0);\n      // this.tick.call(window, this.run.bind(this));\n      this.run();\n    }\n\n    return queued.promise;\n  }\n  /**\n   * Run one item\n   * @return {Promise}\n   */\n\n\n  dequeue() {\n    var inwait, task, result;\n\n    if (this._q.length && !this.paused) {\n      inwait = this._q.shift();\n      task = inwait.task;\n\n      if (task) {\n        // console.log(task)\n        result = task.apply(this.context, inwait.args);\n\n        if (result && typeof result[\"then\"] === \"function\") {\n          // Task is a function that returns a promise\n          return result.then(function () {\n            inwait.deferred.resolve.apply(this.context, arguments);\n          }.bind(this), function () {\n            inwait.deferred.reject.apply(this.context, arguments);\n          }.bind(this));\n        } else {\n          // Task resolves immediately\n          inwait.deferred.resolve.apply(this.context, result);\n          return inwait.promise;\n        }\n      } else if (inwait.promise) {\n        // Task is a promise\n        return inwait.promise;\n      }\n    } else {\n      inwait = new _core.defer();\n      inwait.deferred.resolve();\n      return inwait.promise;\n    }\n  } // Run All Immediately\n\n\n  dump() {\n    while (this._q.length) {\n      this.dequeue();\n    }\n  }\n  /**\n   * Run all tasks sequentially, at convince\n   * @return {Promise}\n   */\n\n\n  run() {\n    if (!this.running) {\n      this.running = true;\n      this.defered = new _core.defer();\n    }\n\n    this.tick.call(window, () => {\n      if (this._q.length) {\n        this.dequeue().then(function () {\n          this.run();\n        }.bind(this));\n      } else {\n        this.defered.resolve();\n        this.running = undefined;\n      }\n    }); // Unpause\n\n    if (this.paused == true) {\n      this.paused = false;\n    }\n\n    return this.defered.promise;\n  }\n  /**\n   * Flush all, as quickly as possible\n   * @return {Promise}\n   */\n\n\n  flush() {\n    if (this.running) {\n      return this.running;\n    }\n\n    if (this._q.length) {\n      this.running = this.dequeue().then(function () {\n        this.running = undefined;\n        return this.flush();\n      }.bind(this));\n      return this.running;\n    }\n  }\n  /**\n   * Clear all items in wait\n   */\n\n\n  clear() {\n    this._q = [];\n  }\n  /**\n   * Get the number of tasks in the queue\n   * @return {number} tasks\n   */\n\n\n  length() {\n    return this._q.length;\n  }\n  /**\n   * Pause a running queue\n   */\n\n\n  pause() {\n    this.paused = true;\n  }\n  /**\n   * End the queue\n   */\n\n\n  stop() {\n    this._q = [];\n    this.running = false;\n    this.paused = true;\n  }\n\n}\n/**\n * Create a new task from a callback\n * @class\n * @private\n * @param {function} task\n * @param {array} args\n * @param {scope} context\n * @return {function} task\n */\n\n\nclass Task {\n  constructor(task, args, context) {\n    return function () {\n      var toApply = arguments || [];\n      return new Promise((resolve, reject) => {\n        var callback = function (value, err) {\n          if (!value && err) {\n            reject(err);\n          } else {\n            resolve(value);\n          }\n        }; // Add the callback to the arguments list\n\n\n        toApply.push(callback); // Apply all arguments to the functions\n\n        task.apply(context || this, toApply);\n      });\n    };\n  }\n\n}\n\nexports.Task = Task;\nvar _default = Queue;\nexports.default = _default;","map":{"version":3,"sources":["S:/REACT/Ract-Js/Frlnce/node_modules/epubjs/lib/utils/queue.js"],"names":["Object","defineProperty","exports","value","default","Task","_core","require","Queue","constructor","context","_q","tick","requestAnimationFrame","running","paused","enqueue","deferred","promise","queued","task","shift","call","arguments","args","Error","defer","push","run","dequeue","inwait","result","length","apply","then","resolve","bind","reject","dump","defered","window","undefined","flush","clear","pause","stop","toApply","Promise","callback","err","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.Task = void 0;\n\nvar _core = require(\"./core\");\n\n/**\n * Queue for handling tasks one at a time\n * @class\n * @param {scope} context what this will resolve to in the tasks\n */\nclass Queue {\n  constructor(context) {\n    this._q = [];\n    this.context = context;\n    this.tick = _core.requestAnimationFrame;\n    this.running = false;\n    this.paused = false;\n  }\n  /**\n   * Add an item to the queue\n   * @return {Promise}\n   */\n\n\n  enqueue() {\n    var deferred, promise;\n    var queued;\n    var task = [].shift.call(arguments);\n    var args = arguments; // Handle single args without context\n    // if(args && !Array.isArray(args)) {\n    //   args = [args];\n    // }\n\n    if (!task) {\n      throw new Error(\"No Task Provided\");\n    }\n\n    if (typeof task === \"function\") {\n      deferred = new _core.defer();\n      promise = deferred.promise;\n      queued = {\n        \"task\": task,\n        \"args\": args,\n        //\"context\"  : context,\n        \"deferred\": deferred,\n        \"promise\": promise\n      };\n    } else {\n      // Task is a promise\n      queued = {\n        \"promise\": task\n      };\n    }\n\n    this._q.push(queued); // Wait to start queue flush\n\n\n    if (this.paused == false && !this.running) {\n      // setTimeout(this.flush.bind(this), 0);\n      // this.tick.call(window, this.run.bind(this));\n      this.run();\n    }\n\n    return queued.promise;\n  }\n  /**\n   * Run one item\n   * @return {Promise}\n   */\n\n\n  dequeue() {\n    var inwait, task, result;\n\n    if (this._q.length && !this.paused) {\n      inwait = this._q.shift();\n      task = inwait.task;\n\n      if (task) {\n        // console.log(task)\n        result = task.apply(this.context, inwait.args);\n\n        if (result && typeof result[\"then\"] === \"function\") {\n          // Task is a function that returns a promise\n          return result.then(function () {\n            inwait.deferred.resolve.apply(this.context, arguments);\n          }.bind(this), function () {\n            inwait.deferred.reject.apply(this.context, arguments);\n          }.bind(this));\n        } else {\n          // Task resolves immediately\n          inwait.deferred.resolve.apply(this.context, result);\n          return inwait.promise;\n        }\n      } else if (inwait.promise) {\n        // Task is a promise\n        return inwait.promise;\n      }\n    } else {\n      inwait = new _core.defer();\n      inwait.deferred.resolve();\n      return inwait.promise;\n    }\n  } // Run All Immediately\n\n\n  dump() {\n    while (this._q.length) {\n      this.dequeue();\n    }\n  }\n  /**\n   * Run all tasks sequentially, at convince\n   * @return {Promise}\n   */\n\n\n  run() {\n    if (!this.running) {\n      this.running = true;\n      this.defered = new _core.defer();\n    }\n\n    this.tick.call(window, () => {\n      if (this._q.length) {\n        this.dequeue().then(function () {\n          this.run();\n        }.bind(this));\n      } else {\n        this.defered.resolve();\n        this.running = undefined;\n      }\n    }); // Unpause\n\n    if (this.paused == true) {\n      this.paused = false;\n    }\n\n    return this.defered.promise;\n  }\n  /**\n   * Flush all, as quickly as possible\n   * @return {Promise}\n   */\n\n\n  flush() {\n    if (this.running) {\n      return this.running;\n    }\n\n    if (this._q.length) {\n      this.running = this.dequeue().then(function () {\n        this.running = undefined;\n        return this.flush();\n      }.bind(this));\n      return this.running;\n    }\n  }\n  /**\n   * Clear all items in wait\n   */\n\n\n  clear() {\n    this._q = [];\n  }\n  /**\n   * Get the number of tasks in the queue\n   * @return {number} tasks\n   */\n\n\n  length() {\n    return this._q.length;\n  }\n  /**\n   * Pause a running queue\n   */\n\n\n  pause() {\n    this.paused = true;\n  }\n  /**\n   * End the queue\n   */\n\n\n  stop() {\n    this._q = [];\n    this.running = false;\n    this.paused = true;\n  }\n\n}\n/**\n * Create a new task from a callback\n * @class\n * @private\n * @param {function} task\n * @param {array} args\n * @param {scope} context\n * @return {function} task\n */\n\n\nclass Task {\n  constructor(task, args, context) {\n    return function () {\n      var toApply = arguments || [];\n      return new Promise((resolve, reject) => {\n        var callback = function (value, err) {\n          if (!value && err) {\n            reject(err);\n          } else {\n            resolve(value);\n          }\n        }; // Add the callback to the arguments list\n\n\n        toApply.push(callback); // Apply all arguments to the functions\n\n        task.apply(context || this, toApply);\n      });\n    };\n  }\n\n}\n\nexports.Task = Task;\nvar _default = Queue;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}