{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _core = require(\"./utils/core\");\n/**\n * Navigation Parser\n * @param {document} xml navigation html / xhtml / ncx\n */\n\n\nclass Navigation {\n  constructor(xml) {\n    this.toc = [];\n    this.tocByHref = {};\n    this.tocById = {};\n    this.landmarks = [];\n    this.landmarksByType = {};\n    this.length = 0;\n\n    if (xml) {\n      this.parse(xml);\n    }\n  }\n  /**\n   * Parse out the navigation items\n   * @param {document} xml navigation html / xhtml / ncx\n   */\n\n\n  parse(xml) {\n    let isXml = xml.nodeType;\n    let html;\n    let ncx;\n\n    if (isXml) {\n      html = (0, _core.qs)(xml, \"html\");\n      ncx = (0, _core.qs)(xml, \"ncx\");\n    }\n\n    if (!isXml) {\n      this.toc = this.load(xml);\n    } else if (html) {\n      this.toc = this.parseNav(xml);\n      this.landmarks = this.parseLandmarks(xml);\n    } else if (ncx) {\n      this.toc = this.parseNcx(xml);\n    }\n\n    this.length = 0;\n    this.unpack(this.toc);\n  }\n  /**\n   * Unpack navigation items\n   * @private\n   * @param  {array} toc\n   */\n\n\n  unpack(toc) {\n    var item;\n\n    for (var i = 0; i < toc.length; i++) {\n      item = toc[i];\n\n      if (item.href) {\n        this.tocByHref[item.href] = i;\n      }\n\n      if (item.id) {\n        this.tocById[item.id] = i;\n      }\n\n      this.length++;\n\n      if (item.subitems.length) {\n        this.unpack(item.subitems);\n      }\n    }\n  }\n  /**\n   * Get an item from the navigation\n   * @param  {string} target\n   * @return {object} navItem\n   */\n\n\n  get(target) {\n    var index;\n\n    if (!target) {\n      return this.toc;\n    }\n\n    if (target.indexOf(\"#\") === 0) {\n      index = this.tocById[target.substring(1)];\n    } else if (target in this.tocByHref) {\n      index = this.tocByHref[target];\n    }\n\n    return this.getByIndex(target, index, this.toc);\n  }\n  /**\n   * Get an item from navigation subitems recursively by index\n   * @param  {string} target\n   * @param  {number} index\n   * @param  {array} navItems\n   * @return {object} navItem\n   */\n\n\n  getByIndex(target, index, navItems) {\n    if (navItems.length === 0) {\n      return;\n    }\n\n    const item = navItems[index];\n\n    if (item && (target === item.id || target === item.href)) {\n      return item;\n    } else {\n      let result;\n\n      for (let i = 0; i < navItems.length; ++i) {\n        result = this.getByIndex(target, index, navItems[i].subitems);\n\n        if (result) {\n          break;\n        }\n      }\n\n      return result;\n    }\n  }\n  /**\n   * Get a landmark by type\n   * List of types: https://idpf.github.io/epub-vocabs/structure/\n   * @param  {string} type\n   * @return {object} landmarkItem\n   */\n\n\n  landmark(type) {\n    var index;\n\n    if (!type) {\n      return this.landmarks;\n    }\n\n    index = this.landmarksByType[type];\n    return this.landmarks[index];\n  }\n  /**\n   * Parse toc from a Epub > 3.0 Nav\n   * @private\n   * @param  {document} navHtml\n   * @return {array} navigation list\n   */\n\n\n  parseNav(navHtml) {\n    var navElement = (0, _core.querySelectorByType)(navHtml, \"nav\", \"toc\");\n    var list = [];\n    if (!navElement) return list;\n    let navList = (0, _core.filterChildren)(navElement, \"ol\", true);\n    if (!navList) return list;\n    list = this.parseNavList(navList);\n    return list;\n  }\n  /**\n   * Parses lists in the toc\n   * @param  {document} navListHtml\n   * @param  {string} parent id\n   * @return {array} navigation list\n   */\n\n\n  parseNavList(navListHtml, parent) {\n    const result = [];\n    if (!navListHtml) return result;\n    if (!navListHtml.children) return result;\n\n    for (let i = 0; i < navListHtml.children.length; i++) {\n      const item = this.navItem(navListHtml.children[i], parent);\n\n      if (item) {\n        result.push(item);\n      }\n    }\n\n    return result;\n  }\n  /**\n   * Create a navItem\n   * @private\n   * @param  {element} item\n   * @return {object} navItem\n   */\n\n\n  navItem(item, parent) {\n    let id = item.getAttribute(\"id\") || undefined;\n    let content = (0, _core.filterChildren)(item, \"a\", true) || (0, _core.filterChildren)(item, \"span\", true);\n\n    if (!content) {\n      return;\n    }\n\n    let src = content.getAttribute(\"href\") || \"\";\n\n    if (!id) {\n      id = src;\n    }\n\n    let text = content.textContent || \"\";\n    let subitems = [];\n    let nested = (0, _core.filterChildren)(item, \"ol\", true);\n\n    if (nested) {\n      subitems = this.parseNavList(nested, id);\n    }\n\n    return {\n      \"id\": id,\n      \"href\": src,\n      \"label\": text,\n      \"subitems\": subitems,\n      \"parent\": parent\n    };\n  }\n  /**\n   * Parse landmarks from a Epub > 3.0 Nav\n   * @private\n   * @param  {document} navHtml\n   * @return {array} landmarks list\n   */\n\n\n  parseLandmarks(navHtml) {\n    var navElement = (0, _core.querySelectorByType)(navHtml, \"nav\", \"landmarks\");\n    var navItems = navElement ? (0, _core.qsa)(navElement, \"li\") : [];\n    var length = navItems.length;\n    var i;\n    var list = [];\n    var item;\n    if (!navItems || length === 0) return list;\n\n    for (i = 0; i < length; ++i) {\n      item = this.landmarkItem(navItems[i]);\n\n      if (item) {\n        list.push(item);\n        this.landmarksByType[item.type] = i;\n      }\n    }\n\n    return list;\n  }\n  /**\n   * Create a landmarkItem\n   * @private\n   * @param  {element} item\n   * @return {object} landmarkItem\n   */\n\n\n  landmarkItem(item) {\n    let content = (0, _core.filterChildren)(item, \"a\", true);\n\n    if (!content) {\n      return;\n    }\n\n    let type = content.getAttributeNS(\"http://www.idpf.org/2007/ops\", \"type\") || undefined;\n    let href = content.getAttribute(\"href\") || \"\";\n    let text = content.textContent || \"\";\n    return {\n      \"href\": href,\n      \"label\": text,\n      \"type\": type\n    };\n  }\n  /**\n   * Parse from a Epub > 3.0 NC\n   * @private\n   * @param  {document} navHtml\n   * @return {array} navigation list\n   */\n\n\n  parseNcx(tocXml) {\n    var navPoints = (0, _core.qsa)(tocXml, \"navPoint\");\n    var length = navPoints.length;\n    var i;\n    var toc = {};\n    var list = [];\n    var item, parent;\n    if (!navPoints || length === 0) return list;\n\n    for (i = 0; i < length; ++i) {\n      item = this.ncxItem(navPoints[i]);\n      toc[item.id] = item;\n\n      if (!item.parent) {\n        list.push(item);\n      } else {\n        parent = toc[item.parent];\n        parent.subitems.push(item);\n      }\n    }\n\n    return list;\n  }\n  /**\n   * Create a ncxItem\n   * @private\n   * @param  {element} item\n   * @return {object} ncxItem\n   */\n\n\n  ncxItem(item) {\n    var id = item.getAttribute(\"id\") || false,\n        content = (0, _core.qs)(item, \"content\"),\n        src = content.getAttribute(\"src\"),\n        navLabel = (0, _core.qs)(item, \"navLabel\"),\n        text = navLabel.textContent ? navLabel.textContent : \"\",\n        subitems = [],\n        parentNode = item.parentNode,\n        parent;\n\n    if (parentNode && (parentNode.nodeName === \"navPoint\" || parentNode.nodeName.split(':').slice(-1)[0] === \"navPoint\")) {\n      parent = parentNode.getAttribute(\"id\");\n    }\n\n    return {\n      \"id\": id,\n      \"href\": src,\n      \"label\": text,\n      \"subitems\": subitems,\n      \"parent\": parent\n    };\n  }\n  /**\n   * Load Spine Items\n   * @param  {object} json the items to be loaded\n   * @return {Array} navItems\n   */\n\n\n  load(json) {\n    return json.map(item => {\n      item.label = item.title;\n      item.subitems = item.children ? this.load(item.children) : [];\n      return item;\n    });\n  }\n  /**\n   * forEach pass through\n   * @param  {Function} fn function to run on each item\n   * @return {method} forEach loop\n   */\n\n\n  forEach(fn) {\n    return this.toc.forEach(fn);\n  }\n\n}\n\nvar _default = Navigation;\nexports.default = _default;","map":{"version":3,"sources":["S:/REACT/Ract-Js/Frlnce/node_modules/epubjs/lib/navigation.js"],"names":["Object","defineProperty","exports","value","default","_core","require","Navigation","constructor","xml","toc","tocByHref","tocById","landmarks","landmarksByType","length","parse","isXml","nodeType","html","ncx","qs","load","parseNav","parseLandmarks","parseNcx","unpack","item","i","href","id","subitems","get","target","index","indexOf","substring","getByIndex","navItems","result","landmark","type","navHtml","navElement","querySelectorByType","list","navList","filterChildren","parseNavList","navListHtml","parent","children","navItem","push","getAttribute","undefined","content","src","text","textContent","nested","qsa","landmarkItem","getAttributeNS","tocXml","navPoints","ncxItem","navLabel","parentNode","nodeName","split","slice","json","map","label","title","forEach","fn","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _core = require(\"./utils/core\");\n\n/**\n * Navigation Parser\n * @param {document} xml navigation html / xhtml / ncx\n */\nclass Navigation {\n  constructor(xml) {\n    this.toc = [];\n    this.tocByHref = {};\n    this.tocById = {};\n    this.landmarks = [];\n    this.landmarksByType = {};\n    this.length = 0;\n\n    if (xml) {\n      this.parse(xml);\n    }\n  }\n  /**\n   * Parse out the navigation items\n   * @param {document} xml navigation html / xhtml / ncx\n   */\n\n\n  parse(xml) {\n    let isXml = xml.nodeType;\n    let html;\n    let ncx;\n\n    if (isXml) {\n      html = (0, _core.qs)(xml, \"html\");\n      ncx = (0, _core.qs)(xml, \"ncx\");\n    }\n\n    if (!isXml) {\n      this.toc = this.load(xml);\n    } else if (html) {\n      this.toc = this.parseNav(xml);\n      this.landmarks = this.parseLandmarks(xml);\n    } else if (ncx) {\n      this.toc = this.parseNcx(xml);\n    }\n\n    this.length = 0;\n    this.unpack(this.toc);\n  }\n  /**\n   * Unpack navigation items\n   * @private\n   * @param  {array} toc\n   */\n\n\n  unpack(toc) {\n    var item;\n\n    for (var i = 0; i < toc.length; i++) {\n      item = toc[i];\n\n      if (item.href) {\n        this.tocByHref[item.href] = i;\n      }\n\n      if (item.id) {\n        this.tocById[item.id] = i;\n      }\n\n      this.length++;\n\n      if (item.subitems.length) {\n        this.unpack(item.subitems);\n      }\n    }\n  }\n  /**\n   * Get an item from the navigation\n   * @param  {string} target\n   * @return {object} navItem\n   */\n\n\n  get(target) {\n    var index;\n\n    if (!target) {\n      return this.toc;\n    }\n\n    if (target.indexOf(\"#\") === 0) {\n      index = this.tocById[target.substring(1)];\n    } else if (target in this.tocByHref) {\n      index = this.tocByHref[target];\n    }\n\n    return this.getByIndex(target, index, this.toc);\n  }\n  /**\n   * Get an item from navigation subitems recursively by index\n   * @param  {string} target\n   * @param  {number} index\n   * @param  {array} navItems\n   * @return {object} navItem\n   */\n\n\n  getByIndex(target, index, navItems) {\n    if (navItems.length === 0) {\n      return;\n    }\n\n    const item = navItems[index];\n\n    if (item && (target === item.id || target === item.href)) {\n      return item;\n    } else {\n      let result;\n\n      for (let i = 0; i < navItems.length; ++i) {\n        result = this.getByIndex(target, index, navItems[i].subitems);\n\n        if (result) {\n          break;\n        }\n      }\n\n      return result;\n    }\n  }\n  /**\n   * Get a landmark by type\n   * List of types: https://idpf.github.io/epub-vocabs/structure/\n   * @param  {string} type\n   * @return {object} landmarkItem\n   */\n\n\n  landmark(type) {\n    var index;\n\n    if (!type) {\n      return this.landmarks;\n    }\n\n    index = this.landmarksByType[type];\n    return this.landmarks[index];\n  }\n  /**\n   * Parse toc from a Epub > 3.0 Nav\n   * @private\n   * @param  {document} navHtml\n   * @return {array} navigation list\n   */\n\n\n  parseNav(navHtml) {\n    var navElement = (0, _core.querySelectorByType)(navHtml, \"nav\", \"toc\");\n    var list = [];\n    if (!navElement) return list;\n    let navList = (0, _core.filterChildren)(navElement, \"ol\", true);\n    if (!navList) return list;\n    list = this.parseNavList(navList);\n    return list;\n  }\n  /**\n   * Parses lists in the toc\n   * @param  {document} navListHtml\n   * @param  {string} parent id\n   * @return {array} navigation list\n   */\n\n\n  parseNavList(navListHtml, parent) {\n    const result = [];\n    if (!navListHtml) return result;\n    if (!navListHtml.children) return result;\n\n    for (let i = 0; i < navListHtml.children.length; i++) {\n      const item = this.navItem(navListHtml.children[i], parent);\n\n      if (item) {\n        result.push(item);\n      }\n    }\n\n    return result;\n  }\n  /**\n   * Create a navItem\n   * @private\n   * @param  {element} item\n   * @return {object} navItem\n   */\n\n\n  navItem(item, parent) {\n    let id = item.getAttribute(\"id\") || undefined;\n    let content = (0, _core.filterChildren)(item, \"a\", true) || (0, _core.filterChildren)(item, \"span\", true);\n\n    if (!content) {\n      return;\n    }\n\n    let src = content.getAttribute(\"href\") || \"\";\n\n    if (!id) {\n      id = src;\n    }\n\n    let text = content.textContent || \"\";\n    let subitems = [];\n    let nested = (0, _core.filterChildren)(item, \"ol\", true);\n\n    if (nested) {\n      subitems = this.parseNavList(nested, id);\n    }\n\n    return {\n      \"id\": id,\n      \"href\": src,\n      \"label\": text,\n      \"subitems\": subitems,\n      \"parent\": parent\n    };\n  }\n  /**\n   * Parse landmarks from a Epub > 3.0 Nav\n   * @private\n   * @param  {document} navHtml\n   * @return {array} landmarks list\n   */\n\n\n  parseLandmarks(navHtml) {\n    var navElement = (0, _core.querySelectorByType)(navHtml, \"nav\", \"landmarks\");\n    var navItems = navElement ? (0, _core.qsa)(navElement, \"li\") : [];\n    var length = navItems.length;\n    var i;\n    var list = [];\n    var item;\n    if (!navItems || length === 0) return list;\n\n    for (i = 0; i < length; ++i) {\n      item = this.landmarkItem(navItems[i]);\n\n      if (item) {\n        list.push(item);\n        this.landmarksByType[item.type] = i;\n      }\n    }\n\n    return list;\n  }\n  /**\n   * Create a landmarkItem\n   * @private\n   * @param  {element} item\n   * @return {object} landmarkItem\n   */\n\n\n  landmarkItem(item) {\n    let content = (0, _core.filterChildren)(item, \"a\", true);\n\n    if (!content) {\n      return;\n    }\n\n    let type = content.getAttributeNS(\"http://www.idpf.org/2007/ops\", \"type\") || undefined;\n    let href = content.getAttribute(\"href\") || \"\";\n    let text = content.textContent || \"\";\n    return {\n      \"href\": href,\n      \"label\": text,\n      \"type\": type\n    };\n  }\n  /**\n   * Parse from a Epub > 3.0 NC\n   * @private\n   * @param  {document} navHtml\n   * @return {array} navigation list\n   */\n\n\n  parseNcx(tocXml) {\n    var navPoints = (0, _core.qsa)(tocXml, \"navPoint\");\n    var length = navPoints.length;\n    var i;\n    var toc = {};\n    var list = [];\n    var item, parent;\n    if (!navPoints || length === 0) return list;\n\n    for (i = 0; i < length; ++i) {\n      item = this.ncxItem(navPoints[i]);\n      toc[item.id] = item;\n\n      if (!item.parent) {\n        list.push(item);\n      } else {\n        parent = toc[item.parent];\n        parent.subitems.push(item);\n      }\n    }\n\n    return list;\n  }\n  /**\n   * Create a ncxItem\n   * @private\n   * @param  {element} item\n   * @return {object} ncxItem\n   */\n\n\n  ncxItem(item) {\n    var id = item.getAttribute(\"id\") || false,\n        content = (0, _core.qs)(item, \"content\"),\n        src = content.getAttribute(\"src\"),\n        navLabel = (0, _core.qs)(item, \"navLabel\"),\n        text = navLabel.textContent ? navLabel.textContent : \"\",\n        subitems = [],\n        parentNode = item.parentNode,\n        parent;\n\n    if (parentNode && (parentNode.nodeName === \"navPoint\" || parentNode.nodeName.split(':').slice(-1)[0] === \"navPoint\")) {\n      parent = parentNode.getAttribute(\"id\");\n    }\n\n    return {\n      \"id\": id,\n      \"href\": src,\n      \"label\": text,\n      \"subitems\": subitems,\n      \"parent\": parent\n    };\n  }\n  /**\n   * Load Spine Items\n   * @param  {object} json the items to be loaded\n   * @return {Array} navItems\n   */\n\n\n  load(json) {\n    return json.map(item => {\n      item.label = item.title;\n      item.subitems = item.children ? this.load(item.children) : [];\n      return item;\n    });\n  }\n  /**\n   * forEach pass through\n   * @param  {Function} fn function to run on each item\n   * @return {method} forEach loop\n   */\n\n\n  forEach(fn) {\n    return this.toc.forEach(fn);\n  }\n\n}\n\nvar _default = Navigation;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}