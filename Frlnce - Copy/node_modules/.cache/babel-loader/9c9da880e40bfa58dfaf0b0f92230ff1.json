{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _epubcfi = _interopRequireDefault(require(\"./epubcfi\"));\n\nvar _hook = _interopRequireDefault(require(\"./utils/hook\"));\n\nvar _section = _interopRequireDefault(require(\"./section\"));\n\nvar _replacements = require(\"./utils/replacements\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * A collection of Spine Items\n */\n\n\nclass Spine {\n  constructor() {\n    this.spineItems = [];\n    this.spineByHref = {};\n    this.spineById = {};\n    this.hooks = {};\n    this.hooks.serialize = new _hook.default();\n    this.hooks.content = new _hook.default(); // Register replacements\n\n    this.hooks.content.register(_replacements.replaceBase);\n    this.hooks.content.register(_replacements.replaceCanonical);\n    this.hooks.content.register(_replacements.replaceMeta);\n    this.epubcfi = new _epubcfi.default();\n    this.loaded = false;\n    this.items = undefined;\n    this.manifest = undefined;\n    this.spineNodeIndex = undefined;\n    this.baseUrl = undefined;\n    this.length = undefined;\n  }\n  /**\n   * Unpack items from a opf into spine items\n   * @param  {Packaging} _package\n   * @param  {method} resolver URL resolver\n   * @param  {method} canonical Resolve canonical url\n   */\n\n\n  unpack(_package, resolver, canonical) {\n    this.items = _package.spine;\n    this.manifest = _package.manifest;\n    this.spineNodeIndex = _package.spineNodeIndex;\n    this.baseUrl = _package.baseUrl || _package.basePath || \"\";\n    this.length = this.items.length;\n    this.items.forEach((item, index) => {\n      var manifestItem = this.manifest[item.idref];\n      var spineItem;\n      item.index = index;\n      item.cfiBase = this.epubcfi.generateChapterComponent(this.spineNodeIndex, item.index, item.id);\n\n      if (item.href) {\n        item.url = resolver(item.href, true);\n        item.canonical = canonical(item.href);\n      }\n\n      if (manifestItem) {\n        item.href = manifestItem.href;\n        item.url = resolver(item.href, true);\n        item.canonical = canonical(item.href);\n\n        if (manifestItem.properties.length) {\n          item.properties.push.apply(item.properties, manifestItem.properties);\n        }\n      }\n\n      if (item.linear === \"yes\") {\n        item.prev = function () {\n          let prevIndex = item.index;\n\n          while (prevIndex > 0) {\n            let prev = this.get(prevIndex - 1);\n\n            if (prev && prev.linear) {\n              return prev;\n            }\n\n            prevIndex -= 1;\n          }\n\n          return;\n        }.bind(this);\n\n        item.next = function () {\n          let nextIndex = item.index;\n\n          while (nextIndex < this.spineItems.length - 1) {\n            let next = this.get(nextIndex + 1);\n\n            if (next && next.linear) {\n              return next;\n            }\n\n            nextIndex += 1;\n          }\n\n          return;\n        }.bind(this);\n      } else {\n        item.prev = function () {\n          return;\n        };\n\n        item.next = function () {\n          return;\n        };\n      }\n\n      spineItem = new _section.default(item, this.hooks);\n      this.append(spineItem);\n    });\n    this.loaded = true;\n  }\n  /**\n   * Get an item from the spine\n   * @param  {string|number} [target]\n   * @return {Section} section\n   * @example spine.get();\n   * @example spine.get(1);\n   * @example spine.get(\"chap1.html\");\n   * @example spine.get(\"#id1234\");\n   */\n\n\n  get(target) {\n    var index = 0;\n\n    if (typeof target === \"undefined\") {\n      while (index < this.spineItems.length) {\n        let next = this.spineItems[index];\n\n        if (next && next.linear) {\n          break;\n        }\n\n        index += 1;\n      }\n    } else if (this.epubcfi.isCfiString(target)) {\n      let cfi = new _epubcfi.default(target);\n      index = cfi.spinePos;\n    } else if (typeof target === \"number\" || isNaN(target) === false) {\n      index = target;\n    } else if (typeof target === \"string\" && target.indexOf(\"#\") === 0) {\n      index = this.spineById[target.substring(1)];\n    } else if (typeof target === \"string\") {\n      // Remove fragments\n      target = target.split(\"#\")[0];\n      index = this.spineByHref[target] || this.spineByHref[encodeURI(target)];\n    }\n\n    return this.spineItems[index] || null;\n  }\n  /**\n   * Append a Section to the Spine\n   * @private\n   * @param  {Section} section\n   */\n\n\n  append(section) {\n    var index = this.spineItems.length;\n    section.index = index;\n    this.spineItems.push(section); // Encode and Decode href lookups\n    // see pr for details: https://github.com/futurepress/epub.js/pull/358\n\n    this.spineByHref[decodeURI(section.href)] = index;\n    this.spineByHref[encodeURI(section.href)] = index;\n    this.spineByHref[section.href] = index;\n    this.spineById[section.idref] = index;\n    return index;\n  }\n  /**\n   * Prepend a Section to the Spine\n   * @private\n   * @param  {Section} section\n   */\n\n\n  prepend(section) {\n    // var index = this.spineItems.unshift(section);\n    this.spineByHref[section.href] = 0;\n    this.spineById[section.idref] = 0; // Re-index\n\n    this.spineItems.forEach(function (item, index) {\n      item.index = index;\n    });\n    return 0;\n  } // insert(section, index) {\n  //\n  // };\n\n  /**\n   * Remove a Section from the Spine\n   * @private\n   * @param  {Section} section\n   */\n\n\n  remove(section) {\n    var index = this.spineItems.indexOf(section);\n\n    if (index > -1) {\n      delete this.spineByHref[section.href];\n      delete this.spineById[section.idref];\n      return this.spineItems.splice(index, 1);\n    }\n  }\n  /**\n   * Loop over the Sections in the Spine\n   * @return {method} forEach\n   */\n\n\n  each() {\n    return this.spineItems.forEach.apply(this.spineItems, arguments);\n  }\n  /**\n   * Find the first Section in the Spine\n   * @return {Section} first section\n   */\n\n\n  first() {\n    let index = 0;\n\n    do {\n      let next = this.get(index);\n\n      if (next && next.linear) {\n        return next;\n      }\n\n      index += 1;\n    } while (index < this.spineItems.length);\n  }\n  /**\n   * Find the last Section in the Spine\n   * @return {Section} last section\n   */\n\n\n  last() {\n    let index = this.spineItems.length - 1;\n\n    do {\n      let prev = this.get(index);\n\n      if (prev && prev.linear) {\n        return prev;\n      }\n\n      index -= 1;\n    } while (index >= 0);\n  }\n\n  destroy() {\n    this.each(section => section.destroy());\n    this.spineItems = undefined;\n    this.spineByHref = undefined;\n    this.spineById = undefined;\n    this.hooks.serialize.clear();\n    this.hooks.content.clear();\n    this.hooks = undefined;\n    this.epubcfi = undefined;\n    this.loaded = false;\n    this.items = undefined;\n    this.manifest = undefined;\n    this.spineNodeIndex = undefined;\n    this.baseUrl = undefined;\n    this.length = undefined;\n  }\n\n}\n\nvar _default = Spine;\nexports.default = _default;","map":{"version":3,"sources":["S:/REACT/Ract-Js/Frlnce/node_modules/epubjs/lib/spine.js"],"names":["Object","defineProperty","exports","value","default","_epubcfi","_interopRequireDefault","require","_hook","_section","_replacements","obj","__esModule","Spine","constructor","spineItems","spineByHref","spineById","hooks","serialize","content","register","replaceBase","replaceCanonical","replaceMeta","epubcfi","loaded","items","undefined","manifest","spineNodeIndex","baseUrl","length","unpack","_package","resolver","canonical","spine","basePath","forEach","item","index","manifestItem","idref","spineItem","cfiBase","generateChapterComponent","id","href","url","properties","push","apply","linear","prev","prevIndex","get","bind","next","nextIndex","append","target","isCfiString","cfi","spinePos","isNaN","indexOf","substring","split","encodeURI","section","decodeURI","prepend","remove","splice","each","arguments","first","last","destroy","clear","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _epubcfi = _interopRequireDefault(require(\"./epubcfi\"));\n\nvar _hook = _interopRequireDefault(require(\"./utils/hook\"));\n\nvar _section = _interopRequireDefault(require(\"./section\"));\n\nvar _replacements = require(\"./utils/replacements\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * A collection of Spine Items\n */\nclass Spine {\n  constructor() {\n    this.spineItems = [];\n    this.spineByHref = {};\n    this.spineById = {};\n    this.hooks = {};\n    this.hooks.serialize = new _hook.default();\n    this.hooks.content = new _hook.default(); // Register replacements\n\n    this.hooks.content.register(_replacements.replaceBase);\n    this.hooks.content.register(_replacements.replaceCanonical);\n    this.hooks.content.register(_replacements.replaceMeta);\n    this.epubcfi = new _epubcfi.default();\n    this.loaded = false;\n    this.items = undefined;\n    this.manifest = undefined;\n    this.spineNodeIndex = undefined;\n    this.baseUrl = undefined;\n    this.length = undefined;\n  }\n  /**\n   * Unpack items from a opf into spine items\n   * @param  {Packaging} _package\n   * @param  {method} resolver URL resolver\n   * @param  {method} canonical Resolve canonical url\n   */\n\n\n  unpack(_package, resolver, canonical) {\n    this.items = _package.spine;\n    this.manifest = _package.manifest;\n    this.spineNodeIndex = _package.spineNodeIndex;\n    this.baseUrl = _package.baseUrl || _package.basePath || \"\";\n    this.length = this.items.length;\n    this.items.forEach((item, index) => {\n      var manifestItem = this.manifest[item.idref];\n      var spineItem;\n      item.index = index;\n      item.cfiBase = this.epubcfi.generateChapterComponent(this.spineNodeIndex, item.index, item.id);\n\n      if (item.href) {\n        item.url = resolver(item.href, true);\n        item.canonical = canonical(item.href);\n      }\n\n      if (manifestItem) {\n        item.href = manifestItem.href;\n        item.url = resolver(item.href, true);\n        item.canonical = canonical(item.href);\n\n        if (manifestItem.properties.length) {\n          item.properties.push.apply(item.properties, manifestItem.properties);\n        }\n      }\n\n      if (item.linear === \"yes\") {\n        item.prev = function () {\n          let prevIndex = item.index;\n\n          while (prevIndex > 0) {\n            let prev = this.get(prevIndex - 1);\n\n            if (prev && prev.linear) {\n              return prev;\n            }\n\n            prevIndex -= 1;\n          }\n\n          return;\n        }.bind(this);\n\n        item.next = function () {\n          let nextIndex = item.index;\n\n          while (nextIndex < this.spineItems.length - 1) {\n            let next = this.get(nextIndex + 1);\n\n            if (next && next.linear) {\n              return next;\n            }\n\n            nextIndex += 1;\n          }\n\n          return;\n        }.bind(this);\n      } else {\n        item.prev = function () {\n          return;\n        };\n\n        item.next = function () {\n          return;\n        };\n      }\n\n      spineItem = new _section.default(item, this.hooks);\n      this.append(spineItem);\n    });\n    this.loaded = true;\n  }\n  /**\n   * Get an item from the spine\n   * @param  {string|number} [target]\n   * @return {Section} section\n   * @example spine.get();\n   * @example spine.get(1);\n   * @example spine.get(\"chap1.html\");\n   * @example spine.get(\"#id1234\");\n   */\n\n\n  get(target) {\n    var index = 0;\n\n    if (typeof target === \"undefined\") {\n      while (index < this.spineItems.length) {\n        let next = this.spineItems[index];\n\n        if (next && next.linear) {\n          break;\n        }\n\n        index += 1;\n      }\n    } else if (this.epubcfi.isCfiString(target)) {\n      let cfi = new _epubcfi.default(target);\n      index = cfi.spinePos;\n    } else if (typeof target === \"number\" || isNaN(target) === false) {\n      index = target;\n    } else if (typeof target === \"string\" && target.indexOf(\"#\") === 0) {\n      index = this.spineById[target.substring(1)];\n    } else if (typeof target === \"string\") {\n      // Remove fragments\n      target = target.split(\"#\")[0];\n      index = this.spineByHref[target] || this.spineByHref[encodeURI(target)];\n    }\n\n    return this.spineItems[index] || null;\n  }\n  /**\n   * Append a Section to the Spine\n   * @private\n   * @param  {Section} section\n   */\n\n\n  append(section) {\n    var index = this.spineItems.length;\n    section.index = index;\n    this.spineItems.push(section); // Encode and Decode href lookups\n    // see pr for details: https://github.com/futurepress/epub.js/pull/358\n\n    this.spineByHref[decodeURI(section.href)] = index;\n    this.spineByHref[encodeURI(section.href)] = index;\n    this.spineByHref[section.href] = index;\n    this.spineById[section.idref] = index;\n    return index;\n  }\n  /**\n   * Prepend a Section to the Spine\n   * @private\n   * @param  {Section} section\n   */\n\n\n  prepend(section) {\n    // var index = this.spineItems.unshift(section);\n    this.spineByHref[section.href] = 0;\n    this.spineById[section.idref] = 0; // Re-index\n\n    this.spineItems.forEach(function (item, index) {\n      item.index = index;\n    });\n    return 0;\n  } // insert(section, index) {\n  //\n  // };\n\n  /**\n   * Remove a Section from the Spine\n   * @private\n   * @param  {Section} section\n   */\n\n\n  remove(section) {\n    var index = this.spineItems.indexOf(section);\n\n    if (index > -1) {\n      delete this.spineByHref[section.href];\n      delete this.spineById[section.idref];\n      return this.spineItems.splice(index, 1);\n    }\n  }\n  /**\n   * Loop over the Sections in the Spine\n   * @return {method} forEach\n   */\n\n\n  each() {\n    return this.spineItems.forEach.apply(this.spineItems, arguments);\n  }\n  /**\n   * Find the first Section in the Spine\n   * @return {Section} first section\n   */\n\n\n  first() {\n    let index = 0;\n\n    do {\n      let next = this.get(index);\n\n      if (next && next.linear) {\n        return next;\n      }\n\n      index += 1;\n    } while (index < this.spineItems.length);\n  }\n  /**\n   * Find the last Section in the Spine\n   * @return {Section} last section\n   */\n\n\n  last() {\n    let index = this.spineItems.length - 1;\n\n    do {\n      let prev = this.get(index);\n\n      if (prev && prev.linear) {\n        return prev;\n      }\n\n      index -= 1;\n    } while (index >= 0);\n  }\n\n  destroy() {\n    this.each(section => section.destroy());\n    this.spineItems = undefined;\n    this.spineByHref = undefined;\n    this.spineById = undefined;\n    this.hooks.serialize.clear();\n    this.hooks.content.clear();\n    this.hooks = undefined;\n    this.epubcfi = undefined;\n    this.loaded = false;\n    this.items = undefined;\n    this.manifest = undefined;\n    this.spineNodeIndex = undefined;\n    this.baseUrl = undefined;\n    this.length = undefined;\n  }\n\n}\n\nvar _default = Spine;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}